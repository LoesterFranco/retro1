ca65 V2.15 - Git a85ac88
Main file   : a1basic.s
Current file: a1basic.s

000000r 1               .setcpu "65C02"
000000r 1               .include "acia.s65"
000000r 2               IO_AREA = $A000
000000r 2               ACIAdata	= IO_AREA		; simulated ACIA r/w port
000000r 2               ACIAstatus  = IO_AREA+1
000000r 2               ACIAcommand = IO_AREA+2
000000r 2               ACIAcontrol = IO_AREA+3
000000r 2               
000000r 2               
000000r 2               
000000r 1               
000000r 1               .feature force_range
000000r 1               ; Apple 1 BASIC
000000r 1               ;
000000r 1               ; Modifications to build with CC65 by Jeff Tranter <tranter@pobox.com>
000000r 1               ;
000000r 1               ; Apple 1 BASIC was written by Steve Wozniak
000000r 1               ; Uses disassembly copyright 2003 Eric Smith <eric@brouhaha.com>
000000r 1               ; http://www.brouhaha.com/~eric/retrocomputing/apple/apple1/basic/
000000r 1               ;read this for more info: http://www.sbprojects.com/projects/apple1/wozmon.php
000000r 1               Z1d     =       $1D
000000r 1               ch      =       $24     ; horizontal cursor location
000000r 1               var     =       $48
000000r 1               lomem   =       $4A     ; lower limit of memory used by BASIC (2 bytes)
000000r 1               himem   =       $4C     ; upper limit of memory used by BASIC (2 bytes)
000000r 1               rnd     =       $4E     ; random number (2 bytes)
000000r 1               
000000r 1               
000000r 1               
000000r 1               
000000r 1               
000000r 1               ;reset:		 START
000000r 1               
000000r 1               ; The noun stack and syntax stack appear to overlap, which is OK since
000000r 1               ; they apparently are not used simultaneously.
000000r 1               
000000r 1               ; The noun stack size appears to be 32 entries, based on LDX #$20
000000r 1               ; instruction at e67f.  However, there seems to be enough room for
000000r 1               ; another 8 entries.  The noun stack builds down from noun_stk_<part>+$1f
000000r 1               ; to noun_stk_<part>+$00, indexed by the X register.
000000r 1               
000000r 1               ; Noun stack usage appears to be:
000000r 1               ;   integer:
000000r 1               ;       (noun_stk_h_int,noun_stk_l) = value
000000r 1               ;       noun_stk_h_str = 0
000000r 1               ;   string:
000000r 1               ;       (noun_stk_h_str,noun_stk_l) = pointer to string
000000r 1               ;       noun_stk_h_int = any
000000r 1               ; Since noun_stk_h_str determines whether stack entry is integer or string,
000000r 1               ; strings can't start in zero page.
000000r 1               
000000r 1               
000000r 1               
000000r 1               noun_stk_l =    $50
000000r 1               syn_stk_h =     $58     ; through $77
000000r 1               noun_stk_h_str = $78
000000r 1               syn_stk_l  =    $80     ; through $9F
000000r 1               noun_stk_h_int = $A0
000000r 1               txtndxstk  =    $A8     ; through $C7
000000r 1               text_index =    $C8     ; index into text being tokenized (in buffer at $0200)
000000r 1               leadbl  =       $C9     ; leading blanks
000000r 1               pp      =       $CA     ; pointer to end of program (2 bytes)
000000r 1               pv      =       $CC     ; pointer to end of variable storage (2 bytes)
000000r 1               acc     =       $CE     ; (2 bytes)
000000r 1               srch    =       $D0
000000r 1               tokndxstk =     $D1
000000r 1               srch2   =       $D2
000000r 1               if_flag =       $D4
000000r 1               cr_flag =       $D5
000000r 1               current_verb =  $D6
000000r 1               precedence =    $D7
000000r 1               x_save  =       $D8
000000r 1               run_flag =      $D9
000000r 1               aux     =       $DA
000000r 1               pline   =       $DC     ; pointer to current program line (2 bytes)
000000r 1               pverb   =       $E0     ; pointer to current verb (2 bytes)
000000r 1               p1      =       $E2
000000r 1               p2      =       $E4
000000r 1               p3      =       $E6
000000r 1               token_index =   $F1    ; pointer used to write tokens into buffer  2 bytes)
000000r 1               pcon    =       $F2    ; temp used in decimal output (2 bytes)
000000r 1               auto_inc =      $F4
000000r 1               auto_ln =       $F6
000000r 1               auto_flag =     $F8
000000r 1               char    =       $F9
000000r 1               leadzr  =       $FA
000000r 1               for_nest_count = $FB    ; count of active (nested) FOR loops
000000r 1               gosub_nest_count = $FC  ; count of active (nested) subroutines calls (GOSUB)
000000r 1               synstkdx =      $FD
000000r 1               synpag  =       $FE
000000r 1               
000000r 1               ; GOSUB stack, max eight entries
000000r 1               ; note that the Apple II version has sixteen entries
000000r 1               gstk_pverbl     =       $0100    ; saved pverb
000000r 1               gstk_pverbh     =       $0108
000000r 1               gstk_plinel     =       $0110    ; saved pline
000000r 1               gstk_plineh     =       $0118
000000r 1               
000000r 1               ; FOR stack, max eight entries
000000r 1               ; note that the Apple II version has sixteen entries
000000r 1               fstk_varl       =       $0120   ; pointer to index variable
000000r 1               fstk_varh       =       $0128
000000r 1               fstk_stepl      =       $0130   ; step value
000000r 1               fstk_steph      =       $0138
000000r 1               fstk_plinel     =       $0140   ; saved pline
000000r 1               fstk_plineh     =       $0148
000000r 1               fstk_pverbl     =       $0150   ; saved pverb
000000r 1               fstk_pverbh     =       $0158
000000r 1               fstk_tol        =       $0160   ; "to" (limit) value
000000r 1               fstk_toh        =       $0168
000000r 1               buffer  =       $0200
000000r 1               ;KBD     =       $D010
000000r 1               KBDCR   =       $D011
000000r 1               DSP     =       $D012
000000r 1               
000000r 1                       ;.org    $8000;test2
000000r 1                       .segment "VECTORS"
000000r 1               
000000r 1  rr rr                  .word   START
000002r 1  rr rr                  .word   START
000004r 1  rr rr                  .word   START
000006r 1               
000006r 1                         .code
000000r 1                       .export START
000000r 1               START:
000000r 1  A9 00                LDA	#$00            ;init acia
000002r 1  8D 01 A0     	    STA	ACIAstatus		; Soft reset
000005r 1  A9 0B        	    LDA	#$0B
000007r 1  8D 02 A0     	    STA	ACIAcommand		; Parity disabled, IRQ disabled
00000Ar 1  A9 1F        	    LDA	#$1F
00000Cr 1  8D 03 A0     	    STA	ACIAcontrol		; Set output for 8-N-1 19200
00000Fr 1               
00000Fr 1  4C rr rr             JMP     cold            ; BASIC cold start entry point
000012r 1               ; Get character for keyboard, return in A.
000012r 1               
000012r 1  8A           Se00c:  TXA
000013r 1  29 20                AND     #$20
000015r 1  F0 23                BEQ     Le034
000017r 1               
000017r 1  A9 A0        Se011:  LDA     #$A0
000019r 1  85 E4                STA     p2
00001Br 1  4C rr rr             JMP     cout
00001Er 1               
00001Er 1  A9 20        Se018:  LDA     #$20
000020r 1               
000020r 1  C5 24        Se01a:  CMP     ch
000022r 1  B0 0C                BCS     nextbyte
000024r 1  A9 8D                LDA     #$8D
000026r 1  A0 07                LDY     #$07
000028r 1  20 rr rr     Le022:  JSR     cout
00002Br 1  A9 A0                LDA     #$A0
00002Dr 1  88                   DEY
00002Er 1  D0 F8                BNE     Le022
000030r 1               
000030r 1  A0 00        nextbyte:       LDY     #$00
000032r 1  B1 E2                LDA     (p1),Y
000034r 1  E6 E2                INC     p1
000036r 1  D0 02                BNE     Le034
000038r 1  E6 E3                INC     p1+1
00003Ar 1  60           Le034:  RTS
00003Br 1               
00003Br 1               ; token $75 - "," in LIST command
00003Br 1  20 rr rr     list_comman:    JSR     get16bit
00003Er 1  20 rr rr             JSR     find_line2
000041r 1  A5 E2        Le03b:  LDA     p1
000043r 1  C5 E6                CMP     p3
000045r 1  A5 E3                LDA     p1+1
000047r 1  E5 E7                SBC     p3+1
000049r 1  B0 EF                BCS     Le034
00004Br 1  20 rr rr             JSR     list_line
00004Er 1  4C rr rr             JMP     Le03b
000051r 1               
000051r 1               ; token $76 - LIST command w/ no args
000051r 1  A5 CA        list_all:       LDA     pp
000053r 1  85 E2                STA     p1
000055r 1  A5 CB                LDA     pp+1
000057r 1  85 E3                STA     p1+1
000059r 1  A5 4C                LDA     himem
00005Br 1  85 E6                STA     p3
00005Dr 1  A5 4D                LDA     himem+1
00005Fr 1  85 E7                STA     p3+1
000061r 1  D0 DE                BNE     Le03b
000063r 1               
000063r 1               ; token $74 - LIST command w/ line number(s)
000063r 1  20 rr rr     list_cmd:       JSR     get16bit
000066r 1  20 rr rr             JSR     find_line
000069r 1  A5 E4                LDA     p2
00006Br 1  85 E2                STA     p1
00006Dr 1  A5 E5                LDA     p2+1
00006Fr 1  85 E3                STA     p1+1
000071r 1  B0 C7                BCS     Le034
000073r 1               
000073r 1               ; list one program line
000073r 1  86 D8        list_line:      STX     x_save
000075r 1  A9 A0                LDA     #$A0
000077r 1  85 FA                STA     leadzr
000079r 1  20 rr rr             JSR     nextbyte
00007Cr 1  98                   TYA
00007Dr 1               
00007Dr 1               ; list an integer (line number or literal)
00007Dr 1  85 E4        list_int:       STA     p2
00007Fr 1  20 rr rr             JSR     nextbyte
000082r 1  AA                   TAX
000083r 1  20 rr rr             JSR     nextbyte
000086r 1  20 rr rr             JSR     prdec
000089r 1  20 rr rr     Le083:  JSR     Se018
00008Cr 1  84 FA                STY     leadzr
00008Er 1  AA                   TAX
00008Fr 1  10 18                BPL     list_token
000091r 1  0A                   ASL
000092r 1  10 E9                BPL     list_int
000094r 1  A5 E4                LDA     p2
000096r 1  D0 03                BNE     Le095
000098r 1  20 rr rr             JSR     Se011
00009Br 1  8A           Le095:  TXA
00009Cr 1  20 rr rr     Le096:  JSR     cout
00009Fr 1  A9 25        Le099:  LDA     #$25
0000A1r 1  20 rr rr             JSR     Se01a
0000A4r 1  AA                   TAX
0000A5r 1  30 F5                BMI     Le096
0000A7r 1  85 E4                STA     p2
0000A9r 1               
0000A9r 1               ; list a single token
0000A9r 1  C9 01        list_token:     CMP     #$01
0000ABr 1  D0 05                BNE     Le0ac
0000ADr 1  A6 D8                LDX     x_save
0000AFr 1  4C rr rr             JMP     crout
0000B2r 1  48           Le0ac:  PHA
0000B3r 1  84 CE                STY     acc
0000B5r 1  A2 ED                LDX     #$ED
0000B7r 1  86 CF                STX     acc+1
0000B9r 1  C9 51                CMP     #$51
0000BBr 1  90 04                BCC     Le0bb
0000BDr 1  C6 CF                DEC     acc+1
0000BFr 1  E9 50                SBC     #$50
0000C1r 1  48           Le0bb:  PHA
0000C2r 1  B1 CE                LDA     (acc),Y
0000C4r 1  AA           Le0be:  TAX
0000C5r 1  88                   DEY
0000C6r 1  B1 CE                LDA     (acc),Y
0000C8r 1  10 FA                BPL     Le0be
0000CAr 1  E0 C0                CPX     #$C0
0000CCr 1  B0 04                BCS     Le0cc
0000CEr 1  E0 00                CPX     #$00
0000D0r 1  30 F2                BMI     Le0be
0000D2r 1  AA           Le0cc:  TAX
0000D3r 1  68                   PLA
0000D4r 1  E9 01                SBC     #$01
0000D6r 1  D0 E9                BNE     Le0bb
0000D8r 1  24 E4                BIT     p2
0000DAr 1  30 03                BMI     Le0d9
0000DCr 1  20 rr rr             JSR     Seff8
0000DFr 1  B1 CE        Le0d9:  LDA     (acc),Y
0000E1r 1  10 10                BPL     Le0ed
0000E3r 1  AA                   TAX
0000E4r 1  29 3F                AND     #$3F
0000E6r 1  85 E4                STA     p2
0000E8r 1  18                   CLC
0000E9r 1  69 A0                ADC     #$A0
0000EBr 1  20 rr rr             JSR     cout
0000EEr 1  88                   DEY
0000EFr 1  E0 C0                CPX     #$C0
0000F1r 1  90 EC                BCC     Le0d9
0000F3r 1  20 rr rr     Le0ed:  JSR     Se00c
0000F6r 1  68                   PLA
0000F7r 1  C9 5D                CMP     #$5D
0000F9r 1  F0 A4                BEQ     Le099
0000FBr 1  C9 28                CMP     #$28
0000FDr 1  D0 8A                BNE     Le083
0000FFr 1  F0 9E                BEQ     Le099
000101r 1               
000101r 1               ; token $2A - left paren for substring like A$(3,5)
000101r 1  20 rr rr     paren_substr:   JSR     Se118
000104r 1  95 50                STA     noun_stk_l,X
000106r 1  D5 78                CMP     noun_stk_h_str,X
000108r 1  90 11        Le102:  BCC     Le115
00010Ar 1  A0 2B        string_err:     LDY     #$2B
00010Cr 1  4C rr rr     go_errmess_1:   JMP     print_err_msg
00010Fr 1               
00010Fr 1               ; token $2B - comma for substring like A$(3,5)
00010Fr 1  20 rr rr     comma_substr:   JSR     getbyte
000112r 1  D5 50                CMP     noun_stk_l,X
000114r 1  90 F4                BCC     string_err
000116r 1  20 rr rr             JSR     Sefe4
000119r 1  95 78                STA     noun_stk_h_str,X
00011Br 1  4C rr rr     Le115:  JMP     left_paren
00011Er 1               
00011Er 1  20 rr rr     Se118:  JSR     getbyte
000121r 1  F0 E7                BEQ     string_err
000123r 1  38                   SEC
000124r 1  E9 01                SBC     #$01
000126r 1  60                   RTS
000127r 1               
000127r 1               ; token $42 - left paren for string array as dest
000127r 1               ; A$(1)="FOO"
000127r 1  20 rr rr     str_arr_dest:   JSR     Se118
00012Ar 1  95 50                STA     noun_stk_l,X
00012Cr 1  18                   CLC
00012Dr 1  F5 78                SBC     noun_stk_h_str,X
00012Fr 1  4C rr rr             JMP     Le102
000132r 1  A0 14        Le12c:  LDY     #$14
000134r 1  D0 D6                BNE     go_errmess_1
000136r 1               
000136r 1               ; token $43 - comma, next var in DIM statement is string
000136r 1               ; token $4E - "DIM", next var in DIM is string
000136r 1  20 rr rr     dim_str:        JSR     Se118
000139r 1  E8                   INX
00013Ar 1  B5 50        Le134:  LDA     noun_stk_l,X
00013Cr 1  85 DA                STA     aux
00013Er 1  65 CE                ADC     acc
000140r 1  48                   PHA
000141r 1  A8                   TAY
000142r 1  B5 78                LDA     noun_stk_h_str,X
000144r 1  85 DB                STA     aux+1
000146r 1  65 CF                ADC     acc+1
000148r 1  48                   PHA
000149r 1  C4 CA                CPY     pp
00014Br 1  E5 CB                SBC     pp+1
00014Dr 1  B0 E3                BCS     Le12c
00014Fr 1  A5 DA                LDA     aux
000151r 1  69 FE                ADC     #$FE
000153r 1  85 DA                STA     aux
000155r 1  A9 FF                LDA     #$FF
000157r 1  A8                   TAY
000158r 1  65 DB                ADC     aux+1
00015Ar 1  85 DB                STA     aux+1
00015Cr 1  C8           Le156:  INY
00015Dr 1  B1 DA                LDA     (aux),Y
00015Fr 1  D9 CC 00             CMP     pv,Y
000162r 1  D0 0F                BNE     Le16d
000164r 1  98                   TYA
000165r 1  F0 F5                BEQ     Le156
000167r 1  68           Le161:  PLA
000168r 1  91 DA                STA     (aux),Y
00016Ar 1  99 CC 00             STA     pv,Y
00016Dr 1  88                   DEY
00016Er 1  10 F7                BPL     Le161
000170r 1  E8                   INX
000171r 1  60                   RTS
000172r 1  EA                   NOP
000173r 1  A0 80        Le16d:  LDY     #$80
000175r 1  D0 95        Le16f:  BNE     go_errmess_1
000177r 1               
000177r 1               ; token ???
000177r 1  A9 00        input_str:      LDA     #$00
000179r 1  20 rr rr             JSR     push_a_noun_stk
00017Cr 1  A0 02                LDY     #$02
00017Er 1  94 78                STY     noun_stk_h_str,X
000180r 1  20 rr rr             JSR     push_a_noun_stk
000183r 1  A9 BF                LDA     #$BF                    ; '?'
000185r 1  20 rr rr             JSR     cout
000188r 1  A0 00                LDY     #$00
00018Ar 1  20 rr rr             JSR     read_line
00018Dr 1  94 78                STY     noun_stk_h_str,X
00018Fr 1  EA                   NOP
000190r 1  EA                   NOP
000191r 1  EA                   NOP
000192r 1               
000192r 1               ; token $70 - string literal
000192r 1  B5 51        string_lit:     LDA     noun_stk_l+1,X
000194r 1  85 CE                STA     acc
000196r 1  B5 79                LDA     noun_stk_h_str+1,X
000198r 1  85 CF                STA     acc+1
00019Ar 1  E8                   INX
00019Br 1  E8                   INX
00019Cr 1  20 rr rr             JSR     Se1bc
00019Fr 1  B5 4E        Le199:  LDA     rnd,X
0001A1r 1  D5 76                CMP     syn_stk_h+30,X
0001A3r 1  B0 15                BCS     Le1b4
0001A5r 1  F6 4E                INC     rnd,X
0001A7r 1  A8                   TAY
0001A8r 1  B1 CE                LDA     (acc),Y
0001AAr 1  B4 50                LDY     noun_stk_l,X
0001ACr 1  C4 E4                CPY     p2
0001AEr 1  90 04                BCC     Le1ae
0001B0r 1  A0 83                LDY     #$83
0001B2r 1  D0 C1                BNE     Le16f
0001B4r 1  91 DA        Le1ae:  STA     (aux),Y
0001B6r 1  F6 50                INC     noun_stk_l,X
0001B8r 1  90 E5                BCC     Le199
0001BAr 1  B4 50        Le1b4:  LDY     noun_stk_l,X
0001BCr 1  8A                   TXA
0001BDr 1  91 DA                STA     (aux),Y
0001BFr 1  E8                   INX
0001C0r 1  E8                   INX
0001C1r 1  60                   RTS
0001C2r 1               
0001C2r 1  B5 51        Se1bc:  LDA     noun_stk_l+1,X
0001C4r 1  85 DA                STA     aux
0001C6r 1  38                   SEC
0001C7r 1  E9 02                SBC     #$02
0001C9r 1  85 E4                STA     p2
0001CBr 1  B5 79                LDA     noun_stk_h_str+1,X
0001CDr 1  85 DB                STA     aux+1
0001CFr 1  E9 00                SBC     #$00
0001D1r 1  85 E5                STA     p2+1
0001D3r 1  A0 00                LDY     #$00
0001D5r 1  B1 E4                LDA     (p2),Y
0001D7r 1  18                   CLC
0001D8r 1  E5 DA                SBC     aux
0001DAr 1  85 E4                STA     p2
0001DCr 1  60                   RTS
0001DDr 1               
0001DDr 1               ; token $39 - "=" for string equality operator
0001DDr 1  B5 53        string_eq:      LDA     noun_stk_l+3,X
0001DFr 1  85 CE                STA     acc
0001E1r 1  B5 7B                LDA     noun_stk_h_str+3,X
0001E3r 1  85 CF                STA     acc+1
0001E5r 1  B5 51                LDA     noun_stk_l+1,X
0001E7r 1  85 DA                STA     aux
0001E9r 1  B5 79                LDA     noun_stk_h_str+1,X
0001EBr 1  85 DB                STA     aux+1
0001EDr 1  E8                   INX
0001EEr 1  E8                   INX
0001EFr 1  E8                   INX
0001F0r 1  A0 00                LDY     #$00
0001F2r 1  94 78                STY     noun_stk_h_str,X
0001F4r 1  94 A0                STY     noun_stk_h_int,X
0001F6r 1  C8                   INY
0001F7r 1  94 50                STY     noun_stk_l,X
0001F9r 1  B5 4D        Le1f3:  LDA     himem+1,X
0001FBr 1  D5 75                CMP     syn_stk_h+29,X
0001FDr 1  08                   PHP
0001FEr 1  48                   PHA
0001FFr 1  B5 4F                LDA     rnd+1,X
000201r 1  D5 77                CMP     syn_stk_h+31,X
000203r 1  90 07                BCC     Le206
000205r 1  68                   PLA
000206r 1  28                   PLP
000207r 1  B0 02                BCS     Le205
000209r 1  56 50        Le203:  LSR     noun_stk_l,X
00020Br 1  60           Le205:  RTS
00020Cr 1  A8           Le206:  TAY
00020Dr 1  B1 CE                LDA     (acc),Y
00020Fr 1  85 E4                STA     p2
000211r 1  68                   PLA
000212r 1  A8                   TAY
000213r 1  28                   PLP
000214r 1  B0 F3                BCS     Le203
000216r 1  B1 DA                LDA     (aux),Y
000218r 1  C5 E4                CMP     p2
00021Ar 1  D0 ED                BNE     Le203
00021Cr 1  F6 4F                INC     rnd+1,X
00021Er 1  F6 4D                INC     himem+1,X
000220r 1  B0 D7                BCS     Le1f3
000222r 1               
000222r 1               ; token $3A - "#" for string inequality operator
000222r 1  20 rr rr     string_neq:     JSR     string_eq
000225r 1  4C rr rr             JMP     not_op
000228r 1               
000228r 1               ; token $14 - "*" for numeric multiplication
000228r 1  20 rr rr     mult_op:        JSR     Se254
00022Br 1  06 CE        Le225:  ASL     acc
00022Dr 1  26 CF                ROL     acc+1
00022Fr 1  90 0D                BCC     Le238
000231r 1  18                   CLC
000232r 1  A5 E6                LDA     p3
000234r 1  65 DA                ADC     aux
000236r 1  85 E6                STA     p3
000238r 1  A5 E7                LDA     p3+1
00023Ar 1  65 DB                ADC     aux+1
00023Cr 1  85 E7                STA     p3+1
00023Er 1  88           Le238:  DEY
00023Fr 1  F0 09                BEQ     Le244
000241r 1  06 E6                ASL     p3
000243r 1  26 E7                ROL     p3+1
000245r 1  10 E4                BPL     Le225
000247r 1  4C rr rr             JMP     Le77e
00024Ar 1  A5 E6        Le244:  LDA     p3
00024Cr 1  20 rr rr             JSR     push_ya_noun_stk
00024Fr 1  A5 E7                LDA     p3+1
000251r 1  95 A0                STA     noun_stk_h_int,X
000253r 1  06 E5                ASL     p2+1
000255r 1  90 28                BCC     Le279
000257r 1  4C rr rr             JMP     negate
00025Ar 1               
00025Ar 1  A9 55        Se254:  LDA     #$55
00025Cr 1  85 E5                STA     p2+1
00025Er 1  20 rr rr             JSR     Se25b
000261r 1               
000261r 1  A5 CE        Se25b:  LDA     acc
000263r 1  85 DA                STA     aux
000265r 1  A5 CF                LDA     acc+1
000267r 1  85 DB                STA     aux+1
000269r 1  20 rr rr             JSR     get16bit
00026Cr 1  84 E6                STY     p3
00026Er 1  84 E7                STY     p3+1
000270r 1  A5 CF                LDA     acc+1
000272r 1  10 09                BPL     Le277
000274r 1  CA                   DEX
000275r 1  06 E5                ASL     p2+1
000277r 1  20 rr rr             JSR     negate
00027Ar 1  20 rr rr             JSR     get16bit
00027Dr 1  A0 10        Le277:  LDY     #$10
00027Fr 1  60           Le279:  RTS
000280r 1               
000280r 1               ; token $1f - "MOD"
000280r 1  20 rr rr     mod_op: JSR     See6c
000283r 1  F0 C5                BEQ     Le244
000285r 1  FF                   .byte   $FF
000286r 1  C9 84        Le280:  CMP     #$84
000288r 1  D0 02                BNE     Le286
00028Ar 1  46 F8                LSR     auto_flag
00028Cr 1  C9 DF        Le286:  CMP     #$DF
00028Er 1  F0 11                BEQ     Le29b
000290r 1  C9 9B                CMP     #$9B
000292r 1  F0 06                BEQ     Le294
000294r 1  99 00 02             STA     buffer,Y
000297r 1  C8                   INY
000298r 1  10 0A                BPL     read_line
00029Ar 1  A0 8B        Le294:  LDY     #$8B ;error
00029Cr 1  20 rr rr             JSR     Se3c4
00029Fr 1               
00029Fr 1  A0 01        Se299:  LDY     #$01
0002A1r 1  88           Le29b:  DEY
0002A2r 1  30 F6                BMI     Le294
0002A4r 1               
0002A4r 1               ; read a line from keyboard (using rdkey) into buffer
0002A4r 1               read_line:
0002A4r 1               
0002A4r 1  AD 01 A0            LDA	ACIAstatus		; Read 6551 status
0002A7r 1  29 08        	   AND	#$08			;
0002A9r 1  F0 F9        	   BEQ	read_line		; If rx buffer empty, no byte
0002ABr 1  09 80               ORA #$80 ;convert to ascii keyboard
0002ADr 1  AD 00 A0     	   LDA	ACIAdata		; Read byte from 6551
0002B0r 1               
0002B0r 1               ;JSR     rdkey
0002B0r 1  EA                   NOP
0002B1r 1  EA                   NOP
0002B2r 1  20 rr rr             JSR     cout    ;output the read character
0002B5r 1  C9 8D                CMP     #$8D    ;is it a cr?
0002B7r 1  D0 CD                BNE     Le280   ;if not cr go here
0002B9r 1  A9 DF                LDA     #$DF
0002BBr 1  99 00 02             STA     buffer,Y    ;stick the character in the buffer
0002BEr 1  60                   RTS
0002BFr 1  20 rr rr     cold:   JSR     mem_init_4k
0002C2r 1                       .export warm
0002C2r 1  20 rr rr     warm:   JSR     crout           ; BASIC warm start entry point
0002C5r 1  46 D9        Le2b6:  LSR     run_flag
0002C7r 1  A9 BE                LDA     #'>'+$80        ; Prompt character (high bit set)
0002C9r 1  20 rr rr             JSR     cout
0002CCr 1  A0 00                LDY     #$00
0002CEr 1  84 FA                STY     leadzr
0002D0r 1  24 F8                BIT     auto_flag
0002D2r 1  10 0C                BPL     Le2d1
0002D4r 1  A6 F6                LDX     auto_ln
0002D6r 1  A5 F7                LDA     auto_ln+1
0002D8r 1  20 rr rr             JSR     prdec
0002DBr 1  A9 A0                LDA     #$A0
0002DDr 1  20 rr rr             JSR     cout
0002E0r 1  A2 FF        Le2d1:  LDX     #$FF
0002E2r 1  9A                   TXS
0002E3r 1  20 rr rr             JSR     read_line ;stache commented out
0002E6r 1  84 F1                STY     token_index
0002E8r 1  8A                   TXA
0002E9r 1  85 C8                STA     text_index
0002EBr 1  A2 20                LDX     #$20
0002EDr 1  20 rr rr             JSR     Se491
0002F0r 1  A5 C8                LDA     text_index
0002F2r 1  69 00                ADC     #$00
0002F4r 1  85 E0                STA     pverb
0002F6r 1  A9 00                LDA     #$00
0002F8r 1  AA                   TAX
0002F9r 1  69 02                ADC     #$02
0002FBr 1  85 E1                STA     pverb+1
0002FDr 1  A1 E0                LDA     (pverb,X)
0002FFr 1  29 F0                AND     #$F0
000301r 1  C9 B0                CMP     #$B0
000303r 1  F0 03                BEQ     Le2f9
000305r 1  4C rr rr             JMP     Le883
000308r 1  A0 02        Le2f9:  LDY     #$02
00030Ar 1  B1 E0        Le2fb:  LDA     (pverb),Y
00030Cr 1  99 CD 00             STA     pv+1,Y
00030Fr 1  88                   DEY
000310r 1  D0 F8                BNE     Le2fb
000312r 1  20 rr rr             JSR     Se38a
000315r 1  A5 F1                LDA     token_index
000317r 1  E5 C8                SBC     text_index
000319r 1  C9 04                CMP     #$04
00031Br 1  F0 A8                BEQ     Le2b6
00031Dr 1  91 E0                STA     (pverb),Y
00031Fr 1  A5 CA                LDA     pp
000321r 1  F1 E0                SBC     (pverb),Y
000323r 1  85 E4                STA     p2
000325r 1  A5 CB                LDA     pp+1
000327r 1  E9 00                SBC     #$00
000329r 1  85 E5                STA     p2+1
00032Br 1  A5 E4                LDA     p2
00032Dr 1  C5 CC                CMP     pv
00032Fr 1  A5 E5                LDA     p2+1
000331r 1  E5 CD                SBC     pv+1
000333r 1  90 45                BCC     Le36b
000335r 1  A5 CA        Le326:  LDA     pp
000337r 1  F1 E0                SBC     (pverb),Y
000339r 1  85 E6                STA     p3
00033Br 1  A5 CB                LDA     pp+1
00033Dr 1  E9 00                SBC     #$00
00033Fr 1  85 E7                STA     p3+1
000341r 1  B1 CA                LDA     (pp),Y
000343r 1  91 E6                STA     (p3),Y
000345r 1  E6 CA                INC     pp
000347r 1  D0 02                BNE     Le33c
000349r 1  E6 CB                INC     pp+1
00034Br 1  A5 E2        Le33c:  LDA     p1
00034Dr 1  C5 CA                CMP     pp
00034Fr 1  A5 E3                LDA     p1+1
000351r 1  E5 CB                SBC     pp+1
000353r 1  B0 E0                BCS     Le326
000355r 1  B5 E4        Le346:  LDA     p2,X
000357r 1  95 CA                STA     pp,X
000359r 1  CA                   DEX
00035Ar 1  10 F9                BPL     Le346
00035Cr 1  B1 E0                LDA     (pverb),Y
00035Er 1  A8                   TAY
00035Fr 1  88           Le350:  DEY
000360r 1  B1 E0                LDA     (pverb),Y
000362r 1  91 E6                STA     (p3),Y
000364r 1  98                   TYA
000365r 1  D0 F8                BNE     Le350
000367r 1  24 F8                BIT     auto_flag
000369r 1  10 09                BPL     Le365
00036Br 1  B5 F7        Le35c:  LDA     auto_ln+1,X
00036Dr 1  75 F5                ADC     auto_inc+1,X
00036Fr 1  95 F7                STA     auto_ln+1,X
000371r 1  E8                   INX
000372r 1  F0 F7                BEQ     Le35c
000374r 1  10 79        Le365:  BPL     Le3e5
000376r 1  00 00 00 00          .byte   $00,$00,$00,$00
00037Ar 1  A0 14        Le36b:  LDY     #$14
00037Cr 1  D0 6C                BNE     print_err_msg
00037Er 1               
00037Er 1               ; token $0a - "," in DEL command
00037Er 1  20 rr rr     del_comma:      JSR     get16bit
000381r 1  A5 E2                LDA     p1
000383r 1  85 E6                STA     p3
000385r 1  A5 E3                LDA     p1+1
000387r 1  85 E7                STA     p3+1
000389r 1  20 rr rr             JSR     find_line1
00038Cr 1  A5 E2                LDA     p1
00038Er 1  85 E4                STA     p2
000390r 1  A5 E3                LDA     p1+1
000392r 1  85 E5                STA     p2+1
000394r 1  D0 0E                BNE     Le395
000396r 1               
000396r 1               ; token $09 - "DEL"
000396r 1  20 rr rr     del_cmd:        JSR     get16bit
000399r 1               
000399r 1  20 rr rr     Se38a:  JSR     find_line
00039Cr 1  A5 E6                LDA     p3
00039Er 1  85 E2                STA     p1
0003A0r 1  A5 E7                LDA     p3+1
0003A2r 1  85 E3                STA     p1+1
0003A4r 1  A0 00        Le395:  LDY     #$00
0003A6r 1  A5 CA        Le397:  LDA     pp
0003A8r 1  C5 E4                CMP     p2
0003AAr 1  A5 CB                LDA     pp+1
0003ACr 1  E5 E5                SBC     p2+1
0003AEr 1  B0 16                BCS     Le3b7
0003B0r 1  A5 E4                LDA     p2
0003B2r 1  D0 02                BNE     Le3a7
0003B4r 1  C6 E5                DEC     p2+1
0003B6r 1  C6 E4        Le3a7:  DEC     p2
0003B8r 1  A5 E6                LDA     p3
0003BAr 1  D0 02                BNE     Le3af
0003BCr 1  C6 E7                DEC     p3+1
0003BEr 1  C6 E6        Le3af:  DEC     p3
0003C0r 1  B1 E4                LDA     (p2),Y
0003C2r 1  91 E6                STA     (p3),Y
0003C4r 1  90 E0                BCC     Le397
0003C6r 1  A5 E6        Le3b7:  LDA     p3
0003C8r 1  85 CA                STA     pp
0003CAr 1  A5 E7                LDA     p3+1
0003CCr 1  85 CB                STA     pp+1
0003CEr 1  60                   RTS
0003CFr 1  20 rr rr     Le3c0:  JSR     cout
0003D2r 1  C8                   INY
0003D3r 1               
0003D3r 1  B9 rr rr     Se3c4:  LDA     error_msg_tbl,Y
0003D6r 1  30 F7                BMI     Le3c0
0003D8r 1               
0003D8r 1  C9 8D        cout:   CMP     #$8D
0003DAr 1  D0 06                BNE     Le3d3
0003DCr 1               
0003DCr 1  A9 00        crout:  LDA     #$00            ; character output
0003DEr 1  85 24                STA     ch
0003E0r 1  A9 8D                LDA     #$8D
0003E2r 1  E6 24        Le3d3:  INC     ch
0003E4r 1               
0003E4r 1               
0003E4r 1               
0003E4r 1               ; Send character to display. Char is in A.
0003E4r 1               Le3d5:
0003E4r 1  20 rr rr     	    JSR ACIAWrite
0003E7r 1               
0003E7r 1  60                   RTS                  ; and return
0003E8r 1               
0003E8r 1  A0 06        too_long_err:   LDY     #$06
0003EAr 1               
0003EAr 1  20 rr rr     print_err_msg:  JSR     print_err_msg1  ; print error message specified in Y
0003EDr 1  24 D9                BIT     run_flag
0003EFr 1  30 03        Le3e5:  BMI     Le3ea
0003F1r 1  4C rr rr             JMP     Le2b6
0003F4r 1  4C rr rr     Le3ea:  JMP     Leb9a
0003F7r 1  2A           Le3ed:  ROL
0003F8r 1  69 A0                ADC     #$A0
0003FAr 1  DD 00 02             CMP     buffer,X
0003FDr 1  D0 53                BNE     Le448
0003FFr 1  B1 FE                LDA     (synpag),Y
000401r 1  0A                   ASL
000402r 1  30 06                BMI     Le400
000404r 1  88                   DEY
000405r 1  B1 FE                LDA     (synpag),Y
000407r 1  30 29                BMI     Le428
000409r 1  C8                   INY
00040Ar 1  86 C8        Le400:  STX     text_index
00040Cr 1  98                   TYA
00040Dr 1  48                   PHA
00040Er 1  A2 00                LDX     #$00
000410r 1  A1 FE                LDA     (synpag,X)
000412r 1  AA                   TAX
000413r 1  4A           Le409:  LSR
000414r 1  49 48                EOR     #$48
000416r 1  11 FE                ORA     (synpag),Y
000418r 1  C9 C0                CMP     #$C0
00041Ar 1  90 01                BCC     Le413
00041Cr 1  E8                   INX
00041Dr 1  C8           Le413:  INY
00041Er 1  D0 F3                BNE     Le409
000420r 1  68                   PLA
000421r 1  A8                   TAY
000422r 1  8A                   TXA
000423r 1  4C rr rr             JMP     Le4c0
000426r 1               
000426r 1               ; write a token to the buffer
000426r 1               ; buffer [++tokndx] = A
000426r 1  E6 F1        put_token:      INC     token_index
000428r 1  A6 F1                LDX     token_index
00042Ar 1  F0 BC                BEQ     too_long_err
00042Cr 1  9D 00 02             STA     buffer,X
00042Fr 1  60           Le425:  RTS
000430r 1  A6 C8        Le426:  LDX     text_index
000432r 1  A9 A0        Le428:  LDA     #$A0
000434r 1  E8           Le42a:  INX
000435r 1  DD 00 02             CMP     buffer,X
000438r 1  B0 FA                BCS     Le42a
00043Ar 1  B1 FE                LDA     (synpag),Y
00043Cr 1  29 3F                AND     #$3F
00043Er 1  4A                   LSR
00043Fr 1  D0 B6                BNE     Le3ed
000441r 1  BD 00 02             LDA     buffer,X
000444r 1  B0 06                BCS     Le442
000446r 1  69 3F                ADC     #$3F
000448r 1  C9 1A                CMP     #$1A
00044Ar 1  90 6F                BCC     Le4b1
00044Cr 1  69 4F        Le442:  ADC     #$4F
00044Er 1  C9 0A                CMP     #$0A
000450r 1  90 69                BCC     Le4b1
000452r 1  A6 FD        Le448:  LDX     synstkdx
000454r 1  C8           Le44a:  INY
000455r 1  B1 FE                LDA     (synpag),Y
000457r 1  29 E0                AND     #$E0
000459r 1  C9 20                CMP     #$20
00045Br 1  F0 7A                BEQ     Le4cd
00045Dr 1  B5 A8                LDA     txtndxstk,X
00045Fr 1  85 C8                STA     text_index
000461r 1  B5 D1                LDA     tokndxstk,X
000463r 1  85 F1                STA     token_index
000465r 1  88           Le45b:  DEY
000466r 1  B1 FE                LDA     (synpag),Y
000468r 1  0A                   ASL
000469r 1  10 FA                BPL     Le45b
00046Br 1  88                   DEY
00046Cr 1  B0 38                BCS     Le49c
00046Er 1  0A                   ASL
00046Fr 1  30 35                BMI     Le49c
000471r 1  B4 58                LDY     syn_stk_h,X
000473r 1  84 FF                STY     synpag+1
000475r 1  B4 80                LDY     syn_stk_l,X
000477r 1  E8                   INX
000478r 1  10 DA                BPL     Le44a
00047Ar 1  F0 B3        Le470:  BEQ     Le425
00047Cr 1  C9 7E                CMP     #$7E
00047Er 1  B0 22                BCS     Le498
000480r 1  CA                   DEX
000481r 1  10 04                BPL     Le47d
000483r 1  A0 06                LDY     #$06
000485r 1  10 29                BPL     go_errmess_2
000487r 1  94 80        Le47d:  STY     syn_stk_l,X
000489r 1  A4 FF                LDY     synpag+1
00048Br 1  94 58                STY     syn_stk_h,X
00048Dr 1  A4 C8                LDY     text_index
00048Fr 1  94 A8                STY     txtndxstk,X
000491r 1  A4 F1                LDY     token_index
000493r 1  94 D1                STY     tokndxstk,X
000495r 1  29 1F                AND     #$1F
000497r 1  A8                   TAY
000498r 1  B9 rr rr             LDA     syntabl_index,Y
00049Br 1               
00049Br 1  0A           Se491:  ASL
00049Cr 1  A8                   TAY
00049Dr 1  A9 76                LDA     #$76
00049Fr 1  2A                   ROL
0004A0r 1  85 FF                STA     synpag+1
0004A2r 1  D0 01        Le498:  BNE     Le49b
0004A4r 1  C8                   INY
0004A5r 1  C8           Le49b:  INY
0004A6r 1  86 FD        Le49c:  STX     synstkdx
0004A8r 1  B1 FE                LDA     (synpag),Y
0004AAr 1  30 84                BMI     Le426
0004ACr 1  D0 05                BNE     Le4a9
0004AEr 1  A0 0E                LDY     #$0E
0004B0r 1  4C rr rr     go_errmess_2:   JMP     print_err_msg
0004B3r 1  C9 03        Le4a9:  CMP     #$03
0004B5r 1  B0 C3                BCS     Le470
0004B7r 1  4A                   LSR
0004B8r 1  A6 C8                LDX     text_index
0004BAr 1  E8                   INX
0004BBr 1  BD 00 02     Le4b1:  LDA     buffer,X
0004BEr 1  90 04                BCC     Le4ba
0004C0r 1  C9 A2                CMP     #$A2
0004C2r 1  F0 0A                BEQ     Le4c4
0004C4r 1  C9 DF        Le4ba:  CMP     #$DF
0004C6r 1  F0 06                BEQ     Le4c4
0004C8r 1  86 C8                STX     text_index
0004CAr 1  20 rr rr     Le4c0:  JSR     put_token
0004CDr 1  C8                   INY
0004CEr 1  88           Le4c4:  DEY
0004CFr 1  A6 FD                LDX     synstkdx
0004D1r 1  B1 FE        Le4c7:  LDA     (synpag),Y
0004D3r 1  88                   DEY
0004D4r 1  0A                   ASL
0004D5r 1  10 CF                BPL     Le49c
0004D7r 1  B4 58        Le4cd:  LDY     syn_stk_h,X
0004D9r 1  84 FF                STY     synpag+1
0004DBr 1  B4 80                LDY     syn_stk_l,X
0004DDr 1  E8                   INX
0004DEr 1  B1 FE                LDA     (synpag),Y
0004E0r 1  29 9F                AND     #$9F
0004E2r 1  D0 ED                BNE     Le4c7
0004E4r 1  85 F2                STA     pcon
0004E6r 1  85 F3                STA     pcon+1
0004E8r 1  98                   TYA
0004E9r 1  48                   PHA
0004EAr 1  86 FD                STX     synstkdx
0004ECr 1  B4 D0                LDY     srch,X
0004EEr 1  84 C9                STY     leadbl
0004F0r 1  18                   CLC
0004F1r 1  A9 0A        Le4e7:  LDA     #$0A
0004F3r 1  85 F9                STA     char
0004F5r 1  A2 00                LDX     #$00
0004F7r 1  C8                   INY
0004F8r 1  B9 00 02             LDA     buffer,Y
0004FBr 1  29 0F                AND     #$0F
0004FDr 1  65 F2        Le4f3:  ADC     pcon
0004FFr 1  48                   PHA
000500r 1  8A                   TXA
000501r 1  65 F3                ADC     pcon+1
000503r 1  30 1C                BMI     Le517
000505r 1  AA                   TAX
000506r 1  68                   PLA
000507r 1  C6 F9                DEC     char
000509r 1  D0 F2                BNE     Le4f3
00050Br 1  85 F2                STA     pcon
00050Dr 1  86 F3                STX     pcon+1
00050Fr 1  C4 F1                CPY     token_index
000511r 1  D0 DE                BNE     Le4e7
000513r 1  A4 C9                LDY     leadbl
000515r 1  C8                   INY
000516r 1  84 F1                STY     token_index
000518r 1  20 rr rr             JSR     put_token
00051Br 1  68                   PLA
00051Cr 1  A8                   TAY
00051Dr 1  A5 F3                LDA     pcon+1
00051Fr 1  B0 A9                BCS     Le4c0
000521r 1  A0 00        Le517:  LDY     #$00
000523r 1  10 8B                BPL     go_errmess_2
000525r 1               
000525r 1  85 F3        prdec:  STA     pcon+1  ; output A:X in decimal
000527r 1  86 F2                STX     pcon
000529r 1  A2 04                LDX     #$04
00052Br 1  86 C9                STX     leadbl
00052Dr 1  A9 B0        Le523:  LDA     #$B0
00052Fr 1  85 F9                STA     char
000531r 1  A5 F2        Le527:  LDA     pcon
000533r 1  DD rr rr             CMP     dectabl,X
000536r 1  A5 F3                LDA     pcon+1
000538r 1  FD rr rr             SBC     dectabh,X
00053Br 1  90 0D                BCC     Le540
00053Dr 1  85 F3                STA     pcon+1
00053Fr 1  A5 F2                LDA     pcon
000541r 1  FD rr rr             SBC     dectabl,X
000544r 1  85 F2                STA     pcon
000546r 1  E6 F9                INC     char
000548r 1  D0 E7                BNE     Le527
00054Ar 1  A5 F9        Le540:  LDA     char
00054Cr 1  E8                   INX
00054Dr 1  CA                   DEX
00054Er 1  F0 0E                BEQ     Le554
000550r 1  C9 B0                CMP     #$B0
000552r 1  F0 02                BEQ     Le54c
000554r 1  85 C9                STA     leadbl
000556r 1  24 C9        Le54c:  BIT     leadbl
000558r 1  30 04                BMI     Le554
00055Ar 1  A5 FA                LDA     leadzr
00055Cr 1  F0 0B                BEQ     Le55f
00055Er 1  20 rr rr     Le554:  JSR     cout
000561r 1  24 F8                BIT     auto_flag
000563r 1  10 04                BPL     Le55f
000565r 1  99 00 02             STA     buffer,Y
000568r 1  C8                   INY
000569r 1  CA           Le55f:  DEX
00056Ar 1  10 C1                BPL     Le523
00056Cr 1  60                   RTS
00056Dr 1               ; powers of 10 table, low byte
00056Dr 1  01 0A 64 E8  dectabl:        .byte   $01,$0A,$64,$E8,$10             ; "..dh."
000571r 1  10           
000572r 1               
000572r 1               ; powers of 10 table, high byte
000572r 1  00 00 00 03  dectabh:        .byte   $00,$00,$00,$03,$27             ; "....'"
000576r 1  27           
000577r 1               
000577r 1  A5 CA        find_line:      LDA     pp
000579r 1  85 E6                STA     p3
00057Br 1  A5 CB                LDA     pp+1
00057Dr 1  85 E7                STA     p3+1
00057Fr 1               
00057Fr 1  E8           find_line1:     INX
000580r 1               
000580r 1  A5 E7        find_line2:     LDA     p3+1
000582r 1  85 E5                STA     p2+1
000584r 1  A5 E6                LDA     p3
000586r 1  85 E4                STA     p2
000588r 1  C5 4C                CMP     himem
00058Ar 1  A5 E5                LDA     p2+1
00058Cr 1  E5 4D                SBC     himem+1
00058Er 1  B0 26                BCS     Le5ac
000590r 1  A0 01                LDY     #$01
000592r 1  B1 E4                LDA     (p2),Y
000594r 1  E5 CE                SBC     acc
000596r 1  C8                   INY
000597r 1  B1 E4                LDA     (p2),Y
000599r 1  E5 CF                SBC     acc+1
00059Br 1  B0 19                BCS     Le5ac
00059Dr 1  A0 00                LDY     #$00
00059Fr 1  A5 E6                LDA     p3
0005A1r 1  71 E4                ADC     (p2),Y
0005A3r 1  85 E6                STA     p3
0005A5r 1  90 03                BCC     Le5a0
0005A7r 1  E6 E7                INC     p3+1
0005A9r 1  18                   CLC
0005AAr 1  C8           Le5a0:  INY
0005ABr 1  A5 CE                LDA     acc
0005ADr 1  F1 E4                SBC     (p2),Y
0005AFr 1  C8                   INY
0005B0r 1  A5 CF                LDA     acc+1
0005B2r 1  F1 E4                SBC     (p2),Y
0005B4r 1  B0 CA                BCS     find_line2
0005B6r 1  60           Le5ac:  RTS
0005B7r 1               
0005B7r 1               ; token $0B - "NEW"
0005B7r 1  46 F8        new_cmd:        LSR     auto_flag
0005B9r 1  A5 4C                LDA     himem
0005BBr 1  85 CA                STA     pp
0005BDr 1  A5 4D                LDA     himem+1
0005BFr 1  85 CB                STA     pp+1
0005C1r 1               
0005C1r 1               ; token $0C - "CLR"
0005C1r 1  A5 4A        clr:    LDA     lomem
0005C3r 1  85 CC                STA     pv
0005C5r 1  A5 4B                LDA     lomem+1
0005C7r 1  85 CD                STA     pv+1
0005C9r 1  A9 00                LDA     #$00
0005CBr 1  85 FB                STA     for_nest_count
0005CDr 1  85 FC                STA     gosub_nest_count
0005CFr 1  85 FE                STA     synpag
0005D1r 1  A9 00                LDA     #$00
0005D3r 1  85 1D                STA     Z1d
0005D5r 1  60                   RTS
0005D6r 1  A5 D0        Le5cc:  LDA     srch
0005D8r 1  69 05                ADC     #$05
0005DAr 1  85 D2                STA     srch2
0005DCr 1  A5 D1                LDA     tokndxstk
0005DEr 1  69 00                ADC     #$00
0005E0r 1  85 D3                STA     srch2+1
0005E2r 1  A5 D2                LDA     srch2
0005E4r 1  C5 CA                CMP     pp
0005E6r 1  A5 D3                LDA     srch2+1
0005E8r 1  E5 CB                SBC     pp+1
0005EAr 1  90 03                BCC     Le5e5
0005ECr 1  4C rr rr             JMP     Le36b
0005EFr 1  A5 CE        Le5e5:  LDA     acc
0005F1r 1  91 D0                STA     (srch),Y
0005F3r 1  A5 CF                LDA     acc+1
0005F5r 1  C8                   INY
0005F6r 1  91 D0                STA     (srch),Y
0005F8r 1  A5 D2                LDA     srch2
0005FAr 1  C8                   INY
0005FBr 1  91 D0                STA     (srch),Y
0005FDr 1  A5 D3                LDA     srch2+1
0005FFr 1  C8                   INY
000600r 1  91 D0                STA     (srch),Y
000602r 1  A9 00                LDA     #$00
000604r 1  C8                   INY
000605r 1  91 D0                STA     (srch),Y
000607r 1  C8                   INY
000608r 1  91 D0                STA     (srch),Y
00060Ar 1  A5 D2                LDA     srch2
00060Cr 1  85 CC                STA     pv
00060Er 1  A5 D3                LDA     srch2+1
000610r 1  85 CD                STA     pv+1
000612r 1  A5 D0                LDA     srch
000614r 1  90 43                BCC     Le64f
000616r 1  85 CE        execute_var:    STA     acc
000618r 1  84 CF                STY     acc+1
00061Ar 1  20 rr rr             JSR     get_next_prog_byte
00061Dr 1  30 0E                BMI     Le623
00061Fr 1  C9 40                CMP     #$40
000621r 1  F0 0A                BEQ     Le623
000623r 1  4C rr rr             JMP     Le628
000626r 1  06 C9 49 D0          .byte   $06,$C9,$49,$D0,$07,$A9,$49
00062Ar 1  07 A9 49     
00062Dr 1  85 CF        Le623:  STA     acc+1
00062Fr 1  20 rr rr             JSR     get_next_prog_byte
000632r 1  A5 4B        Le628:  LDA     lomem+1
000634r 1  85 D1                STA     tokndxstk
000636r 1  A5 4A                LDA     lomem
000638r 1  85 D0        Le62e:  STA     srch
00063Ar 1  C5 CC                CMP     pv
00063Cr 1  A5 D1                LDA     tokndxstk
00063Er 1  E5 CD                SBC     pv+1
000640r 1  B0 94                BCS     Le5cc
000642r 1  B1 D0                LDA     (srch),Y
000644r 1  C8                   INY
000645r 1  C5 CE                CMP     acc
000647r 1  D0 06                BNE     Le645
000649r 1  B1 D0                LDA     (srch),Y
00064Br 1  C5 CF                CMP     acc+1
00064Dr 1  F0 0E                BEQ     Le653
00064Fr 1  C8           Le645:  INY
000650r 1  B1 D0                LDA     (srch),Y
000652r 1  48                   PHA
000653r 1  C8                   INY
000654r 1  B1 D0                LDA     (srch),Y
000656r 1  85 D1                STA     tokndxstk
000658r 1  68                   PLA
000659r 1  A0 00        Le64f:  LDY     #$00
00065Br 1  F0 DB                BEQ     Le62e
00065Dr 1  A5 D0        Le653:  LDA     srch
00065Fr 1  69 03                ADC     #$03
000661r 1  20 rr rr             JSR     push_a_noun_stk
000664r 1  A5 D1                LDA     tokndxstk
000666r 1  69 00                ADC     #$00
000668r 1  95 78                STA     noun_stk_h_str,X
00066Ar 1  A5 CF                LDA     acc+1
00066Cr 1  C9 40                CMP     #$40
00066Er 1  D0 1C                BNE     fetch_prog_byte
000670r 1  88                   DEY
000671r 1  98                   TYA
000672r 1  20 rr rr             JSR     push_a_noun_stk
000675r 1  88                   DEY
000676r 1  94 78                STY     noun_stk_h_str,X
000678r 1  A0 03                LDY     #$03
00067Ar 1  F6 78        Le670:  INC     noun_stk_h_str,X
00067Cr 1  C8                   INY
00067Dr 1  B1 D0                LDA     (srch),Y
00067Fr 1  30 F9                BMI     Le670
000681r 1  10 09                BPL     fetch_prog_byte
000683r 1               
000683r 1  A9 00        execute_stmt:   LDA     #$00 ;reset if and cr_flag
000685r 1  85 D4                STA     if_flag
000687r 1  85 D5                STA     cr_flag
000689r 1  A2 20                LDX     #$20
00068Br 1               
00068Br 1               ; push old verb on stack for later use in precedence test
00068Br 1  48           push_old_verb:  PHA
00068Cr 1  A0 00        fetch_prog_byte:        LDY     #$00
00068Er 1  B1 E0                LDA     (pverb),Y
000690r 1  10 18        Le686:  BPL     execute_token
000692r 1  0A                   ASL
000693r 1  30 81                BMI     execute_var
000695r 1  20 rr rr             JSR     get_next_prog_byte
000698r 1  20 rr rr             JSR     push_ya_noun_stk
00069Br 1  20 rr rr             JSR     get_next_prog_byte
00069Er 1  95 A0                STA     noun_stk_h_int,X
0006A0r 1  24 D4        Le696:  BIT     if_flag
0006A2r 1  10 01                BPL     Le69b
0006A4r 1  CA                   DEX
0006A5r 1  20 rr rr     Le69b:  JSR     get_next_prog_byte
0006A8r 1  B0 E6                BCS     Le686
0006AAr 1               
0006AAr 1  C9 28        execute_token:  CMP     #$28
0006ACr 1  D0 1F                BNE     execute_verb
0006AEr 1  A5 E0                LDA     pverb
0006B0r 1  20 rr rr             JSR     push_a_noun_stk
0006B3r 1  A5 E1                LDA     pverb+1
0006B5r 1  95 78                STA     noun_stk_h_str,X
0006B7r 1  24 D4                BIT     if_flag
0006B9r 1  30 0B                BMI     Le6bc
0006BBr 1  A9 01                LDA     #$01
0006BDr 1  20 rr rr             JSR     push_a_noun_stk
0006C0r 1  A9 00                LDA     #$00
0006C2r 1  95 78                STA     noun_stk_h_str,X
0006C4r 1  F6 78        Le6ba:  INC     noun_stk_h_str,X
0006C6r 1  20 rr rr     Le6bc:  JSR     get_next_prog_byte
0006C9r 1  30 F9                BMI     Le6ba
0006CBr 1  B0 D3                BCS     Le696
0006CDr 1  24 D4        execute_verb:   BIT     if_flag
0006CFr 1  10 06                BPL     Le6cd
0006D1r 1  C9 04                CMP     #$04
0006D3r 1  B0 D0                BCS     Le69b
0006D5r 1  46 D4                LSR     if_flag
0006D7r 1  A8           Le6cd:  TAY
0006D8r 1  85 D6                STA     current_verb
0006DAr 1  B9 rr rr             LDA     verb_prec_tbl,Y
0006DDr 1  29 55                AND     #$55
0006DFr 1  0A                   ASL
0006E0r 1  85 D7                STA     precedence
0006E2r 1  68           Le6d8:  PLA
0006E3r 1  A8                   TAY
0006E4r 1  B9 rr rr             LDA     verb_prec_tbl,Y
0006E7r 1  29 AA                AND     #$AA
0006E9r 1  C5 D7                CMP     precedence
0006EBr 1  B0 09                BCS     do_verb
0006EDr 1  98                   TYA
0006EEr 1  48                   PHA
0006EFr 1  20 rr rr             JSR     get_next_prog_byte
0006F2r 1  A5 D6                LDA     current_verb
0006F4r 1  90 95                BCC     push_old_verb
0006F6r 1  B9 rr rr     do_verb:        LDA     verb_adr_l,Y
0006F9r 1  85 CE                STA     acc
0006FBr 1  B9 rr rr             LDA     verb_adr_h,Y
0006FEr 1  85 CF                STA     acc+1
000700r 1  20 rr rr             JSR     Se6fc
000703r 1  4C rr rr             JMP     Le6d8
000706r 1               
000706r 1  6C CE 00     Se6fc:  JMP     (acc)
000709r 1               
000709r 1  E6 E0        get_next_prog_byte:     INC     pverb
00070Br 1  D0 02                BNE     Le705
00070Dr 1  E6 E1                INC     pverb+1
00070Fr 1  B1 E0        Le705:  LDA     (pverb),Y
000711r 1  60                   RTS
000712r 1               
000712r 1  94 77        push_ya_noun_stk:       STY     syn_stk_h+31,X
000714r 1               
000714r 1  CA           push_a_noun_stk:        DEX
000715r 1  30 03                BMI     Le710
000717r 1  95 50                STA     noun_stk_l,X
000719r 1  60                   RTS
00071Ar 1  A0 66        Le710:  LDY     #$66
00071Cr 1  4C rr rr     go_errmess_3:   JMP     print_err_msg
00071Fr 1               
00071Fr 1  A0 00        get16bit:       LDY     #$00
000721r 1  B5 50                LDA     noun_stk_l,X
000723r 1  85 CE                STA     acc
000725r 1  B5 A0                LDA     noun_stk_h_int,X
000727r 1  85 CF                STA     acc+1
000729r 1  B5 78                LDA     noun_stk_h_str,X
00072Br 1  F0 0E                BEQ     Le731
00072Dr 1  85 CF                STA     acc+1
00072Fr 1  B1 CE                LDA     (acc),Y
000731r 1  48                   PHA
000732r 1  C8                   INY
000733r 1  B1 CE                LDA     (acc),Y
000735r 1  85 CF                STA     acc+1
000737r 1  68                   PLA
000738r 1  85 CE                STA     acc
00073Ar 1  88                   DEY
00073Br 1  E8           Le731:  INX
00073Cr 1  60                   RTS
00073Dr 1               
00073Dr 1               ; token $16 - "=" for numeric equality operator
00073Dr 1  20 rr rr     eq_op:  JSR     neq_op
000740r 1               
000740r 1               ; token $37 - "NOT"
000740r 1  20 rr rr     not_op: JSR     get16bit
000743r 1  98                   TYA
000744r 1  20 rr rr             JSR     push_ya_noun_stk
000747r 1  95 A0                STA     noun_stk_h_int,X
000749r 1  C5 CE                CMP     acc
00074Br 1  D0 06                BNE     Le749
00074Dr 1  C5 CF                CMP     acc+1
00074Fr 1  D0 02                BNE     Le749
000751r 1  F6 50                INC     noun_stk_l,X
000753r 1  60           Le749:  RTS
000754r 1               
000754r 1               ; token $17 - "#" for numeric inequality operator
000754r 1               ; token $1B - "<>" for numeric inequality operator
000754r 1  20 rr rr     neq_op: JSR     subtract
000757r 1  20 rr rr             JSR     sgn_fn
00075Ar 1               
00075Ar 1               ; token $31 - "ABS"
00075Ar 1  20 rr rr     abs_fn: JSR     get16bit
00075Dr 1  24 CF                BIT     acc+1
00075Fr 1  30 1B                BMI     Se772
000761r 1  CA           Le757:  DEX
000762r 1  60           Le758:  RTS
000763r 1               
000763r 1               ; token $30 - "SGN"
000763r 1  20 rr rr     sgn_fn: JSR     get16bit
000766r 1  A5 CF                LDA     acc+1
000768r 1  D0 04                BNE     Le764
00076Ar 1  A5 CE                LDA     acc
00076Cr 1  F0 F3                BEQ     Le757
00076Er 1  A9 FF        Le764:  LDA     #$FF
000770r 1  20 rr rr             JSR     push_ya_noun_stk
000773r 1  95 A0                STA     noun_stk_h_int,X
000775r 1  24 CF                BIT     acc+1
000777r 1  30 E9                BMI     Le758
000779r 1               
000779r 1               ; token $36 - "-" for unary negation
000779r 1  20 rr rr     negate: JSR     get16bit
00077Cr 1               
00077Cr 1  98           Se772:  TYA
00077Dr 1  38                   SEC
00077Er 1  E5 CE                SBC     acc
000780r 1  20 rr rr             JSR     push_ya_noun_stk
000783r 1  98                   TYA
000784r 1  E5 CF                SBC     acc+1
000786r 1  50 23                BVC     Le7a1
000788r 1  A0 00        Le77e:  LDY     #$00
00078Ar 1  10 90                BPL     go_errmess_3
00078Cr 1               
00078Cr 1               ; token $13 - "-" for numeric subtraction
00078Cr 1  20 rr rr     subtract:       JSR     negate
00078Fr 1               
00078Fr 1               ; token $12 - "+" for numeric addition
00078Fr 1  20 rr rr     add:    JSR     get16bit
000792r 1  A5 CE                LDA     acc
000794r 1  85 DA                STA     aux
000796r 1  A5 CF                LDA     acc+1
000798r 1  85 DB                STA     aux+1
00079Ar 1  20 rr rr             JSR     get16bit
00079Dr 1               
00079Dr 1  18           Se793:  CLC
00079Er 1  A5 CE                LDA     acc
0007A0r 1  65 DA                ADC     aux
0007A2r 1  20 rr rr             JSR     push_ya_noun_stk
0007A5r 1  A5 CF                LDA     acc+1
0007A7r 1  65 DB                ADC     aux+1
0007A9r 1  70 DD                BVS     Le77e
0007ABr 1  95 A0        Le7a1:  STA     noun_stk_h_int,X
0007ADr 1               
0007ADr 1               ; token $35 - "+" for unary positive
0007ADr 1  60           unary_pos:      RTS
0007AEr 1               
0007AEr 1               ; token $50 - "TAB" function
0007AEr 1  20 rr rr     tab_fn: JSR     get16bit
0007B1r 1  A4 CE                LDY     acc
0007B3r 1  F0 05                BEQ     Le7b0
0007B5r 1  88                   DEY
0007B6r 1  A5 CF                LDA     acc+1
0007B8r 1  F0 0C                BEQ     Le7bc
0007BAr 1  60           Le7b0:  RTS
0007BBr 1               
0007BBr 1               ; horizontal tab
0007BBr 1  A5 24        tabout: LDA     ch
0007BDr 1  09 07                ORA     #$07
0007BFr 1  A8                   TAY
0007C0r 1  C8                   INY
0007C1r 1  A9 A0        Le7b7:  LDA     #$A0
0007C3r 1  20 rr rr             JSR     cout
0007C6r 1  C4 24        Le7bc:  CPY     ch
0007C8r 1  B0 F7                BCS     Le7b7
0007CAr 1  60                   RTS
0007CBr 1               
0007CBr 1               ; token $49 - "," in print, numeric follows
0007CBr 1  20 rr rr     print_com_num:  JSR     tabout
0007CEr 1               
0007CEr 1               ; token $62 - "PRINT" numeric
0007CEr 1  20 rr rr     print_num:      JSR     get16bit
0007D1r 1  A5 CF                LDA     acc+1
0007D3r 1  10 0A                BPL     Le7d5
0007D5r 1  A9 AD                LDA     #$AD
0007D7r 1  20 rr rr             JSR     cout
0007DAr 1  20 rr rr             JSR     Se772
0007DDr 1  50 EF                BVC     print_num
0007DFr 1  88           Le7d5:  DEY
0007E0r 1  84 D5                STY     cr_flag
0007E2r 1  86 CF                STX     acc+1
0007E4r 1  A6 CE                LDX     acc
0007E6r 1  20 rr rr             JSR     prdec
0007E9r 1  A6 CF                LDX     acc+1
0007EBr 1  60                   RTS
0007ECr 1               
0007ECr 1               ; token $0D - "AUTO" command
0007ECr 1  20 rr rr     auto_cmd:       JSR     get16bit
0007EFr 1  A5 CE                LDA     acc
0007F1r 1  85 F6                STA     auto_ln
0007F3r 1  A5 CF                LDA     acc+1
0007F5r 1  85 F7                STA     auto_ln+1
0007F7r 1  88                   DEY
0007F8r 1  84 F8                STY     auto_flag
0007FAr 1  C8                   INY
0007FBr 1  A9 0A                LDA     #$0A
0007FDr 1  85 F4        Le7f3:  STA     auto_inc
0007FFr 1  84 F5                STY     auto_inc+1
000801r 1  60                   RTS
000802r 1               
000802r 1               ; token $0E - "," in AUTO command
000802r 1  20 rr rr     auto_com:       JSR     get16bit
000805r 1  A5 CE                LDA     acc
000807r 1  A4 CF                LDY     acc+1
000809r 1  10 F2                BPL     Le7f3
00080Br 1               
00080Br 1               ; token $56 - "=" in FOR statement
00080Br 1               ; token $71 - "=" in LET (or implied LET) statement
00080Br 1  20 rr rr     var_assign:     JSR     get16bit
00080Er 1  B5 50                LDA     noun_stk_l,X
000810r 1  85 DA                STA     aux
000812r 1  B5 78                LDA     noun_stk_h_str,X
000814r 1  85 DB                STA     aux+1
000816r 1  A5 CE                LDA     acc
000818r 1  91 DA                STA     (aux),Y
00081Ar 1  C8                   INY
00081Br 1  A5 CF                LDA     acc+1
00081Dr 1  91 DA                STA     (aux),Y
00081Fr 1  E8                   INX
000820r 1               
000820r 1  60           Te816:  RTS
000821r 1               
000821r 1               ; token $00 - begining of line
000821r 1               begin_line:
000821r 1  68                   PLA
000822r 1  68                   PLA
000823r 1               
000823r 1               ; token $03 - ":" statement separator
000823r 1  24 D5        colon:  BIT     cr_flag
000825r 1  10 05                BPL     Le822
000827r 1               
000827r 1               ; token $63 - "PRINT" with no arg
000827r 1  20 rr rr     print_cr:       JSR     crout
00082Ar 1               
00082Ar 1               ; token $47 - ";" at end of print statement
00082Ar 1  46 D5        print_semi:     LSR     cr_flag
00082Cr 1  60           Le822:  RTS
00082Dr 1               
00082Dr 1               
00082Dr 1               ; token $22 - "(" in string DIM
00082Dr 1               ; token $34 - "(" in numeric DIM
00082Dr 1               ; token $38 - "(" in numeric expression
00082Dr 1               ; token $3F - "(" in some PEEK, RND, SGN, ABS (PDL)
00082Dr 1  A0 FF        left_paren:     LDY     #$FF
00082Fr 1  84 D7                STY     precedence
000831r 1               
000831r 1               ; token $72 - ")" everywhere
000831r 1  60           right_paren:    RTS
000832r 1               
000832r 1               ; token $60 - "IF" statement
000832r 1  20 rr rr     if_stmt:        JSR     Sefcd
000835r 1  F0 07                BEQ     Le834
000837r 1  A9 25                LDA     #$25
000839r 1  85 D6                STA     current_verb
00083Br 1  88                   DEY
00083Cr 1  84 D4                STY     if_flag
00083Er 1  E8           Le834:  INX
00083Fr 1  60                   RTS
000840r 1               ; RUN without CLR, used by Apple DOS
000840r 1  A5 CA        run_warm:       LDA     pp
000842r 1  A4 CB                LDY     pp+1
000844r 1  D0 55                BNE     Le896
000846r 1               
000846r 1               ; token $5C - "GOSUB" statement
000846r 1  A0 41        gosub_stmt:     LDY     #$41
000848r 1  A5 FC                LDA     gosub_nest_count
00084Ar 1  C9 08                CMP     #$08
00084Cr 1  B0 59                BCS     go_errmess_4
00084Er 1  A8                   TAY
00084Fr 1  E6 FC                INC     gosub_nest_count
000851r 1  A5 E0                LDA     pverb
000853r 1  99 00 01             STA     gstk_pverbl,Y
000856r 1  A5 E1                LDA     pverb+1
000858r 1  99 08 01             STA     gstk_pverbh,Y
00085Br 1  A5 DC                LDA     pline
00085Dr 1  99 10 01             STA     gstk_plinel,Y
000860r 1  A5 DD                LDA     pline+1
000862r 1  99 18 01             STA     gstk_plineh,Y
000865r 1               
000865r 1               ; token $24 - "THEN"
000865r 1               ; token $5F - "GOTO" statement
000865r 1  20 rr rr     goto_stmt:      JSR     get16bit
000868r 1  20 rr rr             JSR     find_line
00086Br 1  90 04                BCC     Le867
00086Dr 1  A0 37                LDY     #$37
00086Fr 1  D0 36                BNE     go_errmess_4
000871r 1  A5 E4        Le867:  LDA     p2
000873r 1  A4 E5                LDY     p2+1
000875r 1               
000875r 1               ; loop to run a program
000875r 1  85 DC        run_loop:       STA     pline
000877r 1  84 DD                STY     pline+1
000879r 1                       ;BIT     KBDCR ;is keyboard key pressed?
000879r 1                       ;BMI     Le8c3 ;if a key is pressed, stop the program...
000879r 1  18                   CLC
00087Ar 1  69 03                ADC     #$03
00087Cr 1  90 01                BCC     Le87a
00087Er 1  C8                   INY
00087Fr 1  A2 FF        Le87a:  LDX     #$FF
000881r 1  86 D9                STX     run_flag
000883r 1  9A                   TXS
000884r 1  85 E0                STA     pverb
000886r 1  84 E1                STY     pverb+1
000888r 1  20 rr rr     Le883:  JSR     execute_stmt
00088Br 1  24 D9                BIT     run_flag
00088Dr 1  10 49                BPL     end_stmt
00088Fr 1  18                   CLC
000890r 1  A0 00                LDY     #$00
000892r 1  A5 DC                LDA     pline
000894r 1  71 DC                ADC     (pline),Y
000896r 1  A4 DD                LDY     pline+1
000898r 1  90 01                BCC     Le896
00089Ar 1  C8                   INY
00089Br 1  C5 4C        Le896:  CMP     himem
00089Dr 1  D0 D6                BNE     run_loop
00089Fr 1  C4 4D                CPY     himem+1
0008A1r 1  D0 D2                BNE     run_loop
0008A3r 1  A0 34                LDY     #$34
0008A5r 1  46 D9                LSR     run_flag
0008A7r 1  4C rr rr     go_errmess_4:   JMP     print_err_msg
0008AAr 1               
0008AAr 1               ; token $5B - "RETURN" statement
0008AAr 1  A0 4A        return_stmt:    LDY     #$4A
0008ACr 1  A5 FC                LDA     gosub_nest_count
0008AEr 1  F0 F7                BEQ     go_errmess_4
0008B0r 1  C6 FC                DEC     gosub_nest_count
0008B2r 1  A8                   TAY
0008B3r 1  B9 0F 01             LDA     gstk_plinel-1,Y
0008B6r 1  85 DC                STA     pline
0008B8r 1  B9 17 01             LDA     gstk_plineh-1,Y
0008BBr 1  85 DD                STA     pline+1
0008BDr 1  BE FF 00             LDX     a:synpag+1,Y            ; force absolute addressing mode
0008C0r 1  B9 07 01             LDA     gstk_pverbh-1,Y
0008C3r 1  A8           Le8be:  TAY
0008C4r 1  8A                   TXA
0008C5r 1  4C rr rr             JMP     Le87a
0008C8r 1  A0 63        Le8c3:  LDY     #$63 ;will print error "Stopped At: " and line no.
0008CAr 1  20 rr rr             JSR     Se3c4
0008CDr 1  A0 01                LDY     #$01
0008CFr 1  B1 DC                LDA     (pline),Y
0008D1r 1  AA                   TAX
0008D2r 1  C8                   INY
0008D3r 1  B1 DC                LDA     (pline),Y
0008D5r 1  20 rr rr             JSR     prdec
0008D8r 1               
0008D8r 1               ; token $51 - "END" statement
0008D8r 1  4C rr rr     end_stmt:       JMP     warm
0008DBr 1  C6 FB        Le8d6:  DEC     for_nest_count
0008DDr 1               
0008DDr 1               ; token $59 - "NEXT" statement
0008DDr 1               ; token $5A - "," in NEXT statement
0008DDr 1  A0 5B        next_stmt:      LDY     #$5B
0008DFr 1  A5 FB                LDA     for_nest_count
0008E1r 1  F0 C4        Le8dc:  BEQ     go_errmess_4
0008E3r 1  A8                   TAY
0008E4r 1  B5 50                LDA     noun_stk_l,X
0008E6r 1  D9 1F 01             CMP     fstk_varl-1,Y
0008E9r 1  D0 F0                BNE     Le8d6
0008EBr 1  B5 78                LDA     noun_stk_h_str,X
0008EDr 1  D9 27 01             CMP     fstk_varh-1,Y
0008F0r 1  D0 E9                BNE     Le8d6
0008F2r 1  B9 2F 01             LDA     fstk_stepl-1,Y
0008F5r 1  85 DA                STA     aux
0008F7r 1  B9 37 01             LDA     fstk_steph-1,Y
0008FAr 1  85 DB                STA     aux+1
0008FCr 1  20 rr rr             JSR     get16bit
0008FFr 1  CA                   DEX
000900r 1  20 rr rr             JSR     Se793
000903r 1  20 rr rr             JSR     var_assign
000906r 1  CA                   DEX
000907r 1  A4 FB                LDY     for_nest_count
000909r 1  B9 67 01             LDA     fstk_toh-1,Y
00090Cr 1  95 9F                STA     syn_stk_l+31,X
00090Er 1  B9 5F 01             LDA     fstk_tol-1,Y
000911r 1  A0 00                LDY     #$00
000913r 1  20 rr rr             JSR     push_ya_noun_stk
000916r 1  20 rr rr             JSR     subtract
000919r 1  20 rr rr             JSR     sgn_fn
00091Cr 1  20 rr rr             JSR     get16bit
00091Fr 1  A4 FB                LDY     for_nest_count
000921r 1  A5 CE                LDA     acc
000923r 1  F0 05                BEQ     Le925
000925r 1  59 37 01             EOR     fstk_steph-1,Y
000928r 1  10 12                BPL     Le937
00092Ar 1  B9 3F 01     Le925:  LDA     fstk_plinel-1,Y
00092Dr 1  85 DC                STA     pline
00092Fr 1  B9 47 01             LDA     fstk_plineh-1,Y
000932r 1  85 DD                STA     pline+1
000934r 1  BE 4F 01             LDX     fstk_pverbl-1,Y
000937r 1  B9 57 01             LDA     fstk_pverbh-1,Y
00093Ar 1  D0 87                BNE     Le8be
00093Cr 1  C6 FB        Le937:  DEC     for_nest_count
00093Er 1  60                   RTS
00093Fr 1               
00093Fr 1               ; token $55 - "FOR" statement
00093Fr 1  A0 54        for_stmt:       LDY     #$54
000941r 1  A5 FB                LDA     for_nest_count
000943r 1  C9 08                CMP     #$08
000945r 1  F0 9A                BEQ     Le8dc
000947r 1  E6 FB                INC     for_nest_count
000949r 1  A8                   TAY
00094Ar 1  B5 50                LDA     noun_stk_l,X
00094Cr 1  99 20 01             STA     fstk_varl,Y
00094Fr 1  B5 78                LDA     noun_stk_h_str,X
000951r 1  99 28 01             STA     fstk_varh,Y
000954r 1  60                   RTS
000955r 1               
000955r 1               ; token $57 - "TO"
000955r 1  20 rr rr     to_clause:      JSR     get16bit
000958r 1  A4 FB                LDY     for_nest_count
00095Ar 1  A5 CE                LDA     acc
00095Cr 1  99 5F 01             STA     fstk_tol-1,Y
00095Fr 1  A5 CF                LDA     acc+1
000961r 1  99 67 01             STA     fstk_toh-1,Y
000964r 1  A9 01                LDA     #$01
000966r 1  99 2F 01             STA     fstk_stepl-1,Y
000969r 1  A9 00                LDA     #$00
00096Br 1  99 37 01     Le966:  STA     fstk_steph-1,Y
00096Er 1  A5 DC                LDA     pline
000970r 1  99 3F 01             STA     fstk_plinel-1,Y
000973r 1  A5 DD                LDA     pline+1
000975r 1  99 47 01             STA     fstk_plineh-1,Y
000978r 1  A5 E0                LDA     pverb
00097Ar 1  99 4F 01             STA     fstk_pverbl-1,Y
00097Dr 1  A5 E1                LDA     pverb+1
00097Fr 1  99 57 01             STA     fstk_pverbh-1,Y
000982r 1  60                   RTS
000983r 1               
000983r 1  20 rr rr     Te97e:  JSR     get16bit
000986r 1  A4 FB                LDY     for_nest_count
000988r 1  A5 CE                LDA     acc
00098Ar 1  99 2F 01             STA     fstk_stepl-1,Y
00098Dr 1  A5 CF                LDA     acc+1
00098Fr 1  4C rr rr             JMP     Le966
000992r 1  00 00 00 00          .byte   $00,$00,$00,$00,$00,$00,$00,$00 ; "........"
000996r 1  00 00 00 00  
00099Ar 1  00 00 00             .byte   $00,$00,$00                     ; "..."
00099Dr 1               
00099Dr 1               ; verb precedence
00099Dr 1               ; (verb_prec[token]&0xAA)>>1 for left (?)
00099Dr 1               ; verb_prec[token]&0x55 for right (?)
00099Dr 1               verb_prec_tbl:
00099Dr 1  00 00 00 AB          .byte   $00,$00,$00,$AB,$03,$03,$03,$03 ; "...+...."
0009A1r 1  03 03 03 03  
0009A5r 1  03 03 03 03          .byte   $03,$03,$03,$03,$03,$03,$03,$03 ; "........"
0009A9r 1  03 03 03 03  
0009ADr 1  03 03 3F 3F          .byte   $03,$03,$3F,$3F,$C0,$C0,$3C,$3C ; "..??@@<<"
0009B1r 1  C0 C0 3C 3C  
0009B5r 1  3C 3C 3C 3C          .byte   $3C,$3C,$3C,$3C,$3C,$30,$0F,$C0 ; "<<<<<0.@"
0009B9r 1  3C 30 0F C0  
0009BDr 1  CC FF 55 00          .byte   $CC,$FF,$55,$00,$AB,$AB,$03,$03 ; "L.U.++.."
0009C1r 1  AB AB 03 03  
0009C5r 1  FF FF 55 FF          .byte   $FF,$FF,$55,$FF,$FF,$55,$CF,$CF ; "..U..UOO"
0009C9r 1  FF 55 CF CF  
0009CDr 1  CF CF CF FF          .byte   $CF,$CF,$CF,$FF,$55,$C3,$C3,$C3 ; "OOO.UCCC"
0009D1r 1  55 C3 C3 C3  
0009D5r 1  55 F0 F0 CF          .byte   $55,$F0,$F0,$CF,$56,$56,$56,$55 ; "UppOVVVU"
0009D9r 1  56 56 56 55  
0009DDr 1  FF FF 55 03          .byte   $FF,$FF,$55,$03,$03,$03,$03,$03 ; "..U....."
0009E1r 1  03 03 03 03  
0009E5r 1  03 03 FF FF          .byte   $03,$03,$FF,$FF,$FF,$03,$03,$03 ; "........"
0009E9r 1  FF 03 03 03  
0009EDr 1  03 03 03 03          .byte   $03,$03,$03,$03,$03,$03,$03,$03 ; "........"
0009F1r 1  03 03 03 03  
0009F5r 1  03 03 03 03          .byte   $03,$03,$03,$03,$03,$00,$AB,$03 ; "......+."
0009F9r 1  03 00 AB 03  
0009FDr 1  57 03 03 03          .byte   $57,$03,$03,$03,$03,$07,$03,$03 ; "W......."
000A01r 1  03 07 03 03  
000A05r 1  03 03 03 03          .byte   $03,$03,$03,$03,$03,$03,$03,$03 ; "........"
000A09r 1  03 03 03 03  
000A0Dr 1  03 03 AA FF          .byte   $03,$03,$AA,$FF,$FF,$FF,$FF,$FF ; "..*....."
000A11r 1  FF FF FF FF  
000A15r 1               verb_adr_l:
000A15r 1  17 FF FF 19          .byte   $17,$FF,$FF,$19,$5D,$35,$4B,$F2 ; "....]5Kr"
000A19r 1  5D 35 4B F2  
000A1Dr 1  EC 87 6F AD          .byte   $EC,$87,$6F,$AD,$B7,$E2,$F8,$54 ; "l.o-7bxT"
000A21r 1  B7 E2 F8 54  
000A25r 1  80 96 85 82          .byte   $80,$96,$85,$82,$22,$10,$33,$4A ; "....".3J"
000A29r 1  22 10 33 4A  
000A2Dr 1  13 06 0B 4A          .byte   $13,$06,$0B,$4A,$01,$40,$47,$7A ; "...J.@Gz"
000A31r 1  01 40 47 7A  
000A35r 1  00 FF 23 09          .byte   $00,$FF,$23,$09,$5B,$16,$B6,$CB ; "..#.[.6K"
000A39r 1  5B 16 B6 CB  
000A3Dr 1  FF FF FB FF          .byte   $FF,$FF,$FB,$FF,$FF,$24,$F6,$4E ; "..{..$vN"
000A41r 1  FF 24 F6 4E  
000A45r 1  59 50 00 FF          .byte   $59,$50,$00,$FF,$23,$A3,$6F,$36 ; "YP..##o6"
000A49r 1  23 A3 6F 36  
000A4Dr 1  23 D7 1C 22          .byte   $23,$D7,$1C,$22,$C2,$AE,$BA,$23 ; "#W."B.:#"
000A51r 1  C2 AE BA 23  
000A55r 1  FF FF 21 30          .byte   $FF,$FF,$21,$30,$1E,$03,$C4,$20 ; "..!0..D "
000A59r 1  1E 03 C4 20  
000A5Dr 1  00 C1 FF FF          .byte   $00,$C1,$FF,$FF,$FF,$A0,$30,$1E ; ".A... 0."
000A61r 1  FF A0 30 1E  
000A65r 1  A4 D3 B6 BC          .byte   $A4,$D3,$B6,$BC,$AA,$3A,$01,$50 ; "$S6<*:.P"
000A69r 1  AA 3A 01 50  
000A6Dr 1  7E D8 D8 A5          .byte   $7E,$D8,$D8,$A5,$3C,$FF,$16,$5B ; "~XX%<..["
000A71r 1  3C FF 16 5B  
000A75r 1  28 03 C4 1D          .byte   $28,$03,$C4,$1D,$00,$0C,$4E,$00 ; "(.D...N."
000A79r 1  00 0C 4E 00  
000A7Dr 1  3E 00 A6 B0          .byte   $3E,$00,$A6,$B0,$00,$BC,$C6,$57 ; ">.&0.<FW"
000A81r 1  00 BC C6 57  
000A85r 1  8C 01 27 FF          .byte   $8C,$01,$27,$FF,$FF,$FF,$FF,$FF ; "..'....."
000A89r 1  FF FF FF FF  
000A8Dr 1               verb_adr_h:
000A8Dr 1  E8 FF FF E8          .byte   $E8,$FF,$FF,$E8,$E0,$E0,$E0,$EF ; "h..h```o"
000A91r 1  E0 E0 E0 EF  
000A95r 1  EF E3 E3 E5          .byte   $EF,$E3,$E3,$E5,$E5,$E7,$E7,$EE ; "occeeggn"
000A99r 1  E5 E7 E7 EE  
000A9Dr 1  EF EF E7 E7          .byte   $EF,$EF,$E7,$E7,$E2,$EF,$E7,$E7 ; "ooggbogg"
000AA1r 1  E2 EF E7 E7  
000AA5r 1  EC EC EC E7          .byte   $EC,$EC,$EC,$E7,$EC,$EC,$EC,$E2 ; "lllglllb"
000AA9r 1  EC EC EC E2  
000AADr 1  00 FF E8 E1          .byte   $00,$FF,$E8,$E1,$E8,$E8,$EF,$EB ; "..hahhok"
000AB1r 1  E8 E8 EF EB  
000AB5r 1  FF FF E0 FF          .byte   $FF,$FF,$E0,$FF,$FF,$EF,$EE,$EF ; "..`..ono"
000AB9r 1  FF EF EE EF  
000ABDr 1  E7 E7 00 FF          .byte   $E7,$E7,$00,$FF,$E8,$E7,$E7,$E7 ; "gg..hggg"
000AC1r 1  E8 E7 E7 E7  
000AC5r 1  E8 E1 E2 EE          .byte   $E8,$E1,$E2,$EE,$EE,$EE,$EE,$E8 ; "habnnnnh"
000AC9r 1  EE EE EE E8  
000ACDr 1  FF FF E1 E1          .byte   $FF,$FF,$E1,$E1,$EF,$EE,$E7,$E8 ; "..aaongh"
000AD1r 1  EF EE E7 E8  
000AD5r 1  EE E7 FF FF          .byte   $EE,$E7,$FF,$FF,$FF,$EE,$E1,$EF ; "ng...nao"
000AD9r 1  FF EE E1 EF  
000ADDr 1  E7 E8 EF EF          .byte   $E7,$E8,$EF,$EF,$EB,$E9,$E8,$E9 ; "ghookihi"
000AE1r 1  EB E9 E8 E9  
000AE5r 1  E9 E8 E8 E8          .byte   $E9,$E8,$E8,$E8,$E8,$FF,$E8,$E8 ; "ihhhh.hh"
000AE9r 1  E8 FF E8 E8  
000AEDr 1  E8 EE E7 E8          .byte   $E8,$EE,$E7,$E8,$EF,$EF,$EE,$EF ; "hnghoono"
000AF1r 1  EF EF EE EF  
000AF5r 1  EE EF EE EE          .byte   $EE,$EF,$EE,$EE,$EF,$EE,$EE,$EE ; "nonnonnn"
000AF9r 1  EF EE EE EE  
000AFDr 1  E1 E8 E8 FF          .byte   $E1,$E8,$E8,$FF,$FF,$FF,$FF,$FF ; "ahh....."
000B01r 1  FF FF FF FF  
000B05r 1               
000B05r 1               ; Error message strings. Last character has high bit unset.
000B05r 1               error_msg_tbl:
000B05r 1  BE B3 B2 B7          .byte   $BE,$B3,$B2,$B7,$B6,$37         ; ">32767"
000B09r 1  B6 37        
000B0Br 1  D4 CF CF A0          .byte   $D4,$CF,$CF,$A0,$CC,$CF,$CE,$47 ; "TOO LONG"
000B0Fr 1  CC CF CE 47  
000B13r 1  D3 D9 CE D4          .byte   $D3,$D9,$CE,$D4,$C1,$58         ; "SYNTAX"
000B17r 1  C1 58        
000B19r 1  CD C5 CD A0          .byte   $CD,$C5,$CD,$A0,$C6,$D5,$CC,$4C ; "MEM FULL"
000B1Dr 1  C6 D5 CC 4C  
000B21r 1  D4 CF CF A0          .byte   $D4,$CF,$CF,$A0,$CD,$C1,$CE,$D9,$A0,$D0,$C1,$D2,$C5,$CE,$53 ; "TOO MANY PARENS"
000B25r 1  CD C1 CE D9  
000B29r 1  A0 D0 C1 D2  
000B30r 1  D3 D4 D2 C9          .byte   $D3,$D4,$D2,$C9,$CE,$47         ; "STRING"
000B34r 1  CE 47        
000B36r 1  CE CF A0 C5          .byte   $CE,$CF,$A0,$C5,$CE,$44         ; "NO END"
000B3Ar 1  CE 44        
000B3Cr 1  C2 C1 C4 A0          .byte   $C2,$C1,$C4,$A0,$C2,$D2,$C1,$CE,$C3,$48 ; "BAD BRANCH"
000B40r 1  C2 D2 C1 CE  
000B44r 1  C3 48        
000B46r 1  BE B8 A0 C7          .byte   $BE,$B8,$A0,$C7,$CF,$D3,$D5,$C2,$53     ; ">8 GOSUBS"
000B4Ar 1  CF D3 D5 C2  
000B4Er 1  53           
000B4Fr 1  C2 C1 C4 A0          .byte   $C2,$C1,$C4,$A0,$D2,$C5,$D4,$D5,$D2,$4E ; "BAD RETURN"
000B53r 1  D2 C5 D4 D5  
000B57r 1  D2 4E        
000B59r 1  BE B8 A0 C6          .byte   $BE,$B8,$A0,$C6,$CF,$D2,$53     ; ">8 FORS"
000B5Dr 1  CF D2 53     
000B60r 1  C2 C1 C4 A0          .byte   $C2,$C1,$C4,$A0,$CE,$C5,$D8,$54 ; "BAD NEXT"
000B64r 1  CE C5 D8 54  
000B68r 1  D3 D4 CF D0          .byte   $D3,$D4,$CF,$D0,$D0,$C5,$C4,$A0,$C1,$D4,$20 ; "STOPPED AT "
000B6Cr 1  D0 C5 C4 A0  
000B70r 1  C1 D4 20     
000B73r 1  AA AA AA 20          .byte   $AA,$AA,$AA,$20                 ; "*** "
000B77r 1  A0 C5 D2 D2          .byte   $A0,$C5,$D2,$D2,$0D             ; " ERR.\n"
000B7Br 1  0D           
000B7Cr 1  BE B2 B5 35          .byte   $BE,$B2,$B5,$35                 ; ">255"
000B80r 1  D2 C1 CE C7          .byte   $D2,$C1,$CE,$C7,$45             ; RANGE"
000B84r 1  45           
000B85r 1  C4 C9 4D             .byte   $C4,$C9,$4D                     ; "DIM"
000B88r 1  D3 D4 D2 A0          .byte   $D3,$D4,$D2,$A0,$CF,$D6,$C6,$4C ; "STR OVFL"
000B8Cr 1  CF D6 C6 4C  
000B90r 1  DC 0D                .byte   $DC,$0D                         ; "\\\n"
000B92r 1  D2 C5 D4 D9          .byte   $D2,$C5,$D4,$D9,$D0,$C5,$A0,$CC,$C9,$CE,$C5,$8D ; "RETYPE LINE\n"
000B96r 1  D0 C5 A0 CC  
000B9Ar 1  C9 CE C5 8D  
000B9Er 1  3F                   .byte   $3F                             ; "?"
000B9Fr 1  46 D9        Leb9a:  LSR     run_flag
000BA1r 1  90 03                BCC     Leba1
000BA3r 1  4C rr rr             JMP     Le8c3
000BA6r 1  A6 CF        Leba1:  LDX     acc+1
000BA8r 1  9A                   TXS
000BA9r 1  A6 CE                LDX     acc
000BABr 1  A0 8D                LDY     #$8D
000BADr 1  D0 02                BNE     Lebac
000BAFr 1               
000BAFr 1               ; token $54 - "INPUT" statement, numeric, no prompt
000BAFr 1  A0 99        input_num_stmt: LDY     #$99
000BB1r 1  20 rr rr     Lebac:  JSR     Se3c4
000BB4r 1  86 CE                STX     acc
000BB6r 1  BA                   TSX
000BB7r 1  86 CF                STX     acc+1
000BB9r 1  A0 FE                LDY     #$FE
000BBBr 1  84 D9                STY     run_flag
000BBDr 1  C8                   INY
000BBEr 1  84 C8                STY     text_index
000BC0r 1  20 rr rr             JSR     Se299
000BC3r 1  84 F1                STY     token_index
000BC5r 1  A2 20                LDX     #$20
000BC7r 1  A9 30                LDA     #$30
000BC9r 1  20 rr rr             JSR     Se491
000BCCr 1  E6 D9                INC     run_flag
000BCEr 1  A6 CE                LDX     acc
000BD0r 1               
000BD0r 1               ; token $27 - "," numeric input
000BD0r 1  A4 C8        input_num_comma:        LDY     text_index
000BD2r 1  0A                   ASL
000BD3r 1  85 CE        Lebce:  STA     acc
000BD5r 1  C8                   INY
000BD6r 1  B9 00 02             LDA     buffer,Y
000BD9r 1  C9 74                CMP     #$74
000BDBr 1  F0 D2                BEQ     input_num_stmt
000BDDr 1  49 B0                EOR     #$B0
000BDFr 1  C9 0A                CMP     #$0A
000BE1r 1  B0 F0                BCS     Lebce
000BE3r 1  C8                   INY
000BE4r 1  C8                   INY
000BE5r 1  84 C8                STY     text_index
000BE7r 1  B9 00 02             LDA     buffer,Y
000BEAr 1  48                   PHA
000BEBr 1  B9 FF 01             LDA     buffer-1,Y
000BEEr 1  A0 00                LDY     #$00
000BF0r 1  20 rr rr             JSR     push_ya_noun_stk
000BF3r 1  68                   PLA
000BF4r 1  95 A0                STA     noun_stk_h_int,X
000BF6r 1  A5 CE                LDA     acc
000BF8r 1  C9 C7                CMP     #$C7
000BFAr 1  D0 03                BNE     Lebfa
000BFCr 1  20 rr rr             JSR     negate
000BFFr 1  4C rr rr     Lebfa:  JMP     var_assign
000C02r 1               
000C02r 1  FF FF FF 50          .byte   $FF,$FF,$FF,$50
000C06r 1               
000C06r 1  20 rr rr     Tec01:  JSR     Tec13
000C09r 1  D0 15                BNE     Lec1b
000C0Br 1               
000C0Br 1  20 rr rr     Tec06:  JSR     Tec0b
000C0Er 1  D0 10                BNE     Lec1b
000C10r 1               
000C10r 1  20 rr rr     Tec0b:  JSR     subtract
000C13r 1  20 rr rr             JSR     negate
000C16r 1  50 03                BVC     Lec16
000C18r 1               
000C18r 1  20 rr rr     Tec13:  JSR     subtract
000C1Br 1  20 rr rr     Lec16:  JSR     sgn_fn
000C1Er 1  56 50                LSR     noun_stk_l,X
000C20r 1  4C rr rr     Lec1b:  JMP     not_op
000C23r 1               
000C23r 1  FF FF                .byte   $FF,$FF
000C25r 1               
000C25r 1               ; indexes into syntabl
000C25r 1               syntabl_index:
000C25r 1  C1 FF 7F D1          .byte   $C1,$FF,$7F,$D1,$CC,$C7,$CF,$CE ; "A..QLGON"
000C29r 1  CC C7 CF CE  
000C2Dr 1  C5 9A 98 8B          .byte   $C5,$9A,$98,$8B,$96,$95,$93,$BF ; "E......?"
000C31r 1  96 95 93 BF  
000C35r 1  B2 32 2D 2B          .byte   $B2,$32,$2D,$2B,$BC,$B0,$AC,$BE ; "22-+<0,>"
000C39r 1  BC B0 AC BE  
000C3Dr 1  35 8E 61 FF          .byte   $35,$8E,$61,$FF,$FF,$FF,$DD,$FB ; "5.a...]{"
000C41r 1  FF FF DD FB  
000C45r 1               
000C45r 1  20 rr rr     Tec40:  JSR     Sefc9
000C48r 1  15 4F                ORA     rnd+1,X
000C4Ar 1  10 05                BPL     Lec4c
000C4Cr 1               
000C4Cr 1  20 rr rr     Tec47:  JSR     Sefc9
000C4Fr 1  35 4F                AND     rnd+1,X
000C51r 1  95 50        Lec4c:  STA     noun_stk_l,X
000C53r 1  10 CB                BPL     Lec1b
000C55r 1  4C rr rr             JMP     Sefc9
000C58r 1  40 60 8D 60          .byte   $40,$60,$8D,$60,$8B,$00,$7E,$8C ; "@`.`..~."
000C5Cr 1  8B 00 7E 8C  
000C60r 1  33 00 00 60          .byte   $33,$00,$00,$60,$03,$BF,$12,$00 ; "3..`.?.."
000C64r 1  03 BF 12 00  
000C68r 1  40 89 C9 47          .byte   $40,$89,$C9,$47,$9D,$17,$68,$9D ; "@.IG..h."
000C6Cr 1  9D 17 68 9D  
000C70r 1  0A 00 40 60          .byte   $0A,$00,$40,$60,$8D,$60,$8B,$00 ; "..@`.`.."
000C74r 1  8D 60 8B 00  
000C78r 1  7E 8C 3C 00          .byte   $7E,$8C,$3C,$00,$00,$60,$03,$BF ; "~.<..`.?"
000C7Cr 1  00 60 03 BF  
000C80r 1  1B 4B 67 B4          .byte   $1B,$4B,$67,$B4,$A1,$07,$8C,$07 ; ".Kg4!..."
000C84r 1  A1 07 8C 07  
000C88r 1  AE A9 AC A8          .byte   $AE,$A9,$AC,$A8,$67,$8C,$07,$B4 ; ".),(g..4"
000C8Cr 1  67 8C 07 B4  
000C90r 1  AF AC B0 67          .byte   $AF,$AC,$B0,$67,$9D,$B2,$AF,$AC ; "/,0g.2/,"
000C94r 1  9D B2 AF AC  
000C98r 1  AF A3 67 8C          .byte   $AF,$A3,$67,$8C,$07,$A5,$AB,$AF ; "/#g..%+/"
000C9Cr 1  07 A5 AB AF  
000CA0r 1  B0 F4 AE A9          .byte   $B0,$F4,$AE,$A9,$B2,$B0,$7F,$0E ; "0t.)20.."
000CA4r 1  B2 B0 7F 0E  
000CA8r 1  27 B4 AE A9          .byte   $27,$B4,$AE,$A9,$B2,$B0,$7F,$0E ; "'4.)20.."
000CACr 1  B2 B0 7F 0E  
000CB0r 1  28 B4 AE A9          .byte   $28,$B4,$AE,$A9,$B2,$B0,$64,$07 ; "(4.)20d."
000CB4r 1  B2 B0 64 07  
000CB8r 1  A6 A9 67 AF          .byte   $A6,$A9,$67,$AF,$B4,$AF,$A7,$78 ; "&)g/4/'x"
000CBCr 1  B4 AF A7 78  
000CC0r 1  B4 A5 AC 78          .byte   $B4,$A5,$AC,$78,$7F,$02,$AD,$A5 ; "4%,x..-%"
000CC4r 1  7F 02 AD A5  
000CC8r 1  B2 67 A2 B5          .byte   $B2,$67,$A2,$B5,$B3,$AF,$A7,$EE ; "2g"53/'n"
000CCCr 1  B3 AF A7 EE  
000CD0r 1  B2 B5 B4 A5          .byte   $B2,$B5,$B4,$A5,$B2,$7E,$8C,$39 ; "254%2~.9"
000CD4r 1  B2 7E 8C 39  
000CD8r 1  B4 B8 A5 AE          .byte   $B4,$B8,$A5,$AE,$67,$B0,$A5,$B4 ; "48%.g0%4"
000CDCr 1  67 B0 A5 B4  
000CE0r 1  B3 27 AF B4          .byte   $B3,$27,$AF,$B4,$07,$9D,$19,$B2 ; "3'/4...2"
000CE4r 1  07 9D 19 B2  
000CE8r 1  AF A6 7F 05          .byte   $AF,$A6,$7F,$05,$37,$B4,$B5,$B0 ; "/&..7450"
000CECr 1  37 B4 B5 B0  
000CF0r 1  AE A9 7F 05          .byte   $AE,$A9,$7F,$05,$28,$B4,$B5,$B0 ; ".)..(450"
000CF4r 1  28 B4 B5 B0  
000CF8r 1  AE A9 7F 05          .byte   $AE,$A9,$7F,$05,$2A,$B4,$B5,$B0 ; ".)..*450"
000CFCr 1  2A B4 B5 B0  
000D00r 1  AE A9 E4 AE          .byte   $AE,$A9,$E4,$AE,$A5,$00,$FF,$FF ; ".)d.%..."
000D04r 1  A5 00 FF FF  
000D08r 1               syntabl2:
000D08r 1  47 A2 A1 B4          .byte   $47,$A2,$A1,$B4,$7F,$0D,$30,$AD ; "G"!4..0-"
000D0Cr 1  7F 0D 30 AD  
000D10r 1  A9 A4 7F 0D          .byte   $A9,$A4,$7F,$0D,$23,$AD,$A9,$A4 ; ")$..#-)$"
000D14r 1  23 AD A9 A4  
000D18r 1  67 AC AC A1          .byte   $67,$AC,$AC,$A1,$A3,$00,$40,$80 ; "g,,!#.@."
000D1Cr 1  A3 00 40 80  
000D20r 1  C0 C1 80 00          .byte   $C0,$C1,$80,$00,$47,$8C,$68,$8C ; "@A..G.h."
000D24r 1  47 8C 68 8C  
000D28r 1  DB 67 9B 68          .byte   $DB,$67,$9B,$68,$9B,$50,$8C,$63 ; "[g.h.P.c"
000D2Cr 1  9B 50 8C 63  
000D30r 1  8C 7F 01 51          .byte   $8C,$7F,$01,$51,$07,$88,$29,$84 ; "...Q..)."
000D34r 1  07 88 29 84  
000D38r 1  80 C4 80 57          .byte   $80,$C4,$80,$57,$71,$07,$88,$14 ; ".D.Wq..."
000D3Cr 1  71 07 88 14  
000D40r 1  ED A5 AD AF          .byte   $ED,$A5,$AD,$AF,$AC,$ED,$A5,$AD ; "m%-/,m%-"
000D44r 1  AC ED A5 AD  
000D48r 1  A9 A8 F2 AF          .byte   $A9,$A8,$F2,$AF,$AC,$AF,$A3,$71 ; ")(r/,/#q"
000D4Cr 1  AC AF A3 71  
000D50r 1  08 88 AE A5          .byte   $08,$88,$AE,$A5,$AC,$68,$83,$08 ; "...%,h.."
000D54r 1  AC 68 83 08  
000D58r 1  68 9D 08 71          .byte   $68,$9D,$08,$71,$07,$88,$60,$76 ; "h..q..`v"
000D5Cr 1  07 88 60 76  
000D60r 1  B4 AF AE 76          .byte   $B4,$AF,$AE,$76,$8D,$76,$8B,$51 ; "4/.v.v.Q"
000D64r 1  8D 76 8B 51  
000D68r 1  07 88 19 B8          .byte   $07,$88,$19,$B8,$A4,$AE,$B2,$F2 ; "...8$.2r"
000D6Cr 1  A4 AE B2 F2  
000D70r 1  B3 B5 F3 A2          .byte   $B3,$B5,$F3,$A2,$A1,$EE,$A7,$B3 ; "35s"!n'3"
000D74r 1  A1 EE A7 B3  
000D78r 1  E4 AE B2 EB          .byte   $E4,$AE,$B2,$EB,$A5,$A5,$B0,$51 ; "d.2k%%0Q"
000D7Cr 1  A5 A5 B0 51  
000D80r 1  07 88 39 81          .byte   $07,$88,$39,$81,$C1,$4F,$7F,$0F ; "..9.AO.."
000D84r 1  C1 4F 7F 0F  
000D88r 1  2F 00 51 06          .byte   $2F,$00,$51,$06,$88,$29,$C2,$0C ; "/.Q..)B."
000D8Cr 1  88 29 C2 0C  
000D90r 1  82 57 8C 6A          .byte   $82,$57,$8C,$6A,$8C,$42,$AE,$A5 ; ".W.j.B.%"
000D94r 1  8C 42 AE A5  
000D98r 1  A8 B4 60 AE          .byte   $A8,$B4,$60,$AE,$A5,$A8,$B4,$4F ; "(4`.%(4O"
000D9Cr 1  A5 A8 B4 4F  
000DA0r 1  7E 1E 35 8C          .byte   $7E,$1E,$35,$8C,$27,$51,$07,$88 ; "~.5.'Q.."
000DA4r 1  27 51 07 88  
000DA8r 1  09 8B FE E4          .byte   $09,$8B,$FE,$E4,$AF,$AD,$F2,$AF ; "..~d/-r/"
000DACr 1  AF AD F2 AF  
000DB0r 1  E4 AE A1 DC          .byte   $E4,$AE,$A1,$DC,$DE,$9C,$DD,$9C ; "d.!\^.]."
000DB4r 1  DE 9C DD 9C  
000DB8r 1  DE DD 9E C3          .byte   $DE,$DD,$9E,$C3,$DD,$CF,$CA,$CD ; "^].C]OJM"
000DBCr 1  DD CF CA CD  
000DC0r 1  CB 00 47 9D          .byte   $CB,$00,$47,$9D,$AD,$A5,$AD,$AF ; "K.G.-%-/"
000DC4r 1  AD A5 AD AF  
000DC8r 1  AC 76 9D AD          .byte   $AC,$76,$9D,$AD,$A5,$AD,$A9,$A8 ; ",v.-%-)("
000DCCr 1  A5 AD A9 A8  
000DD0r 1  E6 A6 AF 60          .byte   $E6,$A6,$AF,$60,$8C,$20,$AF,$B4 ; "f&/`. /4"
000DD4r 1  8C 20 AF B4  
000DD8r 1  B5 A1 F2 AC          .byte   $B5,$A1,$F2,$AC,$A3,$F2,$A3,$B3 ; "5!r,#r#3"
000DDCr 1  A3 F2 A3 B3  
000DE0r 1  60 8C 20 AC          .byte   $60,$8C,$20,$AC,$A5,$A4,$EE,$B5 ; "`. ,%$n5"
000DE4r 1  A5 A4 EE B5  
000DE8r 1  B2 60 AE B5          .byte   $B2,$60,$AE,$B5,$B2,$F4,$B3,$A9 ; "2`.52t3)"
000DECr 1  B2 F4 B3 A9  
000DF0r 1  AC 60 8C 20          .byte   $AC,$60,$8C,$20,$B4,$B3,$A9,$AC ; ",`. 43),"
000DF4r 1  B4 B3 A9 AC  
000DF8r 1  7A 7E 9A 22          .byte   $7A,$7E,$9A,$22,$20,$00,$60,$03 ; "z~." .`."
000DFCr 1  20 00 60 03  
000E00r 1  BF 60 03 BF          .byte   $BF,$60,$03,$BF,$1F             ; "?`.?."
000E04r 1  1F           
000E05r 1               
000E05r 1               ; token $48 - "," string output
000E05r 1  20 rr rr     print_str_comma:        JSR     tabout
000E08r 1               
000E08r 1               ; token $45 - ";" string output
000E08r 1               ; token $61 - "PRINT" string
000E08r 1  E8           print_str:      INX
000E09r 1  E8                   INX
000E0Ar 1  B5 4F                LDA     rnd+1,X
000E0Cr 1  85 DA                STA     aux
000E0Er 1  B5 77                LDA     syn_stk_h+31,X
000E10r 1  85 DB                STA     aux+1
000E12r 1  B4 4E                LDY     rnd,X
000E14r 1  98           Lee0f:  TYA
000E15r 1  D5 76                CMP     syn_stk_h+30,X
000E17r 1  B0 09                BCS     Lee1d
000E19r 1  B1 DA                LDA     (aux),Y
000E1Br 1  20 rr rr             JSR     cout
000E1Er 1  C8                   INY
000E1Fr 1  4C rr rr             JMP     Lee0f
000E22r 1  A9 FF        Lee1d:  LDA     #$FF
000E24r 1  85 D5                STA     cr_flag
000E26r 1  60                   RTS
000E27r 1               
000E27r 1               ; token $3B - "LEN(" function
000E27r 1  E8           len_fn: INX
000E28r 1  A9 00                LDA     #$00
000E2Ar 1  95 78                STA     noun_stk_h_str,X
000E2Cr 1  95 A0                STA     noun_stk_h_int,X
000E2Er 1  B5 77                LDA     syn_stk_h+31,X
000E30r 1  38                   SEC
000E31r 1  F5 4F                SBC     rnd+1,X
000E33r 1  95 50                STA     noun_stk_l,X
000E35r 1  4C rr rr             JMP     left_paren
000E38r 1               
000E38r 1  FF                   .byte   $FF
000E39r 1               
000E39r 1  20 rr rr     getbyte:        JSR     get16bit
000E3Cr 1  A5 CF                LDA     acc+1
000E3Er 1  D0 28                BNE     gr_255_err
000E40r 1  A5 CE                LDA     acc
000E42r 1  60                   RTS
000E43r 1               
000E43r 1               ; token $68 - "," for PLOT statement (???)
000E43r 1  20 rr rr     plot_comma:     JSR     getbyte
000E46r 1  A4 C8                LDY     text_index
000E48r 1  C9 30                CMP     #$30
000E4Ar 1  B0 21                BCS     range_err
000E4Cr 1  C0 28                CPY     #$28
000E4Er 1  B0 1D                BCS     range_err
000E50r 1  60                   RTS
000E51r 1  EA                   NOP
000E52r 1  EA                   NOP
000E53r 1               
000E53r 1  20 rr rr     Tee4e:  JSR     getbyte
000E56r 1  60                   RTS
000E57r 1  EA                   NOP
000E58r 1  8A           Tee5e:  TXA
000E59r 1  A2 01                LDX     #$01
000E5Br 1  B4 CE        l123:   LDY     acc,X
000E5Dr 1  94 4C                STY     himem,X
000E5Fr 1  B4 48                LDY     var,X
000E61r 1  94 CA                STY     pp,X
000E63r 1  CA                   DEX
000E64r 1  F0 F5                BEQ     l123
000E66r 1  AA                   TAX
000E67r 1  60                   RTS
000E68r 1  A0 77        gr_255_err:     LDY     #$77            ; > 255 error
000E6Ar 1  4C rr rr     go_errmess_5:   JMP     print_err_msg
000E6Dr 1  A0 7B        range_err:      LDY     #$7B            ; range error
000E6Fr 1  D0 F9                BNE     go_errmess_5
000E71r 1               
000E71r 1  20 rr rr     See6c:  JSR     Se254
000E74r 1  A5 DA                LDA     aux
000E76r 1  D0 07                BNE     Lee7a
000E78r 1  A5 DB                LDA     aux+1
000E7Ar 1  D0 03                BNE     Lee7a
000E7Cr 1  4C rr rr             JMP     Le77e
000E7Fr 1  06 CE        Lee7a:  ASL     acc
000E81r 1  26 CF                ROL     acc+1
000E83r 1  26 E6                ROL     p3
000E85r 1  26 E7                ROL     p3+1
000E87r 1  A5 E6                LDA     p3
000E89r 1  C5 DA                CMP     aux
000E8Br 1  A5 E7                LDA     p3+1
000E8Dr 1  E5 DB                SBC     aux+1
000E8Fr 1  90 0A                BCC     Lee96
000E91r 1  85 E7                STA     p3+1
000E93r 1  A5 E6                LDA     p3
000E95r 1  E5 DA                SBC     aux
000E97r 1  85 E6                STA     p3
000E99r 1  E6 CE                INC     acc
000E9Br 1  88           Lee96:  DEY
000E9Cr 1  D0 E1                BNE     Lee7a
000E9Er 1  60                   RTS
000E9Fr 1               
000E9Fr 1  FF FF FF FF          .byte   $FF,$FF,$FF,$FF,$FF,$FF
000EA3r 1  FF FF        
000EA5r 1               
000EA5r 1               ; token $4D - "CALL" statement
000EA5r 1  20 rr rr     call_stmt:      JSR     get16bit
000EA8r 1  6C CE 00             JMP     (acc)
000EABr 1  A5 4C        l1233:  LDA     himem
000EADr 1  D0 02                BNE     l1235
000EAFr 1  C6 4D                DEC     himem+1
000EB1r 1  C6 4C        l1235:  DEC     himem
000EB3r 1  A5 48                LDA     var
000EB5r 1  D0 02                BNE     l1236
000EB7r 1  C6 49                DEC     var+1
000EB9r 1  C6 48        l1236:  DEC     var
000EBBr 1  A0 00        l1237:  LDY     #$00
000EBDr 1  B1 4C                LDA     (himem),Y
000EBFr 1  91 48                STA     (var),Y
000EC1r 1  A5 CA                LDA     pp
000EC3r 1  C5 4C                CMP     himem
000EC5r 1  A5 CB                LDA     pp+1
000EC7r 1  E5 4D                SBC     himem+1
000EC9r 1  90 E0                BCC     l1233
000ECBr 1  4C rr rr             JMP     Tee5e
000ECEr 1  C9 28                CMP     #$28
000ED0r 1  B0 9B        Leecb:  BCS     range_err
000ED2r 1  A8                   TAY
000ED3r 1  A5 C8                LDA     text_index
000ED5r 1  60                   RTS
000ED6r 1  EA                   NOP
000ED7r 1  EA                   NOP
000ED8r 1               
000ED8r 1               print_err_msg1:
000ED8r 1  98                   TYA
000ED9r 1  AA                   TAX
000EDAr 1  A0 6E                LDY     #$6E
000EDCr 1  20 rr rr             JSR     Se3c4
000EDFr 1  8A                   TXA
000EE0r 1  A8                   TAY
000EE1r 1  20 rr rr             JSR     Se3c4
000EE4r 1  A0 72                LDY     #$72
000EE6r 1  4C rr rr             JMP     Se3c4
000EE9r 1               
000EE9r 1  20 rr rr     Seee4:  JSR     get16bit
000EECr 1  06 CE        Leee7:  ASL     acc
000EEEr 1  26 CF                ROL     acc+1
000EF0r 1  30 FA                BMI     Leee7
000EF2r 1  B0 DC                BCS     Leecb
000EF4r 1  D0 04                BNE     Leef5
000EF6r 1  C5 CE                CMP     acc
000EF8r 1  B0 D6                BCS     Leecb
000EFAr 1  60           Leef5:  RTS
000EFBr 1               
000EFBr 1               ; token $2E - "PEEK" fn (uses $3F left paren)
000EFBr 1  20 rr rr     peek_fn:        JSR     get16bit
000EFEr 1  B1 CE                LDA     (acc),Y
000F00r 1  94 9F                STY     syn_stk_l+31,X
000F02r 1  4C rr rr             JMP     push_ya_noun_stk
000F05r 1               
000F05r 1               ; token $65 - "," for POKE statement
000F05r 1  20 rr rr     poke_stmt:      JSR     getbyte
000F08r 1  A5 CE                LDA     acc
000F0Ar 1  48                   PHA
000F0Br 1  20 rr rr             JSR     get16bit
000F0Er 1  68                   PLA
000F0Fr 1  91 CE                STA     (acc),Y
000F11r 1               
000F11r 1  60           Tef0c:  RTS
000F12r 1               
000F12r 1  FF FF FF             .byte   $FF,$FF,$FF
000F15r 1               
000F15r 1               ; token $15 - "/" for numeric division
000F15r 1  20 rr rr     divide: JSR     See6c
000F18r 1  A5 CE                LDA     acc
000F1Ar 1  85 E6                STA     p3
000F1Cr 1  A5 CF                LDA     acc+1
000F1Er 1  85 E7                STA     p3+1
000F20r 1  4C rr rr             JMP     Le244
000F23r 1               
000F23r 1               ; token $44 - "," next var in DIM statement is numeric
000F23r 1               ; token $4F - "DIM", next var is numeric
000F23r 1  20 rr rr     dim_num:        JSR     Seee4
000F26r 1  4C rr rr             JMP     Le134
000F29r 1               
000F29r 1               ; token $2D - "(" for numeric array subscript
000F29r 1  20 rr rr     num_array_subs: JSR     Seee4
000F2Cr 1  B4 78                LDY     noun_stk_h_str,X
000F2Er 1  B5 50                LDA     noun_stk_l,X
000F30r 1  69 FE                ADC     #$FE
000F32r 1  B0 01                BCS     Lef30
000F34r 1  88                   DEY
000F35r 1  85 DA        Lef30:  STA     aux
000F37r 1  84 DB                STY     aux+1
000F39r 1  18                   CLC
000F3Ar 1  65 CE                ADC     acc
000F3Cr 1  95 50                STA     noun_stk_l,X
000F3Er 1  98                   TYA
000F3Fr 1  65 CF                ADC     acc+1
000F41r 1  95 78                STA     noun_stk_h_str,X
000F43r 1  A0 00                LDY     #$00
000F45r 1  B5 50                LDA     noun_stk_l,X
000F47r 1  D1 DA                CMP     (aux),Y
000F49r 1  C8                   INY
000F4Ar 1  B5 78                LDA     noun_stk_h_str,X
000F4Cr 1  F1 DA                SBC     (aux),Y
000F4Er 1  B0 80                BCS     Leecb
000F50r 1  4C rr rr             JMP     left_paren
000F53r 1               
000F53r 1               ; token $2F - "RND" fn (uses $3F left paren)
000F53r 1  20 rr rr     rnd_fn: JSR     get16bit
000F56r 1  A5 4E                LDA     rnd
000F58r 1  20 rr rr             JSR     push_ya_noun_stk
000F5Br 1  A5 4F                LDA     rnd+1
000F5Dr 1  D0 04                BNE     Lef5e
000F5Fr 1  C5 4E                CMP     rnd
000F61r 1  69 00                ADC     #$00
000F63r 1  29 7F        Lef5e:  AND     #$7F
000F65r 1  85 4F                STA     rnd+1
000F67r 1  95 A0                STA     noun_stk_h_int,X
000F69r 1  A0 11                LDY     #$11
000F6Br 1  A5 4F        Lef66:  LDA     rnd+1
000F6Dr 1  0A                   ASL
000F6Er 1  18                   CLC
000F6Fr 1  69 40                ADC     #$40
000F71r 1  0A                   ASL
000F72r 1  26 4E                ROL     rnd
000F74r 1  26 4F                ROL     rnd+1
000F76r 1  88                   DEY
000F77r 1  D0 F2                BNE     Lef66
000F79r 1  A5 CE                LDA     acc
000F7Br 1  20 rr rr             JSR     push_ya_noun_stk
000F7Er 1  A5 CF                LDA     acc+1
000F80r 1  95 A0                STA     noun_stk_h_int,X
000F82r 1  4C rr rr             JMP     mod_op
000F85r 1               
000F85r 1  20 rr rr     Tef80:  JSR     get16bit
000F88r 1  A4 CE                LDY     acc
000F8Ar 1  C4 4C                CPY     himem
000F8Cr 1  A5 CF                LDA     acc+1
000F8Er 1  E5 4D                SBC     himem+1
000F90r 1  90 1F                BCC     Lefab
000F92r 1  84 48                STY     var
000F94r 1  A5 CF                LDA     acc+1
000F96r 1  85 49                STA     var+1
000F98r 1  4C rr rr     Lef93:  JMP     l1237
000F9Br 1               
000F9Br 1  20 rr rr     Tef96:  JSR     get16bit
000F9Er 1  A4 CE                LDY     acc
000FA0r 1  C4 CA                CPY     pp
000FA2r 1  A5 CF                LDA     acc+1
000FA4r 1  E5 CB                SBC     pp+1
000FA6r 1  B0 09                BCS     Lefab
000FA8r 1  84 4A                STY     lomem
000FAAr 1  A5 CF                LDA     acc+1
000FACr 1  85 4B                STA     lomem+1
000FAEr 1  4C rr rr             JMP     clr
000FB1r 1  4C rr rr     Lefab:  JMP     Leecb
000FB4r 1  EA                   NOP
000FB5r 1  EA                   NOP
000FB6r 1  EA                   NOP
000FB7r 1  EA                   NOP
000FB8r 1  20 rr rr     Lefb3:  JSR     Sefc9
000FBBr 1               
000FBBr 1               ; token $26 - "," for string input
000FBBr 1               ; token $52 - "INPUT" statement for string
000FBBr 1  20 rr rr     string_input:   JSR     input_str
000FBEr 1  4C rr rr             JMP     Lefbf
000FC1r 1               
000FC1r 1               ; token $53 - "INPUT" with literal string prompt
000FC1r 1  20 rr rr     input_prompt:   JSR     print_str
000FC4r 1  A9 FF        Lefbf:  LDA     #$FF
000FC6r 1  85 C8                STA     text_index
000FC8r 1  A9 74                LDA     #$74
000FCAr 1  8D 00 02             STA     buffer
000FCDr 1  60                   RTS
000FCEr 1               
000FCEr 1  20 rr rr     Sefc9:  JSR     not_op
000FD1r 1  E8                   INX
000FD2r 1               
000FD2r 1  20 rr rr     Sefcd:  JSR     not_op
000FD5r 1  B5 50                LDA     noun_stk_l,X
000FD7r 1  60                   RTS
000FD8r 1               
000FD8r 1               ; memory initialization for 4K RAM
000FD8r 1  A9 00        mem_init_4k:    LDA     #$00
000FDAr 1  85 4A                STA     lomem
000FDCr 1  85 4C                STA     himem
000FDEr 1  A9 08                LDA     #$08
000FE0r 1  85 4B                STA     lomem+1         ; LOMEM defaults to $0800
000FE2r 1  A9 10                LDA     #$10
000FE4r 1  85 4D                STA     himem+1         ; HIMEM defaults to $1000
000FE6r 1  4C rr rr             JMP     new_cmd
000FE9r 1               
000FE9r 1  D5 78        Sefe4:  CMP     noun_stk_h_str,X
000FEBr 1  D0 01                BNE     Lefe9
000FEDr 1  18                   CLC
000FEEr 1  4C rr rr     Lefe9:  JMP     Le102
000FF1r 1               
000FF1r 1  20 rr rr     Tefec:  JSR     clr
000FF4r 1  4C rr rr             JMP     run_warm
000FF7r 1               
000FF7r 1  20 rr rr     Teff2:  JSR     clr
000FFAr 1  4C rr rr             JMP     goto_stmt
000FFDr 1               
000FFDr 1  E0 80        Seff8:  CPX     #$80
000FFFr 1  D0 01                BNE     Leffd
001001r 1  88                   DEY
001002r 1  4C rr rr     Leffd:  JMP     Se00c
001005r 1               
001005r 1               ACIAWrite:
001005r 1  48               PHA				; save accumulator
001006r 1               ACIAloop:
001006r 1  AD 01 A0     	LDA	ACIAstatus		; Read 6551 status
001009r 1  29 10        	AND	#$10			; Is tx buffer full?
00100Br 1  F0 F9        	BEQ	ACIAloop			; if not, loop back
00100Dr 1  68           	PLA				; Otherwise, restore accumulator
00100Er 1  29 7F            AND #$7F ;standard ascii
001010r 1  8D 00 A0     	STA	ACIAdata		; write byte to 6551
001013r 1  60               RTS
001013r 1               
