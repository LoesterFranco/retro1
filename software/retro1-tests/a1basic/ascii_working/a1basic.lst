ca65 V2.15 - Git a85ac88
Main file   : a1basic.s
Current file: a1basic.s

000000r 1               .setcpu "65C02"
000000r 1               .include "acia.s65"
000000r 2               IO_AREA = $A000
000000r 2               ACIAdata	= IO_AREA		; simulated ACIA r/w port
000000r 2               ACIAstatus  = IO_AREA+1
000000r 2               ACIAcommand = IO_AREA+2
000000r 2               ACIAcontrol = IO_AREA+3
000000r 2               
000000r 2               
000000r 2               ACIAWrite:
000000r 2  48               PHA				; save accumulator
000001r 2               ACIAloop:
000001r 2  AD 01 A0     	LDA	ACIAstatus		; Read 6551 status
000004r 2  29 10        	AND	#$10			; Is tx buffer full?
000006r 2  F0 F9        	BEQ	ACIAloop			; if not, loop back
000008r 2  68           	PLA				; Otherwise, restore accumulator
000009r 2  29 7F            AND #$7F ;standard ascii
00000Br 2  8D 00 A0     	STA	ACIAdata		; write byte to 6551
00000Er 2  60               RTS
00000Fr 2               
00000Fr 1               
00000Fr 1               .feature force_range
00000Fr 1               ; Apple 1 BASIC
00000Fr 1               ;
00000Fr 1               ; Modifications to build with CC65 by Jeff Tranter <tranter@pobox.com>
00000Fr 1               ;
00000Fr 1               ; Apple 1 BASIC was written by Steve Wozniak
00000Fr 1               ; Uses disassembly copyright 2003 Eric Smith <eric@brouhaha.com>
00000Fr 1               ; http://www.brouhaha.com/~eric/retrocomputing/apple/apple1/basic/
00000Fr 1               
00000Fr 1               Z1d     =       $1D
00000Fr 1               ch      =       $24     ; horizontal cursor location
00000Fr 1               var     =       $48
00000Fr 1               lomem   =       $4A     ; lower limit of memory used by BASIC (2 bytes)
00000Fr 1               himem   =       $4C     ; upper limit of memory used by BASIC (2 bytes)
00000Fr 1               rnd     =       $4E     ; random number (2 bytes)
00000Fr 1               
00000Fr 1               
00000Fr 1               
00000Fr 1               .segment "VECTORS"
000000r 1               
000000r 1  rr rr                  .word   nmi
000002r 1  rr rr                  .word   reset
000004r 1  rr rr                  .word   irq
000006r 1               
000006r 1                         .code
00000Fr 1               
00000Fr 1  4C rr rr     reset:		jmp START
000012r 1               
000012r 1  40           nmi:		rti
000013r 1               
000013r 1  40           irq:		rti
000014r 1               ; The noun stack and syntax stack appear to overlap, which is OK since
000014r 1               ; they apparently are not used simultaneously.
000014r 1               
000014r 1               ; The noun stack size appears to be 32 entries, based on LDX #$20
000014r 1               ; instruction at e67f.  However, there seems to be enough room for
000014r 1               ; another 8 entries.  The noun stack builds down from noun_stk_<part>+$1f
000014r 1               ; to noun_stk_<part>+$00, indexed by the X register.
000014r 1               
000014r 1               ; Noun stack usage appears to be:
000014r 1               ;   integer:
000014r 1               ;       (noun_stk_h_int,noun_stk_l) = value
000014r 1               ;       noun_stk_h_str = 0
000014r 1               ;   string:
000014r 1               ;       (noun_stk_h_str,noun_stk_l) = pointer to string
000014r 1               ;       noun_stk_h_int = any
000014r 1               ; Since noun_stk_h_str determines whether stack entry is integer or string,
000014r 1               ; strings can't start in zero page.
000014r 1               
000014r 1               
000014r 1               
000014r 1               noun_stk_l =    $50
000014r 1               syn_stk_h =     $58     ; through $77
000014r 1               noun_stk_h_str = $78
000014r 1               syn_stk_l  =    $80     ; through $9F
000014r 1               noun_stk_h_int = $A0
000014r 1               txtndxstk  =    $A8     ; through $C7
000014r 1               text_index =    $C8     ; index into text being tokenized (in buffer at $0200)
000014r 1               leadbl  =       $C9     ; leading blanks
000014r 1               pp      =       $CA     ; pointer to end of program (2 bytes)
000014r 1               pv      =       $CC     ; pointer to end of variable storage (2 bytes)
000014r 1               acc     =       $CE     ; (2 bytes)
000014r 1               srch    =       $D0
000014r 1               tokndxstk =     $D1
000014r 1               srch2   =       $D2
000014r 1               if_flag =       $D4
000014r 1               cr_flag =       $D5
000014r 1               current_verb =  $D6
000014r 1               precedence =    $D7
000014r 1               x_save  =       $D8
000014r 1               run_flag =      $D9
000014r 1               aux     =       $DA
000014r 1               pline   =       $DC     ; pointer to current program line (2 bytes)
000014r 1               pverb   =       $E0     ; pointer to current verb (2 bytes)
000014r 1               p1      =       $E2
000014r 1               p2      =       $E4
000014r 1               p3      =       $E6
000014r 1               token_index =   $F1    ; pointer used to write tokens into buffer  2 bytes)
000014r 1               pcon    =       $F2    ; temp used in decimal output (2 bytes)
000014r 1               auto_inc =      $F4
000014r 1               auto_ln =       $F6
000014r 1               auto_flag =     $F8
000014r 1               char    =       $F9
000014r 1               leadzr  =       $FA
000014r 1               for_nest_count = $FB    ; count of active (nested) FOR loops
000014r 1               gosub_nest_count = $FC  ; count of active (nested) subroutines calls (GOSUB)
000014r 1               synstkdx =      $FD
000014r 1               synpag  =       $FE
000014r 1               
000014r 1               ; GOSUB stack, max eight entries
000014r 1               ; note that the Apple II version has sixteen entries
000014r 1               gstk_pverbl     =       $0100    ; saved pverb
000014r 1               gstk_pverbh     =       $0108
000014r 1               gstk_plinel     =       $0110    ; saved pline
000014r 1               gstk_plineh     =       $0118
000014r 1               
000014r 1               ; FOR stack, max eight entries
000014r 1               ; note that the Apple II version has sixteen entries
000014r 1               fstk_varl       =       $0120   ; pointer to index variable
000014r 1               fstk_varh       =       $0128
000014r 1               fstk_stepl      =       $0130   ; step value
000014r 1               fstk_steph      =       $0138
000014r 1               fstk_plinel     =       $0140   ; saved pline
000014r 1               fstk_plineh     =       $0148
000014r 1               fstk_pverbl     =       $0150   ; saved pverb
000014r 1               fstk_pverbh     =       $0158
000014r 1               fstk_tol        =       $0160   ; "to" (limit) value
000014r 1               fstk_toh        =       $0168
000014r 1               buffer  =       $0200
000014r 1               ;KBD     =       $D010
000014r 1               ;KBDCR   =       $D011
000014r 1               DSP     =       $D012
000014r 1               
000014r 1                       ;.org    $8000;test2
000014r 1                       .export START
000014r 1               START:
000014r 1  A9 00                LDA	#$00            ;init acia
000016r 1  8D 01 A0     	    STA	ACIAstatus		; Soft reset
000019r 1  A9 0B        	    LDA	#$0B
00001Br 1  8D 02 A0     	    STA	ACIAcommand		; Parity disabled, IRQ disabled
00001Er 1  A9 1F        	    LDA	#$1F
000020r 1  8D 03 A0     	    STA	ACIAcontrol		; Set output for 8-N-1 19200
000023r 1               
000023r 1  4C rr rr             JMP     cold            ; BASIC cold start entry point
000026r 1               ; Get character for keyboard, return in A.
000026r 1               rdkey:
000026r 1  AD 01 A0     	   LDA	ACIAstatus		; Read 6551 status
000029r 1  29 08        	   AND	#$08			;
00002Br 1  F0 F9        	   BEQ	rdkey		; If rx buffer empty, no byte
00002Dr 1  09 80               ORA #$80 ;convert to ascii keyboard
00002Fr 1  AD 00 A0     	   LDA	ACIAdata		; Read byte from 6551
000032r 1                       ;LDA     KBDCR           ; Read control register
000032r 1                       ;BPL     rdkey           ; Loop if no key pressed
000032r 1                       ;LDA     KBD             ; Read key data
000032r 1  60                   RTS                     ; and return
000033r 1               
000033r 1  8A           Se00c:  TXA
000034r 1  29 20                AND     #$20
000036r 1  F0 23                BEQ     Le034
000038r 1               
000038r 1  A9 A0        Se011:  LDA     #$A0
00003Ar 1  85 E4                STA     p2
00003Cr 1  4C rr rr             JMP     cout
00003Fr 1               
00003Fr 1  A9 20        Se018:  LDA     #$20
000041r 1               
000041r 1  C5 24        Se01a:  CMP     ch
000043r 1  B0 0C                BCS     nextbyte
000045r 1  A9 8D                LDA     #$8D
000047r 1  A0 07                LDY     #$07
000049r 1  20 rr rr     Le022:  JSR     cout
00004Cr 1  A9 A0                LDA     #$A0
00004Er 1  88                   DEY
00004Fr 1  D0 F8                BNE     Le022
000051r 1               
000051r 1  A0 00        nextbyte:       LDY     #$00
000053r 1  B1 E2                LDA     (p1),Y
000055r 1  E6 E2                INC     p1
000057r 1  D0 02                BNE     Le034
000059r 1  E6 E3                INC     p1+1
00005Br 1  60           Le034:  RTS
00005Cr 1               
00005Cr 1               ; token $75 - "," in LIST command
00005Cr 1  20 rr rr     list_comman:    JSR     get16bit
00005Fr 1  20 rr rr             JSR     find_line2
000062r 1  A5 E2        Le03b:  LDA     p1
000064r 1  C5 E6                CMP     p3
000066r 1  A5 E3                LDA     p1+1
000068r 1  E5 E7                SBC     p3+1
00006Ar 1  B0 EF                BCS     Le034
00006Cr 1  20 rr rr             JSR     list_line
00006Fr 1  4C rr rr             JMP     Le03b
000072r 1               
000072r 1               ; token $76 - LIST command w/ no args
000072r 1  A5 CA        list_all:       LDA     pp
000074r 1  85 E2                STA     p1
000076r 1  A5 CB                LDA     pp+1
000078r 1  85 E3                STA     p1+1
00007Ar 1  A5 4C                LDA     himem
00007Cr 1  85 E6                STA     p3
00007Er 1  A5 4D                LDA     himem+1
000080r 1  85 E7                STA     p3+1
000082r 1  D0 DE                BNE     Le03b
000084r 1               
000084r 1               ; token $74 - LIST command w/ line number(s)
000084r 1  20 rr rr     list_cmd:       JSR     get16bit
000087r 1  20 rr rr             JSR     find_line
00008Ar 1  A5 E4                LDA     p2
00008Cr 1  85 E2                STA     p1
00008Er 1  A5 E5                LDA     p2+1
000090r 1  85 E3                STA     p1+1
000092r 1  B0 C7                BCS     Le034
000094r 1               
000094r 1               ; list one program line
000094r 1  86 D8        list_line:      STX     x_save
000096r 1  A9 A0                LDA     #$A0
000098r 1  85 FA                STA     leadzr
00009Ar 1  20 rr rr             JSR     nextbyte
00009Dr 1  98                   TYA
00009Er 1               
00009Er 1               ; list an integer (line number or literal)
00009Er 1  85 E4        list_int:       STA     p2
0000A0r 1  20 rr rr             JSR     nextbyte
0000A3r 1  AA                   TAX
0000A4r 1  20 rr rr             JSR     nextbyte
0000A7r 1  20 rr rr             JSR     prdec
0000AAr 1  20 rr rr     Le083:  JSR     Se018
0000ADr 1  84 FA                STY     leadzr
0000AFr 1  AA                   TAX
0000B0r 1  10 18                BPL     list_token
0000B2r 1  0A                   ASL
0000B3r 1  10 E9                BPL     list_int
0000B5r 1  A5 E4                LDA     p2
0000B7r 1  D0 03                BNE     Le095
0000B9r 1  20 rr rr             JSR     Se011
0000BCr 1  8A           Le095:  TXA
0000BDr 1  20 rr rr     Le096:  JSR     cout
0000C0r 1  A9 25        Le099:  LDA     #$25
0000C2r 1  20 rr rr             JSR     Se01a
0000C5r 1  AA                   TAX
0000C6r 1  30 F5                BMI     Le096
0000C8r 1  85 E4                STA     p2
0000CAr 1               
0000CAr 1               ; list a single token
0000CAr 1  C9 01        list_token:     CMP     #$01
0000CCr 1  D0 05                BNE     Le0ac
0000CEr 1  A6 D8                LDX     x_save
0000D0r 1  4C rr rr             JMP     crout
0000D3r 1  48           Le0ac:  PHA
0000D4r 1  84 CE                STY     acc
0000D6r 1  A2 ED                LDX     #$ED
0000D8r 1  86 CF                STX     acc+1
0000DAr 1  C9 51                CMP     #$51
0000DCr 1  90 04                BCC     Le0bb
0000DEr 1  C6 CF                DEC     acc+1
0000E0r 1  E9 50                SBC     #$50
0000E2r 1  48           Le0bb:  PHA
0000E3r 1  B1 CE                LDA     (acc),Y
0000E5r 1  AA           Le0be:  TAX
0000E6r 1  88                   DEY
0000E7r 1  B1 CE                LDA     (acc),Y
0000E9r 1  10 FA                BPL     Le0be
0000EBr 1  E0 C0                CPX     #$C0
0000EDr 1  B0 04                BCS     Le0cc
0000EFr 1  E0 00                CPX     #$00
0000F1r 1  30 F2                BMI     Le0be
0000F3r 1  AA           Le0cc:  TAX
0000F4r 1  68                   PLA
0000F5r 1  E9 01                SBC     #$01
0000F7r 1  D0 E9                BNE     Le0bb
0000F9r 1  24 E4                BIT     p2
0000FBr 1  30 03                BMI     Le0d9
0000FDr 1  20 rr rr             JSR     Seff8
000100r 1  B1 CE        Le0d9:  LDA     (acc),Y
000102r 1  10 10                BPL     Le0ed
000104r 1  AA                   TAX
000105r 1  29 3F                AND     #$3F
000107r 1  85 E4                STA     p2
000109r 1  18                   CLC
00010Ar 1  69 A0                ADC     #$A0
00010Cr 1  20 rr rr             JSR     cout
00010Fr 1  88                   DEY
000110r 1  E0 C0                CPX     #$C0
000112r 1  90 EC                BCC     Le0d9
000114r 1  20 rr rr     Le0ed:  JSR     Se00c
000117r 1  68                   PLA
000118r 1  C9 5D                CMP     #$5D
00011Ar 1  F0 A4                BEQ     Le099
00011Cr 1  C9 28                CMP     #$28
00011Er 1  D0 8A                BNE     Le083
000120r 1  F0 9E                BEQ     Le099
000122r 1               
000122r 1               ; token $2A - left paren for substring like A$(3,5)
000122r 1  20 rr rr     paren_substr:   JSR     Se118
000125r 1  95 50                STA     noun_stk_l,X
000127r 1  D5 78                CMP     noun_stk_h_str,X
000129r 1  90 11        Le102:  BCC     Le115
00012Br 1  A0 2B        string_err:     LDY     #$2B
00012Dr 1  4C rr rr     go_errmess_1:   JMP     print_err_msg
000130r 1               
000130r 1               ; token $2B - comma for substring like A$(3,5)
000130r 1  20 rr rr     comma_substr:   JSR     getbyte
000133r 1  D5 50                CMP     noun_stk_l,X
000135r 1  90 F4                BCC     string_err
000137r 1  20 rr rr             JSR     Sefe4
00013Ar 1  95 78                STA     noun_stk_h_str,X
00013Cr 1  4C rr rr     Le115:  JMP     left_paren
00013Fr 1               
00013Fr 1  20 rr rr     Se118:  JSR     getbyte
000142r 1  F0 E7                BEQ     string_err
000144r 1  38                   SEC
000145r 1  E9 01                SBC     #$01
000147r 1  60                   RTS
000148r 1               
000148r 1               ; token $42 - left paren for string array as dest
000148r 1               ; A$(1)="FOO"
000148r 1  20 rr rr     str_arr_dest:   JSR     Se118
00014Br 1  95 50                STA     noun_stk_l,X
00014Dr 1  18                   CLC
00014Er 1  F5 78                SBC     noun_stk_h_str,X
000150r 1  4C rr rr             JMP     Le102
000153r 1  A0 14        Le12c:  LDY     #$14
000155r 1  D0 D6                BNE     go_errmess_1
000157r 1               
000157r 1               ; token $43 - comma, next var in DIM statement is string
000157r 1               ; token $4E - "DIM", next var in DIM is string
000157r 1  20 rr rr     dim_str:        JSR     Se118
00015Ar 1  E8                   INX
00015Br 1  B5 50        Le134:  LDA     noun_stk_l,X
00015Dr 1  85 DA                STA     aux
00015Fr 1  65 CE                ADC     acc
000161r 1  48                   PHA
000162r 1  A8                   TAY
000163r 1  B5 78                LDA     noun_stk_h_str,X
000165r 1  85 DB                STA     aux+1
000167r 1  65 CF                ADC     acc+1
000169r 1  48                   PHA
00016Ar 1  C4 CA                CPY     pp
00016Cr 1  E5 CB                SBC     pp+1
00016Er 1  B0 E3                BCS     Le12c
000170r 1  A5 DA                LDA     aux
000172r 1  69 FE                ADC     #$FE
000174r 1  85 DA                STA     aux
000176r 1  A9 FF                LDA     #$FF
000178r 1  A8                   TAY
000179r 1  65 DB                ADC     aux+1
00017Br 1  85 DB                STA     aux+1
00017Dr 1  C8           Le156:  INY
00017Er 1  B1 DA                LDA     (aux),Y
000180r 1  D9 CC 00             CMP     pv,Y
000183r 1  D0 0F                BNE     Le16d
000185r 1  98                   TYA
000186r 1  F0 F5                BEQ     Le156
000188r 1  68           Le161:  PLA
000189r 1  91 DA                STA     (aux),Y
00018Br 1  99 CC 00             STA     pv,Y
00018Er 1  88                   DEY
00018Fr 1  10 F7                BPL     Le161
000191r 1  E8                   INX
000192r 1  60                   RTS
000193r 1  EA                   NOP
000194r 1  A0 80        Le16d:  LDY     #$80
000196r 1  D0 95        Le16f:  BNE     go_errmess_1
000198r 1               
000198r 1               ; token ???
000198r 1  A9 00        input_str:      LDA     #$00
00019Ar 1  20 rr rr             JSR     push_a_noun_stk
00019Dr 1  A0 02                LDY     #$02
00019Fr 1  94 78                STY     noun_stk_h_str,X
0001A1r 1  20 rr rr             JSR     push_a_noun_stk
0001A4r 1  A9 BF                LDA     #$BF                    ; '?'
0001A6r 1  20 rr rr             JSR     cout
0001A9r 1  A0 00                LDY     #$00
0001ABr 1  20 rr rr             JSR     read_line
0001AEr 1  94 78                STY     noun_stk_h_str,X
0001B0r 1  EA                   NOP
0001B1r 1  EA                   NOP
0001B2r 1  EA                   NOP
0001B3r 1               
0001B3r 1               ; token $70 - string literal
0001B3r 1  B5 51        string_lit:     LDA     noun_stk_l+1,X
0001B5r 1  85 CE                STA     acc
0001B7r 1  B5 79                LDA     noun_stk_h_str+1,X
0001B9r 1  85 CF                STA     acc+1
0001BBr 1  E8                   INX
0001BCr 1  E8                   INX
0001BDr 1  20 rr rr             JSR     Se1bc
0001C0r 1  B5 4E        Le199:  LDA     rnd,X
0001C2r 1  D5 76                CMP     syn_stk_h+30,X
0001C4r 1  B0 15                BCS     Le1b4
0001C6r 1  F6 4E                INC     rnd,X
0001C8r 1  A8                   TAY
0001C9r 1  B1 CE                LDA     (acc),Y
0001CBr 1  B4 50                LDY     noun_stk_l,X
0001CDr 1  C4 E4                CPY     p2
0001CFr 1  90 04                BCC     Le1ae
0001D1r 1  A0 83                LDY     #$83
0001D3r 1  D0 C1                BNE     Le16f
0001D5r 1  91 DA        Le1ae:  STA     (aux),Y
0001D7r 1  F6 50                INC     noun_stk_l,X
0001D9r 1  90 E5                BCC     Le199
0001DBr 1  B4 50        Le1b4:  LDY     noun_stk_l,X
0001DDr 1  8A                   TXA
0001DEr 1  91 DA                STA     (aux),Y
0001E0r 1  E8                   INX
0001E1r 1  E8                   INX
0001E2r 1  60                   RTS
0001E3r 1               
0001E3r 1  B5 51        Se1bc:  LDA     noun_stk_l+1,X
0001E5r 1  85 DA                STA     aux
0001E7r 1  38                   SEC
0001E8r 1  E9 02                SBC     #$02
0001EAr 1  85 E4                STA     p2
0001ECr 1  B5 79                LDA     noun_stk_h_str+1,X
0001EEr 1  85 DB                STA     aux+1
0001F0r 1  E9 00                SBC     #$00
0001F2r 1  85 E5                STA     p2+1
0001F4r 1  A0 00                LDY     #$00
0001F6r 1  B1 E4                LDA     (p2),Y
0001F8r 1  18                   CLC
0001F9r 1  E5 DA                SBC     aux
0001FBr 1  85 E4                STA     p2
0001FDr 1  60                   RTS
0001FEr 1               
0001FEr 1               ; token $39 - "=" for string equality operator
0001FEr 1  B5 53        string_eq:      LDA     noun_stk_l+3,X
000200r 1  85 CE                STA     acc
000202r 1  B5 7B                LDA     noun_stk_h_str+3,X
000204r 1  85 CF                STA     acc+1
000206r 1  B5 51                LDA     noun_stk_l+1,X
000208r 1  85 DA                STA     aux
00020Ar 1  B5 79                LDA     noun_stk_h_str+1,X
00020Cr 1  85 DB                STA     aux+1
00020Er 1  E8                   INX
00020Fr 1  E8                   INX
000210r 1  E8                   INX
000211r 1  A0 00                LDY     #$00
000213r 1  94 78                STY     noun_stk_h_str,X
000215r 1  94 A0                STY     noun_stk_h_int,X
000217r 1  C8                   INY
000218r 1  94 50                STY     noun_stk_l,X
00021Ar 1  B5 4D        Le1f3:  LDA     himem+1,X
00021Cr 1  D5 75                CMP     syn_stk_h+29,X
00021Er 1  08                   PHP
00021Fr 1  48                   PHA
000220r 1  B5 4F                LDA     rnd+1,X
000222r 1  D5 77                CMP     syn_stk_h+31,X
000224r 1  90 07                BCC     Le206
000226r 1  68                   PLA
000227r 1  28                   PLP
000228r 1  B0 02                BCS     Le205
00022Ar 1  56 50        Le203:  LSR     noun_stk_l,X
00022Cr 1  60           Le205:  RTS
00022Dr 1  A8           Le206:  TAY
00022Er 1  B1 CE                LDA     (acc),Y
000230r 1  85 E4                STA     p2
000232r 1  68                   PLA
000233r 1  A8                   TAY
000234r 1  28                   PLP
000235r 1  B0 F3                BCS     Le203
000237r 1  B1 DA                LDA     (aux),Y
000239r 1  C5 E4                CMP     p2
00023Br 1  D0 ED                BNE     Le203
00023Dr 1  F6 4F                INC     rnd+1,X
00023Fr 1  F6 4D                INC     himem+1,X
000241r 1  B0 D7                BCS     Le1f3
000243r 1               
000243r 1               ; token $3A - "#" for string inequality operator
000243r 1  20 rr rr     string_neq:     JSR     string_eq
000246r 1  4C rr rr             JMP     not_op
000249r 1               
000249r 1               ; token $14 - "*" for numeric multiplication
000249r 1  20 rr rr     mult_op:        JSR     Se254
00024Cr 1  06 CE        Le225:  ASL     acc
00024Er 1  26 CF                ROL     acc+1
000250r 1  90 0D                BCC     Le238
000252r 1  18                   CLC
000253r 1  A5 E6                LDA     p3
000255r 1  65 DA                ADC     aux
000257r 1  85 E6                STA     p3
000259r 1  A5 E7                LDA     p3+1
00025Br 1  65 DB                ADC     aux+1
00025Dr 1  85 E7                STA     p3+1
00025Fr 1  88           Le238:  DEY
000260r 1  F0 09                BEQ     Le244
000262r 1  06 E6                ASL     p3
000264r 1  26 E7                ROL     p3+1
000266r 1  10 E4                BPL     Le225
000268r 1  4C rr rr             JMP     Le77e
00026Br 1  A5 E6        Le244:  LDA     p3
00026Dr 1  20 rr rr             JSR     push_ya_noun_stk
000270r 1  A5 E7                LDA     p3+1
000272r 1  95 A0                STA     noun_stk_h_int,X
000274r 1  06 E5                ASL     p2+1
000276r 1  90 28                BCC     Le279
000278r 1  4C rr rr             JMP     negate
00027Br 1               
00027Br 1  A9 55        Se254:  LDA     #$55
00027Dr 1  85 E5                STA     p2+1
00027Fr 1  20 rr rr             JSR     Se25b
000282r 1               
000282r 1  A5 CE        Se25b:  LDA     acc
000284r 1  85 DA                STA     aux
000286r 1  A5 CF                LDA     acc+1
000288r 1  85 DB                STA     aux+1
00028Ar 1  20 rr rr             JSR     get16bit
00028Dr 1  84 E6                STY     p3
00028Fr 1  84 E7                STY     p3+1
000291r 1  A5 CF                LDA     acc+1
000293r 1  10 09                BPL     Le277
000295r 1  CA                   DEX
000296r 1  06 E5                ASL     p2+1
000298r 1  20 rr rr             JSR     negate
00029Br 1  20 rr rr             JSR     get16bit
00029Er 1  A0 10        Le277:  LDY     #$10
0002A0r 1  60           Le279:  RTS
0002A1r 1               
0002A1r 1               ; token $1f - "MOD"
0002A1r 1  20 rr rr     mod_op: JSR     See6c
0002A4r 1  F0 C5                BEQ     Le244
0002A6r 1  FF                   .byte   $FF
0002A7r 1  C9 84        Le280:  CMP     #$84
0002A9r 1  D0 02                BNE     Le286
0002ABr 1  46 F8                LSR     auto_flag
0002ADr 1  C9 DF        Le286:  CMP     #$DF
0002AFr 1  F0 11                BEQ     Le29b
0002B1r 1  C9 9B                CMP     #$9B
0002B3r 1  F0 06                BEQ     Le294
0002B5r 1  99 00 02             STA     buffer,Y
0002B8r 1  C8                   INY
0002B9r 1  10 0A                BPL     read_line
0002BBr 1  A0 8B        Le294:  LDY     #$8B
0002BDr 1  20 rr rr             JSR     Se3c4
0002C0r 1               
0002C0r 1  A0 01        Se299:  LDY     #$01
0002C2r 1  88           Le29b:  DEY
0002C3r 1  30 F6                BMI     Le294
0002C5r 1               
0002C5r 1               ; read a line from keyboard (using rdkey) into buffer
0002C5r 1  20 rr rr     read_line:      JSR     rdkey
0002C8r 1  EA                   NOP
0002C9r 1  EA                   NOP
0002CAr 1  20 rr rr             JSR     cout
0002CDr 1  C9 8D                CMP     #$8D
0002CFr 1  D0 D6                BNE     Le280
0002D1r 1  A9 DF                LDA     #$DF
0002D3r 1  99 00 02             STA     buffer,Y
0002D6r 1  60                   RTS
0002D7r 1  20 rr rr     cold:   JSR     mem_init_4k
0002DAr 1                       .export warm
0002DAr 1  20 rr rr     warm:   JSR     crout           ; BASIC warm start entry point
0002DDr 1  46 D9        Le2b6:  LSR     run_flag
0002DFr 1  A9 BE                LDA     #'>'+$80        ; Prompt character (high bit set)
0002E1r 1  20 rr rr             JSR     cout
0002E4r 1  A0 00                LDY     #$00
0002E6r 1  84 FA                STY     leadzr
0002E8r 1  24 F8                BIT     auto_flag
0002EAr 1  10 0C                BPL     Le2d1
0002ECr 1  A6 F6                LDX     auto_ln
0002EEr 1  A5 F7                LDA     auto_ln+1
0002F0r 1  20 rr rr             JSR     prdec
0002F3r 1  A9 A0                LDA     #$A0
0002F5r 1  20 rr rr             JSR     cout
0002F8r 1  A2 FF        Le2d1:  LDX     #$FF
0002FAr 1  9A                   TXS
0002FBr 1                       ;JSR     read_line ;stache commented out
0002FBr 1  84 F1                STY     token_index
0002FDr 1  8A                   TXA
0002FEr 1  85 C8                STA     text_index
000300r 1  A2 20                LDX     #$20
000302r 1  20 rr rr             JSR     Se491
000305r 1  A5 C8                LDA     text_index
000307r 1  69 00                ADC     #$00
000309r 1  85 E0                STA     pverb
00030Br 1  A9 00                LDA     #$00
00030Dr 1  AA                   TAX
00030Er 1  69 02                ADC     #$02
000310r 1  85 E1                STA     pverb+1
000312r 1  A1 E0                LDA     (pverb,X)
000314r 1  29 F0                AND     #$F0
000316r 1  C9 B0                CMP     #$B0
000318r 1  F0 03                BEQ     Le2f9
00031Ar 1  4C rr rr             JMP     Le883
00031Dr 1  A0 02        Le2f9:  LDY     #$02
00031Fr 1  B1 E0        Le2fb:  LDA     (pverb),Y
000321r 1  99 CD 00             STA     pv+1,Y
000324r 1  88                   DEY
000325r 1  D0 F8                BNE     Le2fb
000327r 1  20 rr rr             JSR     Se38a
00032Ar 1  A5 F1                LDA     token_index
00032Cr 1  E5 C8                SBC     text_index
00032Er 1  C9 04                CMP     #$04
000330r 1  F0 AB                BEQ     Le2b6
000332r 1  91 E0                STA     (pverb),Y
000334r 1  A5 CA                LDA     pp
000336r 1  F1 E0                SBC     (pverb),Y
000338r 1  85 E4                STA     p2
00033Ar 1  A5 CB                LDA     pp+1
00033Cr 1  E9 00                SBC     #$00
00033Er 1  85 E5                STA     p2+1
000340r 1  A5 E4                LDA     p2
000342r 1  C5 CC                CMP     pv
000344r 1  A5 E5                LDA     p2+1
000346r 1  E5 CD                SBC     pv+1
000348r 1  90 45                BCC     Le36b
00034Ar 1  A5 CA        Le326:  LDA     pp
00034Cr 1  F1 E0                SBC     (pverb),Y
00034Er 1  85 E6                STA     p3
000350r 1  A5 CB                LDA     pp+1
000352r 1  E9 00                SBC     #$00
000354r 1  85 E7                STA     p3+1
000356r 1  B1 CA                LDA     (pp),Y
000358r 1  91 E6                STA     (p3),Y
00035Ar 1  E6 CA                INC     pp
00035Cr 1  D0 02                BNE     Le33c
00035Er 1  E6 CB                INC     pp+1
000360r 1  A5 E2        Le33c:  LDA     p1
000362r 1  C5 CA                CMP     pp
000364r 1  A5 E3                LDA     p1+1
000366r 1  E5 CB                SBC     pp+1
000368r 1  B0 E0                BCS     Le326
00036Ar 1  B5 E4        Le346:  LDA     p2,X
00036Cr 1  95 CA                STA     pp,X
00036Er 1  CA                   DEX
00036Fr 1  10 F9                BPL     Le346
000371r 1  B1 E0                LDA     (pverb),Y
000373r 1  A8                   TAY
000374r 1  88           Le350:  DEY
000375r 1  B1 E0                LDA     (pverb),Y
000377r 1  91 E6                STA     (p3),Y
000379r 1  98                   TYA
00037Ar 1  D0 F8                BNE     Le350
00037Cr 1  24 F8                BIT     auto_flag
00037Er 1  10 09                BPL     Le365
000380r 1  B5 F7        Le35c:  LDA     auto_ln+1,X
000382r 1  75 F5                ADC     auto_inc+1,X
000384r 1  95 F7                STA     auto_ln+1,X
000386r 1  E8                   INX
000387r 1  F0 F7                BEQ     Le35c
000389r 1  10 79        Le365:  BPL     Le3e5
00038Br 1  00 00 00 00          .byte   $00,$00,$00,$00
00038Fr 1  A0 14        Le36b:  LDY     #$14
000391r 1  D0 6C                BNE     print_err_msg
000393r 1               
000393r 1               ; token $0a - "," in DEL command
000393r 1  20 rr rr     del_comma:      JSR     get16bit
000396r 1  A5 E2                LDA     p1
000398r 1  85 E6                STA     p3
00039Ar 1  A5 E3                LDA     p1+1
00039Cr 1  85 E7                STA     p3+1
00039Er 1  20 rr rr             JSR     find_line1
0003A1r 1  A5 E2                LDA     p1
0003A3r 1  85 E4                STA     p2
0003A5r 1  A5 E3                LDA     p1+1
0003A7r 1  85 E5                STA     p2+1
0003A9r 1  D0 0E                BNE     Le395
0003ABr 1               
0003ABr 1               ; token $09 - "DEL"
0003ABr 1  20 rr rr     del_cmd:        JSR     get16bit
0003AEr 1               
0003AEr 1  20 rr rr     Se38a:  JSR     find_line
0003B1r 1  A5 E6                LDA     p3
0003B3r 1  85 E2                STA     p1
0003B5r 1  A5 E7                LDA     p3+1
0003B7r 1  85 E3                STA     p1+1
0003B9r 1  A0 00        Le395:  LDY     #$00
0003BBr 1  A5 CA        Le397:  LDA     pp
0003BDr 1  C5 E4                CMP     p2
0003BFr 1  A5 CB                LDA     pp+1
0003C1r 1  E5 E5                SBC     p2+1
0003C3r 1  B0 16                BCS     Le3b7
0003C5r 1  A5 E4                LDA     p2
0003C7r 1  D0 02                BNE     Le3a7
0003C9r 1  C6 E5                DEC     p2+1
0003CBr 1  C6 E4        Le3a7:  DEC     p2
0003CDr 1  A5 E6                LDA     p3
0003CFr 1  D0 02                BNE     Le3af
0003D1r 1  C6 E7                DEC     p3+1
0003D3r 1  C6 E6        Le3af:  DEC     p3
0003D5r 1  B1 E4                LDA     (p2),Y
0003D7r 1  91 E6                STA     (p3),Y
0003D9r 1  90 E0                BCC     Le397
0003DBr 1  A5 E6        Le3b7:  LDA     p3
0003DDr 1  85 CA                STA     pp
0003DFr 1  A5 E7                LDA     p3+1
0003E1r 1  85 CB                STA     pp+1
0003E3r 1  60                   RTS
0003E4r 1  20 rr rr     Le3c0:  JSR     cout
0003E7r 1  C8                   INY
0003E8r 1               
0003E8r 1  B9 rr rr     Se3c4:  LDA     error_msg_tbl,Y
0003EBr 1  30 F7                BMI     Le3c0
0003EDr 1               
0003EDr 1  C9 8D        cout:   CMP     #$8D
0003EFr 1  D0 06                BNE     Le3d3
0003F1r 1               
0003F1r 1  A9 00        crout:  LDA     #$00            ; character output
0003F3r 1  85 24                STA     ch
0003F5r 1  A9 8D                LDA     #$8D
0003F7r 1  E6 24        Le3d3:  INC     ch
0003F9r 1               
0003F9r 1               
0003F9r 1               
0003F9r 1               ; Send character to display. Char is in A.
0003F9r 1               Le3d5:
0003F9r 1  20 rr rr     	    JSR ACIAWrite
0003FCr 1               
0003FCr 1  60                   RTS                  ; and return
0003FDr 1               
0003FDr 1  A0 06        too_long_err:   LDY     #$06
0003FFr 1               
0003FFr 1  20 rr rr     print_err_msg:  JSR     print_err_msg1  ; print error message specified in Y
000402r 1  24 D9                BIT     run_flag
000404r 1  30 03        Le3e5:  BMI     Le3ea
000406r 1  4C rr rr             JMP     Le2b6
000409r 1  4C rr rr     Le3ea:  JMP     Leb9a
00040Cr 1  2A           Le3ed:  ROL
00040Dr 1  69 A0                ADC     #$A0
00040Fr 1  DD 00 02             CMP     buffer,X
000412r 1  D0 53                BNE     Le448
000414r 1  B1 FE                LDA     (synpag),Y
000416r 1  0A                   ASL
000417r 1  30 06                BMI     Le400
000419r 1  88                   DEY
00041Ar 1  B1 FE                LDA     (synpag),Y
00041Cr 1  30 29                BMI     Le428
00041Er 1  C8                   INY
00041Fr 1  86 C8        Le400:  STX     text_index
000421r 1  98                   TYA
000422r 1  48                   PHA
000423r 1  A2 00                LDX     #$00
000425r 1  A1 FE                LDA     (synpag,X)
000427r 1  AA                   TAX
000428r 1  4A           Le409:  LSR
000429r 1  49 48                EOR     #$48
00042Br 1  11 FE                ORA     (synpag),Y
00042Dr 1  C9 C0                CMP     #$C0
00042Fr 1  90 01                BCC     Le413
000431r 1  E8                   INX
000432r 1  C8           Le413:  INY
000433r 1  D0 F3                BNE     Le409
000435r 1  68                   PLA
000436r 1  A8                   TAY
000437r 1  8A                   TXA
000438r 1  4C rr rr             JMP     Le4c0
00043Br 1               
00043Br 1               ; write a token to the buffer
00043Br 1               ; buffer [++tokndx] = A
00043Br 1  E6 F1        put_token:      INC     token_index
00043Dr 1  A6 F1                LDX     token_index
00043Fr 1  F0 BC                BEQ     too_long_err
000441r 1  9D 00 02             STA     buffer,X
000444r 1  60           Le425:  RTS
000445r 1  A6 C8        Le426:  LDX     text_index
000447r 1  A9 A0        Le428:  LDA     #$A0
000449r 1  E8           Le42a:  INX
00044Ar 1  DD 00 02             CMP     buffer,X
00044Dr 1  B0 FA                BCS     Le42a
00044Fr 1  B1 FE                LDA     (synpag),Y
000451r 1  29 3F                AND     #$3F
000453r 1  4A                   LSR
000454r 1  D0 B6                BNE     Le3ed
000456r 1  BD 00 02             LDA     buffer,X
000459r 1  B0 06                BCS     Le442
00045Br 1  69 3F                ADC     #$3F
00045Dr 1  C9 1A                CMP     #$1A
00045Fr 1  90 6F                BCC     Le4b1
000461r 1  69 4F        Le442:  ADC     #$4F
000463r 1  C9 0A                CMP     #$0A
000465r 1  90 69                BCC     Le4b1
000467r 1  A6 FD        Le448:  LDX     synstkdx
000469r 1  C8           Le44a:  INY
00046Ar 1  B1 FE                LDA     (synpag),Y
00046Cr 1  29 E0                AND     #$E0
00046Er 1  C9 20                CMP     #$20
000470r 1  F0 7A                BEQ     Le4cd
000472r 1  B5 A8                LDA     txtndxstk,X
000474r 1  85 C8                STA     text_index
000476r 1  B5 D1                LDA     tokndxstk,X
000478r 1  85 F1                STA     token_index
00047Ar 1  88           Le45b:  DEY
00047Br 1  B1 FE                LDA     (synpag),Y
00047Dr 1  0A                   ASL
00047Er 1  10 FA                BPL     Le45b
000480r 1  88                   DEY
000481r 1  B0 38                BCS     Le49c
000483r 1  0A                   ASL
000484r 1  30 35                BMI     Le49c
000486r 1  B4 58                LDY     syn_stk_h,X
000488r 1  84 FF                STY     synpag+1
00048Ar 1  B4 80                LDY     syn_stk_l,X
00048Cr 1  E8                   INX
00048Dr 1  10 DA                BPL     Le44a
00048Fr 1  F0 B3        Le470:  BEQ     Le425
000491r 1  C9 7E                CMP     #$7E
000493r 1  B0 22                BCS     Le498
000495r 1  CA                   DEX
000496r 1  10 04                BPL     Le47d
000498r 1  A0 06                LDY     #$06
00049Ar 1  10 29                BPL     go_errmess_2
00049Cr 1  94 80        Le47d:  STY     syn_stk_l,X
00049Er 1  A4 FF                LDY     synpag+1
0004A0r 1  94 58                STY     syn_stk_h,X
0004A2r 1  A4 C8                LDY     text_index
0004A4r 1  94 A8                STY     txtndxstk,X
0004A6r 1  A4 F1                LDY     token_index
0004A8r 1  94 D1                STY     tokndxstk,X
0004AAr 1  29 1F                AND     #$1F
0004ACr 1  A8                   TAY
0004ADr 1  B9 rr rr             LDA     syntabl_index,Y
0004B0r 1               
0004B0r 1  0A           Se491:  ASL
0004B1r 1  A8                   TAY
0004B2r 1  A9 76                LDA     #$76
0004B4r 1  2A                   ROL
0004B5r 1  85 FF                STA     synpag+1
0004B7r 1  D0 01        Le498:  BNE     Le49b
0004B9r 1  C8                   INY
0004BAr 1  C8           Le49b:  INY
0004BBr 1  86 FD        Le49c:  STX     synstkdx
0004BDr 1  B1 FE                LDA     (synpag),Y
0004BFr 1  30 84                BMI     Le426
0004C1r 1  D0 05                BNE     Le4a9
0004C3r 1  A0 0E                LDY     #$0E
0004C5r 1  4C rr rr     go_errmess_2:   JMP     print_err_msg
0004C8r 1  C9 03        Le4a9:  CMP     #$03
0004CAr 1  B0 C3                BCS     Le470
0004CCr 1  4A                   LSR
0004CDr 1  A6 C8                LDX     text_index
0004CFr 1  E8                   INX
0004D0r 1  BD 00 02     Le4b1:  LDA     buffer,X
0004D3r 1  90 04                BCC     Le4ba
0004D5r 1  C9 A2                CMP     #$A2
0004D7r 1  F0 0A                BEQ     Le4c4
0004D9r 1  C9 DF        Le4ba:  CMP     #$DF
0004DBr 1  F0 06                BEQ     Le4c4
0004DDr 1  86 C8                STX     text_index
0004DFr 1  20 rr rr     Le4c0:  JSR     put_token
0004E2r 1  C8                   INY
0004E3r 1  88           Le4c4:  DEY
0004E4r 1  A6 FD                LDX     synstkdx
0004E6r 1  B1 FE        Le4c7:  LDA     (synpag),Y
0004E8r 1  88                   DEY
0004E9r 1  0A                   ASL
0004EAr 1  10 CF                BPL     Le49c
0004ECr 1  B4 58        Le4cd:  LDY     syn_stk_h,X
0004EEr 1  84 FF                STY     synpag+1
0004F0r 1  B4 80                LDY     syn_stk_l,X
0004F2r 1  E8                   INX
0004F3r 1  B1 FE                LDA     (synpag),Y
0004F5r 1  29 9F                AND     #$9F
0004F7r 1  D0 ED                BNE     Le4c7
0004F9r 1  85 F2                STA     pcon
0004FBr 1  85 F3                STA     pcon+1
0004FDr 1  98                   TYA
0004FEr 1  48                   PHA
0004FFr 1  86 FD                STX     synstkdx
000501r 1  B4 D0                LDY     srch,X
000503r 1  84 C9                STY     leadbl
000505r 1  18                   CLC
000506r 1  A9 0A        Le4e7:  LDA     #$0A
000508r 1  85 F9                STA     char
00050Ar 1  A2 00                LDX     #$00
00050Cr 1  C8                   INY
00050Dr 1  B9 00 02             LDA     buffer,Y
000510r 1  29 0F                AND     #$0F
000512r 1  65 F2        Le4f3:  ADC     pcon
000514r 1  48                   PHA
000515r 1  8A                   TXA
000516r 1  65 F3                ADC     pcon+1
000518r 1  30 1C                BMI     Le517
00051Ar 1  AA                   TAX
00051Br 1  68                   PLA
00051Cr 1  C6 F9                DEC     char
00051Er 1  D0 F2                BNE     Le4f3
000520r 1  85 F2                STA     pcon
000522r 1  86 F3                STX     pcon+1
000524r 1  C4 F1                CPY     token_index
000526r 1  D0 DE                BNE     Le4e7
000528r 1  A4 C9                LDY     leadbl
00052Ar 1  C8                   INY
00052Br 1  84 F1                STY     token_index
00052Dr 1  20 rr rr             JSR     put_token
000530r 1  68                   PLA
000531r 1  A8                   TAY
000532r 1  A5 F3                LDA     pcon+1
000534r 1  B0 A9                BCS     Le4c0
000536r 1  A0 00        Le517:  LDY     #$00
000538r 1  10 8B                BPL     go_errmess_2
00053Ar 1               
00053Ar 1  85 F3        prdec:  STA     pcon+1  ; output A:X in decimal
00053Cr 1  86 F2                STX     pcon
00053Er 1  A2 04                LDX     #$04
000540r 1  86 C9                STX     leadbl
000542r 1  A9 B0        Le523:  LDA     #$B0
000544r 1  85 F9                STA     char
000546r 1  A5 F2        Le527:  LDA     pcon
000548r 1  DD rr rr             CMP     dectabl,X
00054Br 1  A5 F3                LDA     pcon+1
00054Dr 1  FD rr rr             SBC     dectabh,X
000550r 1  90 0D                BCC     Le540
000552r 1  85 F3                STA     pcon+1
000554r 1  A5 F2                LDA     pcon
000556r 1  FD rr rr             SBC     dectabl,X
000559r 1  85 F2                STA     pcon
00055Br 1  E6 F9                INC     char
00055Dr 1  D0 E7                BNE     Le527
00055Fr 1  A5 F9        Le540:  LDA     char
000561r 1  E8                   INX
000562r 1  CA                   DEX
000563r 1  F0 0E                BEQ     Le554
000565r 1  C9 B0                CMP     #$B0
000567r 1  F0 02                BEQ     Le54c
000569r 1  85 C9                STA     leadbl
00056Br 1  24 C9        Le54c:  BIT     leadbl
00056Dr 1  30 04                BMI     Le554
00056Fr 1  A5 FA                LDA     leadzr
000571r 1  F0 0B                BEQ     Le55f
000573r 1  20 rr rr     Le554:  JSR     cout
000576r 1  24 F8                BIT     auto_flag
000578r 1  10 04                BPL     Le55f
00057Ar 1  99 00 02             STA     buffer,Y
00057Dr 1  C8                   INY
00057Er 1  CA           Le55f:  DEX
00057Fr 1  10 C1                BPL     Le523
000581r 1  60                   RTS
000582r 1               ; powers of 10 table, low byte
000582r 1  01 0A 64 E8  dectabl:        .byte   $01,$0A,$64,$E8,$10             ; "..dh."
000586r 1  10           
000587r 1               
000587r 1               ; powers of 10 table, high byte
000587r 1  00 00 00 03  dectabh:        .byte   $00,$00,$00,$03,$27             ; "....'"
00058Br 1  27           
00058Cr 1               
00058Cr 1  A5 CA        find_line:      LDA     pp
00058Er 1  85 E6                STA     p3
000590r 1  A5 CB                LDA     pp+1
000592r 1  85 E7                STA     p3+1
000594r 1               
000594r 1  E8           find_line1:     INX
000595r 1               
000595r 1  A5 E7        find_line2:     LDA     p3+1
000597r 1  85 E5                STA     p2+1
000599r 1  A5 E6                LDA     p3
00059Br 1  85 E4                STA     p2
00059Dr 1  C5 4C                CMP     himem
00059Fr 1  A5 E5                LDA     p2+1
0005A1r 1  E5 4D                SBC     himem+1
0005A3r 1  B0 26                BCS     Le5ac
0005A5r 1  A0 01                LDY     #$01
0005A7r 1  B1 E4                LDA     (p2),Y
0005A9r 1  E5 CE                SBC     acc
0005ABr 1  C8                   INY
0005ACr 1  B1 E4                LDA     (p2),Y
0005AEr 1  E5 CF                SBC     acc+1
0005B0r 1  B0 19                BCS     Le5ac
0005B2r 1  A0 00                LDY     #$00
0005B4r 1  A5 E6                LDA     p3
0005B6r 1  71 E4                ADC     (p2),Y
0005B8r 1  85 E6                STA     p3
0005BAr 1  90 03                BCC     Le5a0
0005BCr 1  E6 E7                INC     p3+1
0005BEr 1  18                   CLC
0005BFr 1  C8           Le5a0:  INY
0005C0r 1  A5 CE                LDA     acc
0005C2r 1  F1 E4                SBC     (p2),Y
0005C4r 1  C8                   INY
0005C5r 1  A5 CF                LDA     acc+1
0005C7r 1  F1 E4                SBC     (p2),Y
0005C9r 1  B0 CA                BCS     find_line2
0005CBr 1  60           Le5ac:  RTS
0005CCr 1               
0005CCr 1               ; token $0B - "NEW"
0005CCr 1  46 F8        new_cmd:        LSR     auto_flag
0005CEr 1  A5 4C                LDA     himem
0005D0r 1  85 CA                STA     pp
0005D2r 1  A5 4D                LDA     himem+1
0005D4r 1  85 CB                STA     pp+1
0005D6r 1               
0005D6r 1               ; token $0C - "CLR"
0005D6r 1  A5 4A        clr:    LDA     lomem
0005D8r 1  85 CC                STA     pv
0005DAr 1  A5 4B                LDA     lomem+1
0005DCr 1  85 CD                STA     pv+1
0005DEr 1  A9 00                LDA     #$00
0005E0r 1  85 FB                STA     for_nest_count
0005E2r 1  85 FC                STA     gosub_nest_count
0005E4r 1  85 FE                STA     synpag
0005E6r 1  A9 00                LDA     #$00
0005E8r 1  85 1D                STA     Z1d
0005EAr 1  60                   RTS
0005EBr 1  A5 D0        Le5cc:  LDA     srch
0005EDr 1  69 05                ADC     #$05
0005EFr 1  85 D2                STA     srch2
0005F1r 1  A5 D1                LDA     tokndxstk
0005F3r 1  69 00                ADC     #$00
0005F5r 1  85 D3                STA     srch2+1
0005F7r 1  A5 D2                LDA     srch2
0005F9r 1  C5 CA                CMP     pp
0005FBr 1  A5 D3                LDA     srch2+1
0005FDr 1  E5 CB                SBC     pp+1
0005FFr 1  90 03                BCC     Le5e5
000601r 1  4C rr rr             JMP     Le36b
000604r 1  A5 CE        Le5e5:  LDA     acc
000606r 1  91 D0                STA     (srch),Y
000608r 1  A5 CF                LDA     acc+1
00060Ar 1  C8                   INY
00060Br 1  91 D0                STA     (srch),Y
00060Dr 1  A5 D2                LDA     srch2
00060Fr 1  C8                   INY
000610r 1  91 D0                STA     (srch),Y
000612r 1  A5 D3                LDA     srch2+1
000614r 1  C8                   INY
000615r 1  91 D0                STA     (srch),Y
000617r 1  A9 00                LDA     #$00
000619r 1  C8                   INY
00061Ar 1  91 D0                STA     (srch),Y
00061Cr 1  C8                   INY
00061Dr 1  91 D0                STA     (srch),Y
00061Fr 1  A5 D2                LDA     srch2
000621r 1  85 CC                STA     pv
000623r 1  A5 D3                LDA     srch2+1
000625r 1  85 CD                STA     pv+1
000627r 1  A5 D0                LDA     srch
000629r 1  90 43                BCC     Le64f
00062Br 1  85 CE        execute_var:    STA     acc
00062Dr 1  84 CF                STY     acc+1
00062Fr 1  20 rr rr             JSR     get_next_prog_byte
000632r 1  30 0E                BMI     Le623
000634r 1  C9 40                CMP     #$40
000636r 1  F0 0A                BEQ     Le623
000638r 1  4C rr rr             JMP     Le628
00063Br 1  06 C9 49 D0          .byte   $06,$C9,$49,$D0,$07,$A9,$49
00063Fr 1  07 A9 49     
000642r 1  85 CF        Le623:  STA     acc+1
000644r 1  20 rr rr             JSR     get_next_prog_byte
000647r 1  A5 4B        Le628:  LDA     lomem+1
000649r 1  85 D1                STA     tokndxstk
00064Br 1  A5 4A                LDA     lomem
00064Dr 1  85 D0        Le62e:  STA     srch
00064Fr 1  C5 CC                CMP     pv
000651r 1  A5 D1                LDA     tokndxstk
000653r 1  E5 CD                SBC     pv+1
000655r 1  B0 94                BCS     Le5cc
000657r 1  B1 D0                LDA     (srch),Y
000659r 1  C8                   INY
00065Ar 1  C5 CE                CMP     acc
00065Cr 1  D0 06                BNE     Le645
00065Er 1  B1 D0                LDA     (srch),Y
000660r 1  C5 CF                CMP     acc+1
000662r 1  F0 0E                BEQ     Le653
000664r 1  C8           Le645:  INY
000665r 1  B1 D0                LDA     (srch),Y
000667r 1  48                   PHA
000668r 1  C8                   INY
000669r 1  B1 D0                LDA     (srch),Y
00066Br 1  85 D1                STA     tokndxstk
00066Dr 1  68                   PLA
00066Er 1  A0 00        Le64f:  LDY     #$00
000670r 1  F0 DB                BEQ     Le62e
000672r 1  A5 D0        Le653:  LDA     srch
000674r 1  69 03                ADC     #$03
000676r 1  20 rr rr             JSR     push_a_noun_stk
000679r 1  A5 D1                LDA     tokndxstk
00067Br 1  69 00                ADC     #$00
00067Dr 1  95 78                STA     noun_stk_h_str,X
00067Fr 1  A5 CF                LDA     acc+1
000681r 1  C9 40                CMP     #$40
000683r 1  D0 1C                BNE     fetch_prog_byte
000685r 1  88                   DEY
000686r 1  98                   TYA
000687r 1  20 rr rr             JSR     push_a_noun_stk
00068Ar 1  88                   DEY
00068Br 1  94 78                STY     noun_stk_h_str,X
00068Dr 1  A0 03                LDY     #$03
00068Fr 1  F6 78        Le670:  INC     noun_stk_h_str,X
000691r 1  C8                   INY
000692r 1  B1 D0                LDA     (srch),Y
000694r 1  30 F9                BMI     Le670
000696r 1  10 09                BPL     fetch_prog_byte
000698r 1               
000698r 1  A9 00        execute_stmt:   LDA     #$00
00069Ar 1  85 D4                STA     if_flag
00069Cr 1  85 D5                STA     cr_flag
00069Er 1  A2 20                LDX     #$20
0006A0r 1               
0006A0r 1               ; push old verb on stack for later use in precedence test
0006A0r 1  48           push_old_verb:  PHA
0006A1r 1  A0 00        fetch_prog_byte:        LDY     #$00
0006A3r 1  B1 E0                LDA     (pverb),Y
0006A5r 1  10 18        Le686:  BPL     execute_token
0006A7r 1  0A                   ASL
0006A8r 1  30 81                BMI     execute_var
0006AAr 1  20 rr rr             JSR     get_next_prog_byte
0006ADr 1  20 rr rr             JSR     push_ya_noun_stk
0006B0r 1  20 rr rr             JSR     get_next_prog_byte
0006B3r 1  95 A0                STA     noun_stk_h_int,X
0006B5r 1  24 D4        Le696:  BIT     if_flag
0006B7r 1  10 01                BPL     Le69b
0006B9r 1  CA                   DEX
0006BAr 1  20 rr rr     Le69b:  JSR     get_next_prog_byte
0006BDr 1  B0 E6                BCS     Le686
0006BFr 1               
0006BFr 1  C9 28        execute_token:  CMP     #$28
0006C1r 1  D0 1F                BNE     execute_verb
0006C3r 1  A5 E0                LDA     pverb
0006C5r 1  20 rr rr             JSR     push_a_noun_stk
0006C8r 1  A5 E1                LDA     pverb+1
0006CAr 1  95 78                STA     noun_stk_h_str,X
0006CCr 1  24 D4                BIT     if_flag
0006CEr 1  30 0B                BMI     Le6bc
0006D0r 1  A9 01                LDA     #$01
0006D2r 1  20 rr rr             JSR     push_a_noun_stk
0006D5r 1  A9 00                LDA     #$00
0006D7r 1  95 78                STA     noun_stk_h_str,X
0006D9r 1  F6 78        Le6ba:  INC     noun_stk_h_str,X
0006DBr 1  20 rr rr     Le6bc:  JSR     get_next_prog_byte
0006DEr 1  30 F9                BMI     Le6ba
0006E0r 1  B0 D3                BCS     Le696
0006E2r 1  24 D4        execute_verb:   BIT     if_flag
0006E4r 1  10 06                BPL     Le6cd
0006E6r 1  C9 04                CMP     #$04
0006E8r 1  B0 D0                BCS     Le69b
0006EAr 1  46 D4                LSR     if_flag
0006ECr 1  A8           Le6cd:  TAY
0006EDr 1  85 D6                STA     current_verb
0006EFr 1  B9 rr rr             LDA     verb_prec_tbl,Y
0006F2r 1  29 55                AND     #$55
0006F4r 1  0A                   ASL
0006F5r 1  85 D7                STA     precedence
0006F7r 1  68           Le6d8:  PLA
0006F8r 1  A8                   TAY
0006F9r 1  B9 rr rr             LDA     verb_prec_tbl,Y
0006FCr 1  29 AA                AND     #$AA
0006FEr 1  C5 D7                CMP     precedence
000700r 1  B0 09                BCS     do_verb
000702r 1  98                   TYA
000703r 1  48                   PHA
000704r 1  20 rr rr             JSR     get_next_prog_byte
000707r 1  A5 D6                LDA     current_verb
000709r 1  90 95                BCC     push_old_verb
00070Br 1  B9 rr rr     do_verb:        LDA     verb_adr_l,Y
00070Er 1  85 CE                STA     acc
000710r 1  B9 rr rr             LDA     verb_adr_h,Y
000713r 1  85 CF                STA     acc+1
000715r 1  20 rr rr             JSR     Se6fc
000718r 1  4C rr rr             JMP     Le6d8
00071Br 1               
00071Br 1  6C CE 00     Se6fc:  JMP     (acc)
00071Er 1               
00071Er 1  E6 E0        get_next_prog_byte:     INC     pverb
000720r 1  D0 02                BNE     Le705
000722r 1  E6 E1                INC     pverb+1
000724r 1  B1 E0        Le705:  LDA     (pverb),Y
000726r 1  60                   RTS
000727r 1               
000727r 1  94 77        push_ya_noun_stk:       STY     syn_stk_h+31,X
000729r 1               
000729r 1  CA           push_a_noun_stk:        DEX
00072Ar 1  30 03                BMI     Le710
00072Cr 1  95 50                STA     noun_stk_l,X
00072Er 1  60                   RTS
00072Fr 1  A0 66        Le710:  LDY     #$66
000731r 1  4C rr rr     go_errmess_3:   JMP     print_err_msg
000734r 1               
000734r 1  A0 00        get16bit:       LDY     #$00
000736r 1  B5 50                LDA     noun_stk_l,X
000738r 1  85 CE                STA     acc
00073Ar 1  B5 A0                LDA     noun_stk_h_int,X
00073Cr 1  85 CF                STA     acc+1
00073Er 1  B5 78                LDA     noun_stk_h_str,X
000740r 1  F0 0E                BEQ     Le731
000742r 1  85 CF                STA     acc+1
000744r 1  B1 CE                LDA     (acc),Y
000746r 1  48                   PHA
000747r 1  C8                   INY
000748r 1  B1 CE                LDA     (acc),Y
00074Ar 1  85 CF                STA     acc+1
00074Cr 1  68                   PLA
00074Dr 1  85 CE                STA     acc
00074Fr 1  88                   DEY
000750r 1  E8           Le731:  INX
000751r 1  60                   RTS
000752r 1               
000752r 1               ; token $16 - "=" for numeric equality operator
000752r 1  20 rr rr     eq_op:  JSR     neq_op
000755r 1               
000755r 1               ; token $37 - "NOT"
000755r 1  20 rr rr     not_op: JSR     get16bit
000758r 1  98                   TYA
000759r 1  20 rr rr             JSR     push_ya_noun_stk
00075Cr 1  95 A0                STA     noun_stk_h_int,X
00075Er 1  C5 CE                CMP     acc
000760r 1  D0 06                BNE     Le749
000762r 1  C5 CF                CMP     acc+1
000764r 1  D0 02                BNE     Le749
000766r 1  F6 50                INC     noun_stk_l,X
000768r 1  60           Le749:  RTS
000769r 1               
000769r 1               ; token $17 - "#" for numeric inequality operator
000769r 1               ; token $1B - "<>" for numeric inequality operator
000769r 1  20 rr rr     neq_op: JSR     subtract
00076Cr 1  20 rr rr             JSR     sgn_fn
00076Fr 1               
00076Fr 1               ; token $31 - "ABS"
00076Fr 1  20 rr rr     abs_fn: JSR     get16bit
000772r 1  24 CF                BIT     acc+1
000774r 1  30 1B                BMI     Se772
000776r 1  CA           Le757:  DEX
000777r 1  60           Le758:  RTS
000778r 1               
000778r 1               ; token $30 - "SGN"
000778r 1  20 rr rr     sgn_fn: JSR     get16bit
00077Br 1  A5 CF                LDA     acc+1
00077Dr 1  D0 04                BNE     Le764
00077Fr 1  A5 CE                LDA     acc
000781r 1  F0 F3                BEQ     Le757
000783r 1  A9 FF        Le764:  LDA     #$FF
000785r 1  20 rr rr             JSR     push_ya_noun_stk
000788r 1  95 A0                STA     noun_stk_h_int,X
00078Ar 1  24 CF                BIT     acc+1
00078Cr 1  30 E9                BMI     Le758
00078Er 1               
00078Er 1               ; token $36 - "-" for unary negation
00078Er 1  20 rr rr     negate: JSR     get16bit
000791r 1               
000791r 1  98           Se772:  TYA
000792r 1  38                   SEC
000793r 1  E5 CE                SBC     acc
000795r 1  20 rr rr             JSR     push_ya_noun_stk
000798r 1  98                   TYA
000799r 1  E5 CF                SBC     acc+1
00079Br 1  50 23                BVC     Le7a1
00079Dr 1  A0 00        Le77e:  LDY     #$00
00079Fr 1  10 90                BPL     go_errmess_3
0007A1r 1               
0007A1r 1               ; token $13 - "-" for numeric subtraction
0007A1r 1  20 rr rr     subtract:       JSR     negate
0007A4r 1               
0007A4r 1               ; token $12 - "+" for numeric addition
0007A4r 1  20 rr rr     add:    JSR     get16bit
0007A7r 1  A5 CE                LDA     acc
0007A9r 1  85 DA                STA     aux
0007ABr 1  A5 CF                LDA     acc+1
0007ADr 1  85 DB                STA     aux+1
0007AFr 1  20 rr rr             JSR     get16bit
0007B2r 1               
0007B2r 1  18           Se793:  CLC
0007B3r 1  A5 CE                LDA     acc
0007B5r 1  65 DA                ADC     aux
0007B7r 1  20 rr rr             JSR     push_ya_noun_stk
0007BAr 1  A5 CF                LDA     acc+1
0007BCr 1  65 DB                ADC     aux+1
0007BEr 1  70 DD                BVS     Le77e
0007C0r 1  95 A0        Le7a1:  STA     noun_stk_h_int,X
0007C2r 1               
0007C2r 1               ; token $35 - "+" for unary positive
0007C2r 1  60           unary_pos:      RTS
0007C3r 1               
0007C3r 1               ; token $50 - "TAB" function
0007C3r 1  20 rr rr     tab_fn: JSR     get16bit
0007C6r 1  A4 CE                LDY     acc
0007C8r 1  F0 05                BEQ     Le7b0
0007CAr 1  88                   DEY
0007CBr 1  A5 CF                LDA     acc+1
0007CDr 1  F0 0C                BEQ     Le7bc
0007CFr 1  60           Le7b0:  RTS
0007D0r 1               
0007D0r 1               ; horizontal tab
0007D0r 1  A5 24        tabout: LDA     ch
0007D2r 1  09 07                ORA     #$07
0007D4r 1  A8                   TAY
0007D5r 1  C8                   INY
0007D6r 1  A9 A0        Le7b7:  LDA     #$A0
0007D8r 1  20 rr rr             JSR     cout
0007DBr 1  C4 24        Le7bc:  CPY     ch
0007DDr 1  B0 F7                BCS     Le7b7
0007DFr 1  60                   RTS
0007E0r 1               
0007E0r 1               ; token $49 - "," in print, numeric follows
0007E0r 1  20 rr rr     print_com_num:  JSR     tabout
0007E3r 1               
0007E3r 1               ; token $62 - "PRINT" numeric
0007E3r 1  20 rr rr     print_num:      JSR     get16bit
0007E6r 1  A5 CF                LDA     acc+1
0007E8r 1  10 0A                BPL     Le7d5
0007EAr 1  A9 AD                LDA     #$AD
0007ECr 1  20 rr rr             JSR     cout
0007EFr 1  20 rr rr             JSR     Se772
0007F2r 1  50 EF                BVC     print_num
0007F4r 1  88           Le7d5:  DEY
0007F5r 1  84 D5                STY     cr_flag
0007F7r 1  86 CF                STX     acc+1
0007F9r 1  A6 CE                LDX     acc
0007FBr 1  20 rr rr             JSR     prdec
0007FEr 1  A6 CF                LDX     acc+1
000800r 1  60                   RTS
000801r 1               
000801r 1               ; token $0D - "AUTO" command
000801r 1  20 rr rr     auto_cmd:       JSR     get16bit
000804r 1  A5 CE                LDA     acc
000806r 1  85 F6                STA     auto_ln
000808r 1  A5 CF                LDA     acc+1
00080Ar 1  85 F7                STA     auto_ln+1
00080Cr 1  88                   DEY
00080Dr 1  84 F8                STY     auto_flag
00080Fr 1  C8                   INY
000810r 1  A9 0A                LDA     #$0A
000812r 1  85 F4        Le7f3:  STA     auto_inc
000814r 1  84 F5                STY     auto_inc+1
000816r 1  60                   RTS
000817r 1               
000817r 1               ; token $0E - "," in AUTO command
000817r 1  20 rr rr     auto_com:       JSR     get16bit
00081Ar 1  A5 CE                LDA     acc
00081Cr 1  A4 CF                LDY     acc+1
00081Er 1  10 F2                BPL     Le7f3
000820r 1               
000820r 1               ; token $56 - "=" in FOR statement
000820r 1               ; token $71 - "=" in LET (or implied LET) statement
000820r 1  20 rr rr     var_assign:     JSR     get16bit
000823r 1  B5 50                LDA     noun_stk_l,X
000825r 1  85 DA                STA     aux
000827r 1  B5 78                LDA     noun_stk_h_str,X
000829r 1  85 DB                STA     aux+1
00082Br 1  A5 CE                LDA     acc
00082Dr 1  91 DA                STA     (aux),Y
00082Fr 1  C8                   INY
000830r 1  A5 CF                LDA     acc+1
000832r 1  91 DA                STA     (aux),Y
000834r 1  E8                   INX
000835r 1               
000835r 1  60           Te816:  RTS
000836r 1               
000836r 1               ; token $00 - begining of line
000836r 1               begin_line:
000836r 1  68                   PLA
000837r 1  68                   PLA
000838r 1               
000838r 1               ; token $03 - ":" statement separator
000838r 1  24 D5        colon:  BIT     cr_flag
00083Ar 1  10 05                BPL     Le822
00083Cr 1               
00083Cr 1               ; token $63 - "PRINT" with no arg
00083Cr 1  20 rr rr     print_cr:       JSR     crout
00083Fr 1               
00083Fr 1               ; token $47 - ";" at end of print statement
00083Fr 1  46 D5        print_semi:     LSR     cr_flag
000841r 1  60           Le822:  RTS
000842r 1               
000842r 1               
000842r 1               ; token $22 - "(" in string DIM
000842r 1               ; token $34 - "(" in numeric DIM
000842r 1               ; token $38 - "(" in numeric expression
000842r 1               ; token $3F - "(" in some PEEK, RND, SGN, ABS (PDL)
000842r 1  A0 FF        left_paren:     LDY     #$FF
000844r 1  84 D7                STY     precedence
000846r 1               
000846r 1               ; token $72 - ")" everywhere
000846r 1  60           right_paren:    RTS
000847r 1               
000847r 1               ; token $60 - "IF" statement
000847r 1  20 rr rr     if_stmt:        JSR     Sefcd
00084Ar 1  F0 07                BEQ     Le834
00084Cr 1  A9 25                LDA     #$25
00084Er 1  85 D6                STA     current_verb
000850r 1  88                   DEY
000851r 1  84 D4                STY     if_flag
000853r 1  E8           Le834:  INX
000854r 1  60                   RTS
000855r 1               ; RUN without CLR, used by Apple DOS
000855r 1  A5 CA        run_warm:       LDA     pp
000857r 1  A4 CB                LDY     pp+1
000859r 1  D0 55                BNE     Le896
00085Br 1               
00085Br 1               ; token $5C - "GOSUB" statement
00085Br 1  A0 41        gosub_stmt:     LDY     #$41
00085Dr 1  A5 FC                LDA     gosub_nest_count
00085Fr 1  C9 08                CMP     #$08
000861r 1  B0 59                BCS     go_errmess_4
000863r 1  A8                   TAY
000864r 1  E6 FC                INC     gosub_nest_count
000866r 1  A5 E0                LDA     pverb
000868r 1  99 00 01             STA     gstk_pverbl,Y
00086Br 1  A5 E1                LDA     pverb+1
00086Dr 1  99 08 01             STA     gstk_pverbh,Y
000870r 1  A5 DC                LDA     pline
000872r 1  99 10 01             STA     gstk_plinel,Y
000875r 1  A5 DD                LDA     pline+1
000877r 1  99 18 01             STA     gstk_plineh,Y
00087Ar 1               
00087Ar 1               ; token $24 - "THEN"
00087Ar 1               ; token $5F - "GOTO" statement
00087Ar 1  20 rr rr     goto_stmt:      JSR     get16bit
00087Dr 1  20 rr rr             JSR     find_line
000880r 1  90 04                BCC     Le867
000882r 1  A0 37                LDY     #$37
000884r 1  D0 36                BNE     go_errmess_4
000886r 1  A5 E4        Le867:  LDA     p2
000888r 1  A4 E5                LDY     p2+1
00088Ar 1               
00088Ar 1               ; loop to run a program
00088Ar 1  85 DC        run_loop:       STA     pline
00088Cr 1  84 DD                STY     pline+1
00088Er 1                       ;BIT     KBDCR ;stache commented out
00088Er 1                       ;BMI     Le8c3
00088Er 1  18                   CLC
00088Fr 1  69 03                ADC     #$03
000891r 1  90 01                BCC     Le87a
000893r 1  C8                   INY
000894r 1  A2 FF        Le87a:  LDX     #$FF
000896r 1  86 D9                STX     run_flag
000898r 1  9A                   TXS
000899r 1  85 E0                STA     pverb
00089Br 1  84 E1                STY     pverb+1
00089Dr 1  20 rr rr     Le883:  JSR     execute_stmt
0008A0r 1  24 D9                BIT     run_flag
0008A2r 1  10 49                BPL     end_stmt
0008A4r 1  18                   CLC
0008A5r 1  A0 00                LDY     #$00
0008A7r 1  A5 DC                LDA     pline
0008A9r 1  71 DC                ADC     (pline),Y
0008ABr 1  A4 DD                LDY     pline+1
0008ADr 1  90 01                BCC     Le896
0008AFr 1  C8                   INY
0008B0r 1  C5 4C        Le896:  CMP     himem
0008B2r 1  D0 D6                BNE     run_loop
0008B4r 1  C4 4D                CPY     himem+1
0008B6r 1  D0 D2                BNE     run_loop
0008B8r 1  A0 34                LDY     #$34
0008BAr 1  46 D9                LSR     run_flag
0008BCr 1  4C rr rr     go_errmess_4:   JMP     print_err_msg
0008BFr 1               
0008BFr 1               ; token $5B - "RETURN" statement
0008BFr 1  A0 4A        return_stmt:    LDY     #$4A
0008C1r 1  A5 FC                LDA     gosub_nest_count
0008C3r 1  F0 F7                BEQ     go_errmess_4
0008C5r 1  C6 FC                DEC     gosub_nest_count
0008C7r 1  A8                   TAY
0008C8r 1  B9 0F 01             LDA     gstk_plinel-1,Y
0008CBr 1  85 DC                STA     pline
0008CDr 1  B9 17 01             LDA     gstk_plineh-1,Y
0008D0r 1  85 DD                STA     pline+1
0008D2r 1  BE FF 00             LDX     a:synpag+1,Y            ; force absolute addressing mode
0008D5r 1  B9 07 01             LDA     gstk_pverbh-1,Y
0008D8r 1  A8           Le8be:  TAY
0008D9r 1  8A                   TXA
0008DAr 1  4C rr rr             JMP     Le87a
0008DDr 1  A0 63        Le8c3:  LDY     #$63
0008DFr 1  20 rr rr             JSR     Se3c4
0008E2r 1  A0 01                LDY     #$01
0008E4r 1  B1 DC                LDA     (pline),Y
0008E6r 1  AA                   TAX
0008E7r 1  C8                   INY
0008E8r 1  B1 DC                LDA     (pline),Y
0008EAr 1  20 rr rr             JSR     prdec
0008EDr 1               
0008EDr 1               ; token $51 - "END" statement
0008EDr 1  4C rr rr     end_stmt:       JMP     warm
0008F0r 1  C6 FB        Le8d6:  DEC     for_nest_count
0008F2r 1               
0008F2r 1               ; token $59 - "NEXT" statement
0008F2r 1               ; token $5A - "," in NEXT statement
0008F2r 1  A0 5B        next_stmt:      LDY     #$5B
0008F4r 1  A5 FB                LDA     for_nest_count
0008F6r 1  F0 C4        Le8dc:  BEQ     go_errmess_4
0008F8r 1  A8                   TAY
0008F9r 1  B5 50                LDA     noun_stk_l,X
0008FBr 1  D9 1F 01             CMP     fstk_varl-1,Y
0008FEr 1  D0 F0                BNE     Le8d6
000900r 1  B5 78                LDA     noun_stk_h_str,X
000902r 1  D9 27 01             CMP     fstk_varh-1,Y
000905r 1  D0 E9                BNE     Le8d6
000907r 1  B9 2F 01             LDA     fstk_stepl-1,Y
00090Ar 1  85 DA                STA     aux
00090Cr 1  B9 37 01             LDA     fstk_steph-1,Y
00090Fr 1  85 DB                STA     aux+1
000911r 1  20 rr rr             JSR     get16bit
000914r 1  CA                   DEX
000915r 1  20 rr rr             JSR     Se793
000918r 1  20 rr rr             JSR     var_assign
00091Br 1  CA                   DEX
00091Cr 1  A4 FB                LDY     for_nest_count
00091Er 1  B9 67 01             LDA     fstk_toh-1,Y
000921r 1  95 9F                STA     syn_stk_l+31,X
000923r 1  B9 5F 01             LDA     fstk_tol-1,Y
000926r 1  A0 00                LDY     #$00
000928r 1  20 rr rr             JSR     push_ya_noun_stk
00092Br 1  20 rr rr             JSR     subtract
00092Er 1  20 rr rr             JSR     sgn_fn
000931r 1  20 rr rr             JSR     get16bit
000934r 1  A4 FB                LDY     for_nest_count
000936r 1  A5 CE                LDA     acc
000938r 1  F0 05                BEQ     Le925
00093Ar 1  59 37 01             EOR     fstk_steph-1,Y
00093Dr 1  10 12                BPL     Le937
00093Fr 1  B9 3F 01     Le925:  LDA     fstk_plinel-1,Y
000942r 1  85 DC                STA     pline
000944r 1  B9 47 01             LDA     fstk_plineh-1,Y
000947r 1  85 DD                STA     pline+1
000949r 1  BE 4F 01             LDX     fstk_pverbl-1,Y
00094Cr 1  B9 57 01             LDA     fstk_pverbh-1,Y
00094Fr 1  D0 87                BNE     Le8be
000951r 1  C6 FB        Le937:  DEC     for_nest_count
000953r 1  60                   RTS
000954r 1               
000954r 1               ; token $55 - "FOR" statement
000954r 1  A0 54        for_stmt:       LDY     #$54
000956r 1  A5 FB                LDA     for_nest_count
000958r 1  C9 08                CMP     #$08
00095Ar 1  F0 9A                BEQ     Le8dc
00095Cr 1  E6 FB                INC     for_nest_count
00095Er 1  A8                   TAY
00095Fr 1  B5 50                LDA     noun_stk_l,X
000961r 1  99 20 01             STA     fstk_varl,Y
000964r 1  B5 78                LDA     noun_stk_h_str,X
000966r 1  99 28 01             STA     fstk_varh,Y
000969r 1  60                   RTS
00096Ar 1               
00096Ar 1               ; token $57 - "TO"
00096Ar 1  20 rr rr     to_clause:      JSR     get16bit
00096Dr 1  A4 FB                LDY     for_nest_count
00096Fr 1  A5 CE                LDA     acc
000971r 1  99 5F 01             STA     fstk_tol-1,Y
000974r 1  A5 CF                LDA     acc+1
000976r 1  99 67 01             STA     fstk_toh-1,Y
000979r 1  A9 01                LDA     #$01
00097Br 1  99 2F 01             STA     fstk_stepl-1,Y
00097Er 1  A9 00                LDA     #$00
000980r 1  99 37 01     Le966:  STA     fstk_steph-1,Y
000983r 1  A5 DC                LDA     pline
000985r 1  99 3F 01             STA     fstk_plinel-1,Y
000988r 1  A5 DD                LDA     pline+1
00098Ar 1  99 47 01             STA     fstk_plineh-1,Y
00098Dr 1  A5 E0                LDA     pverb
00098Fr 1  99 4F 01             STA     fstk_pverbl-1,Y
000992r 1  A5 E1                LDA     pverb+1
000994r 1  99 57 01             STA     fstk_pverbh-1,Y
000997r 1  60                   RTS
000998r 1               
000998r 1  20 rr rr     Te97e:  JSR     get16bit
00099Br 1  A4 FB                LDY     for_nest_count
00099Dr 1  A5 CE                LDA     acc
00099Fr 1  99 2F 01             STA     fstk_stepl-1,Y
0009A2r 1  A5 CF                LDA     acc+1
0009A4r 1  4C rr rr             JMP     Le966
0009A7r 1  00 00 00 00          .byte   $00,$00,$00,$00,$00,$00,$00,$00 ; "........"
0009ABr 1  00 00 00 00  
0009AFr 1  00 00 00             .byte   $00,$00,$00                     ; "..."
0009B2r 1               
0009B2r 1               ; verb precedence
0009B2r 1               ; (verb_prec[token]&0xAA)>>1 for left (?)
0009B2r 1               ; verb_prec[token]&0x55 for right (?)
0009B2r 1               verb_prec_tbl:
0009B2r 1  00 00 00 AB          .byte   $00,$00,$00,$AB,$03,$03,$03,$03 ; "...+...."
0009B6r 1  03 03 03 03  
0009BAr 1  03 03 03 03          .byte   $03,$03,$03,$03,$03,$03,$03,$03 ; "........"
0009BEr 1  03 03 03 03  
0009C2r 1  03 03 3F 3F          .byte   $03,$03,$3F,$3F,$C0,$C0,$3C,$3C ; "..??@@<<"
0009C6r 1  C0 C0 3C 3C  
0009CAr 1  3C 3C 3C 3C          .byte   $3C,$3C,$3C,$3C,$3C,$30,$0F,$C0 ; "<<<<<0.@"
0009CEr 1  3C 30 0F C0  
0009D2r 1  CC FF 55 00          .byte   $CC,$FF,$55,$00,$AB,$AB,$03,$03 ; "L.U.++.."
0009D6r 1  AB AB 03 03  
0009DAr 1  FF FF 55 FF          .byte   $FF,$FF,$55,$FF,$FF,$55,$CF,$CF ; "..U..UOO"
0009DEr 1  FF 55 CF CF  
0009E2r 1  CF CF CF FF          .byte   $CF,$CF,$CF,$FF,$55,$C3,$C3,$C3 ; "OOO.UCCC"
0009E6r 1  55 C3 C3 C3  
0009EAr 1  55 F0 F0 CF          .byte   $55,$F0,$F0,$CF,$56,$56,$56,$55 ; "UppOVVVU"
0009EEr 1  56 56 56 55  
0009F2r 1  FF FF 55 03          .byte   $FF,$FF,$55,$03,$03,$03,$03,$03 ; "..U....."
0009F6r 1  03 03 03 03  
0009FAr 1  03 03 FF FF          .byte   $03,$03,$FF,$FF,$FF,$03,$03,$03 ; "........"
0009FEr 1  FF 03 03 03  
000A02r 1  03 03 03 03          .byte   $03,$03,$03,$03,$03,$03,$03,$03 ; "........"
000A06r 1  03 03 03 03  
000A0Ar 1  03 03 03 03          .byte   $03,$03,$03,$03,$03,$00,$AB,$03 ; "......+."
000A0Er 1  03 00 AB 03  
000A12r 1  57 03 03 03          .byte   $57,$03,$03,$03,$03,$07,$03,$03 ; "W......."
000A16r 1  03 07 03 03  
000A1Ar 1  03 03 03 03          .byte   $03,$03,$03,$03,$03,$03,$03,$03 ; "........"
000A1Er 1  03 03 03 03  
000A22r 1  03 03 AA FF          .byte   $03,$03,$AA,$FF,$FF,$FF,$FF,$FF ; "..*....."
000A26r 1  FF FF FF FF  
000A2Ar 1               verb_adr_l:
000A2Ar 1  17 FF FF 19          .byte   $17,$FF,$FF,$19,$5D,$35,$4B,$F2 ; "....]5Kr"
000A2Er 1  5D 35 4B F2  
000A32r 1  EC 87 6F AD          .byte   $EC,$87,$6F,$AD,$B7,$E2,$F8,$54 ; "l.o-7bxT"
000A36r 1  B7 E2 F8 54  
000A3Ar 1  80 96 85 82          .byte   $80,$96,$85,$82,$22,$10,$33,$4A ; "....".3J"
000A3Er 1  22 10 33 4A  
000A42r 1  13 06 0B 4A          .byte   $13,$06,$0B,$4A,$01,$40,$47,$7A ; "...J.@Gz"
000A46r 1  01 40 47 7A  
000A4Ar 1  00 FF 23 09          .byte   $00,$FF,$23,$09,$5B,$16,$B6,$CB ; "..#.[.6K"
000A4Er 1  5B 16 B6 CB  
000A52r 1  FF FF FB FF          .byte   $FF,$FF,$FB,$FF,$FF,$24,$F6,$4E ; "..{..$vN"
000A56r 1  FF 24 F6 4E  
000A5Ar 1  59 50 00 FF          .byte   $59,$50,$00,$FF,$23,$A3,$6F,$36 ; "YP..##o6"
000A5Er 1  23 A3 6F 36  
000A62r 1  23 D7 1C 22          .byte   $23,$D7,$1C,$22,$C2,$AE,$BA,$23 ; "#W."B.:#"
000A66r 1  C2 AE BA 23  
000A6Ar 1  FF FF 21 30          .byte   $FF,$FF,$21,$30,$1E,$03,$C4,$20 ; "..!0..D "
000A6Er 1  1E 03 C4 20  
000A72r 1  00 C1 FF FF          .byte   $00,$C1,$FF,$FF,$FF,$A0,$30,$1E ; ".A... 0."
000A76r 1  FF A0 30 1E  
000A7Ar 1  A4 D3 B6 BC          .byte   $A4,$D3,$B6,$BC,$AA,$3A,$01,$50 ; "$S6<*:.P"
000A7Er 1  AA 3A 01 50  
000A82r 1  7E D8 D8 A5          .byte   $7E,$D8,$D8,$A5,$3C,$FF,$16,$5B ; "~XX%<..["
000A86r 1  3C FF 16 5B  
000A8Ar 1  28 03 C4 1D          .byte   $28,$03,$C4,$1D,$00,$0C,$4E,$00 ; "(.D...N."
000A8Er 1  00 0C 4E 00  
000A92r 1  3E 00 A6 B0          .byte   $3E,$00,$A6,$B0,$00,$BC,$C6,$57 ; ">.&0.<FW"
000A96r 1  00 BC C6 57  
000A9Ar 1  8C 01 27 FF          .byte   $8C,$01,$27,$FF,$FF,$FF,$FF,$FF ; "..'....."
000A9Er 1  FF FF FF FF  
000AA2r 1               verb_adr_h:
000AA2r 1  E8 FF FF E8          .byte   $E8,$FF,$FF,$E8,$E0,$E0,$E0,$EF ; "h..h```o"
000AA6r 1  E0 E0 E0 EF  
000AAAr 1  EF E3 E3 E5          .byte   $EF,$E3,$E3,$E5,$E5,$E7,$E7,$EE ; "occeeggn"
000AAEr 1  E5 E7 E7 EE  
000AB2r 1  EF EF E7 E7          .byte   $EF,$EF,$E7,$E7,$E2,$EF,$E7,$E7 ; "ooggbogg"
000AB6r 1  E2 EF E7 E7  
000ABAr 1  EC EC EC E7          .byte   $EC,$EC,$EC,$E7,$EC,$EC,$EC,$E2 ; "lllglllb"
000ABEr 1  EC EC EC E2  
000AC2r 1  00 FF E8 E1          .byte   $00,$FF,$E8,$E1,$E8,$E8,$EF,$EB ; "..hahhok"
000AC6r 1  E8 E8 EF EB  
000ACAr 1  FF FF E0 FF          .byte   $FF,$FF,$E0,$FF,$FF,$EF,$EE,$EF ; "..`..ono"
000ACEr 1  FF EF EE EF  
000AD2r 1  E7 E7 00 FF          .byte   $E7,$E7,$00,$FF,$E8,$E7,$E7,$E7 ; "gg..hggg"
000AD6r 1  E8 E7 E7 E7  
000ADAr 1  E8 E1 E2 EE          .byte   $E8,$E1,$E2,$EE,$EE,$EE,$EE,$E8 ; "habnnnnh"
000ADEr 1  EE EE EE E8  
000AE2r 1  FF FF E1 E1          .byte   $FF,$FF,$E1,$E1,$EF,$EE,$E7,$E8 ; "..aaongh"
000AE6r 1  EF EE E7 E8  
000AEAr 1  EE E7 FF FF          .byte   $EE,$E7,$FF,$FF,$FF,$EE,$E1,$EF ; "ng...nao"
000AEEr 1  FF EE E1 EF  
000AF2r 1  E7 E8 EF EF          .byte   $E7,$E8,$EF,$EF,$EB,$E9,$E8,$E9 ; "ghookihi"
000AF6r 1  EB E9 E8 E9  
000AFAr 1  E9 E8 E8 E8          .byte   $E9,$E8,$E8,$E8,$E8,$FF,$E8,$E8 ; "ihhhh.hh"
000AFEr 1  E8 FF E8 E8  
000B02r 1  E8 EE E7 E8          .byte   $E8,$EE,$E7,$E8,$EF,$EF,$EE,$EF ; "hnghoono"
000B06r 1  EF EF EE EF  
000B0Ar 1  EE EF EE EE          .byte   $EE,$EF,$EE,$EE,$EF,$EE,$EE,$EE ; "nonnonnn"
000B0Er 1  EF EE EE EE  
000B12r 1  E1 E8 E8 FF          .byte   $E1,$E8,$E8,$FF,$FF,$FF,$FF,$FF ; "ahh....."
000B16r 1  FF FF FF FF  
000B1Ar 1               
000B1Ar 1               ; Error message strings. Last character has high bit unset.
000B1Ar 1               error_msg_tbl:
000B1Ar 1  BE B3 B2 B7          .byte   $BE,$B3,$B2,$B7,$B6,$37         ; ">32767"
000B1Er 1  B6 37        
000B20r 1  D4 CF CF A0          .byte   $D4,$CF,$CF,$A0,$CC,$CF,$CE,$47 ; "TOO LONG"
000B24r 1  CC CF CE 47  
000B28r 1  D3 D9 CE D4          .byte   $D3,$D9,$CE,$D4,$C1,$58         ; "SYNTAX"
000B2Cr 1  C1 58        
000B2Er 1  CD C5 CD A0          .byte   $CD,$C5,$CD,$A0,$C6,$D5,$CC,$4C ; "MEM FULL"
000B32r 1  C6 D5 CC 4C  
000B36r 1  D4 CF CF A0          .byte   $D4,$CF,$CF,$A0,$CD,$C1,$CE,$D9,$A0,$D0,$C1,$D2,$C5,$CE,$53 ; "TOO MANY PARENS"
000B3Ar 1  CD C1 CE D9  
000B3Er 1  A0 D0 C1 D2  
000B45r 1  D3 D4 D2 C9          .byte   $D3,$D4,$D2,$C9,$CE,$47         ; "STRING"
000B49r 1  CE 47        
000B4Br 1  CE CF A0 C5          .byte   $CE,$CF,$A0,$C5,$CE,$44         ; "NO END"
000B4Fr 1  CE 44        
000B51r 1  C2 C1 C4 A0          .byte   $C2,$C1,$C4,$A0,$C2,$D2,$C1,$CE,$C3,$48 ; "BAD BRANCH"
000B55r 1  C2 D2 C1 CE  
000B59r 1  C3 48        
000B5Br 1  BE B8 A0 C7          .byte   $BE,$B8,$A0,$C7,$CF,$D3,$D5,$C2,$53     ; ">8 GOSUBS"
000B5Fr 1  CF D3 D5 C2  
000B63r 1  53           
000B64r 1  C2 C1 C4 A0          .byte   $C2,$C1,$C4,$A0,$D2,$C5,$D4,$D5,$D2,$4E ; "BAD RETURN"
000B68r 1  D2 C5 D4 D5  
000B6Cr 1  D2 4E        
000B6Er 1  BE B8 A0 C6          .byte   $BE,$B8,$A0,$C6,$CF,$D2,$53     ; ">8 FORS"
000B72r 1  CF D2 53     
000B75r 1  C2 C1 C4 A0          .byte   $C2,$C1,$C4,$A0,$CE,$C5,$D8,$54 ; "BAD NEXT"
000B79r 1  CE C5 D8 54  
000B7Dr 1  D3 D4 CF D0          .byte   $D3,$D4,$CF,$D0,$D0,$C5,$C4,$A0,$C1,$D4,$20 ; "STOPPED AT "
000B81r 1  D0 C5 C4 A0  
000B85r 1  C1 D4 20     
000B88r 1  AA AA AA 20          .byte   $AA,$AA,$AA,$20                 ; "*** "
000B8Cr 1  A0 C5 D2 D2          .byte   $A0,$C5,$D2,$D2,$0D             ; " ERR.\n"
000B90r 1  0D           
000B91r 1  BE B2 B5 35          .byte   $BE,$B2,$B5,$35                 ; ">255"
000B95r 1  D2 C1 CE C7          .byte   $D2,$C1,$CE,$C7,$45             ; RANGE"
000B99r 1  45           
000B9Ar 1  C4 C9 4D             .byte   $C4,$C9,$4D                     ; "DIM"
000B9Dr 1  D3 D4 D2 A0          .byte   $D3,$D4,$D2,$A0,$CF,$D6,$C6,$4C ; "STR OVFL"
000BA1r 1  CF D6 C6 4C  
000BA5r 1  DC 0D                .byte   $DC,$0D                         ; "\\\n"
000BA7r 1  D2 C5 D4 D9          .byte   $D2,$C5,$D4,$D9,$D0,$C5,$A0,$CC,$C9,$CE,$C5,$8D ; "RETYPE LINE\n"
000BABr 1  D0 C5 A0 CC  
000BAFr 1  C9 CE C5 8D  
000BB3r 1  3F                   .byte   $3F                             ; "?"
000BB4r 1  46 D9        Leb9a:  LSR     run_flag
000BB6r 1  90 03                BCC     Leba1
000BB8r 1  4C rr rr             JMP     Le8c3
000BBBr 1  A6 CF        Leba1:  LDX     acc+1
000BBDr 1  9A                   TXS
000BBEr 1  A6 CE                LDX     acc
000BC0r 1  A0 8D                LDY     #$8D
000BC2r 1  D0 02                BNE     Lebac
000BC4r 1               
000BC4r 1               ; token $54 - "INPUT" statement, numeric, no prompt
000BC4r 1  A0 99        input_num_stmt: LDY     #$99
000BC6r 1  20 rr rr     Lebac:  JSR     Se3c4
000BC9r 1  86 CE                STX     acc
000BCBr 1  BA                   TSX
000BCCr 1  86 CF                STX     acc+1
000BCEr 1  A0 FE                LDY     #$FE
000BD0r 1  84 D9                STY     run_flag
000BD2r 1  C8                   INY
000BD3r 1  84 C8                STY     text_index
000BD5r 1  20 rr rr             JSR     Se299
000BD8r 1  84 F1                STY     token_index
000BDAr 1  A2 20                LDX     #$20
000BDCr 1  A9 30                LDA     #$30
000BDEr 1  20 rr rr             JSR     Se491
000BE1r 1  E6 D9                INC     run_flag
000BE3r 1  A6 CE                LDX     acc
000BE5r 1               
000BE5r 1               ; token $27 - "," numeric input
000BE5r 1  A4 C8        input_num_comma:        LDY     text_index
000BE7r 1  0A                   ASL
000BE8r 1  85 CE        Lebce:  STA     acc
000BEAr 1  C8                   INY
000BEBr 1  B9 00 02             LDA     buffer,Y
000BEEr 1  C9 74                CMP     #$74
000BF0r 1  F0 D2                BEQ     input_num_stmt
000BF2r 1  49 B0                EOR     #$B0
000BF4r 1  C9 0A                CMP     #$0A
000BF6r 1  B0 F0                BCS     Lebce
000BF8r 1  C8                   INY
000BF9r 1  C8                   INY
000BFAr 1  84 C8                STY     text_index
000BFCr 1  B9 00 02             LDA     buffer,Y
000BFFr 1  48                   PHA
000C00r 1  B9 FF 01             LDA     buffer-1,Y
000C03r 1  A0 00                LDY     #$00
000C05r 1  20 rr rr             JSR     push_ya_noun_stk
000C08r 1  68                   PLA
000C09r 1  95 A0                STA     noun_stk_h_int,X
000C0Br 1  A5 CE                LDA     acc
000C0Dr 1  C9 C7                CMP     #$C7
000C0Fr 1  D0 03                BNE     Lebfa
000C11r 1  20 rr rr             JSR     negate
000C14r 1  4C rr rr     Lebfa:  JMP     var_assign
000C17r 1               
000C17r 1  FF FF FF 50          .byte   $FF,$FF,$FF,$50
000C1Br 1               
000C1Br 1  20 rr rr     Tec01:  JSR     Tec13
000C1Er 1  D0 15                BNE     Lec1b
000C20r 1               
000C20r 1  20 rr rr     Tec06:  JSR     Tec0b
000C23r 1  D0 10                BNE     Lec1b
000C25r 1               
000C25r 1  20 rr rr     Tec0b:  JSR     subtract
000C28r 1  20 rr rr             JSR     negate
000C2Br 1  50 03                BVC     Lec16
000C2Dr 1               
000C2Dr 1  20 rr rr     Tec13:  JSR     subtract
000C30r 1  20 rr rr     Lec16:  JSR     sgn_fn
000C33r 1  56 50                LSR     noun_stk_l,X
000C35r 1  4C rr rr     Lec1b:  JMP     not_op
000C38r 1               
000C38r 1  FF FF                .byte   $FF,$FF
000C3Ar 1               
000C3Ar 1               ; indexes into syntabl
000C3Ar 1               syntabl_index:
000C3Ar 1  C1 FF 7F D1          .byte   $C1,$FF,$7F,$D1,$CC,$C7,$CF,$CE ; "A..QLGON"
000C3Er 1  CC C7 CF CE  
000C42r 1  C5 9A 98 8B          .byte   $C5,$9A,$98,$8B,$96,$95,$93,$BF ; "E......?"
000C46r 1  96 95 93 BF  
000C4Ar 1  B2 32 2D 2B          .byte   $B2,$32,$2D,$2B,$BC,$B0,$AC,$BE ; "22-+<0,>"
000C4Er 1  BC B0 AC BE  
000C52r 1  35 8E 61 FF          .byte   $35,$8E,$61,$FF,$FF,$FF,$DD,$FB ; "5.a...]{"
000C56r 1  FF FF DD FB  
000C5Ar 1               
000C5Ar 1  20 rr rr     Tec40:  JSR     Sefc9
000C5Dr 1  15 4F                ORA     rnd+1,X
000C5Fr 1  10 05                BPL     Lec4c
000C61r 1               
000C61r 1  20 rr rr     Tec47:  JSR     Sefc9
000C64r 1  35 4F                AND     rnd+1,X
000C66r 1  95 50        Lec4c:  STA     noun_stk_l,X
000C68r 1  10 CB                BPL     Lec1b
000C6Ar 1  4C rr rr             JMP     Sefc9
000C6Dr 1  40 60 8D 60          .byte   $40,$60,$8D,$60,$8B,$00,$7E,$8C ; "@`.`..~."
000C71r 1  8B 00 7E 8C  
000C75r 1  33 00 00 60          .byte   $33,$00,$00,$60,$03,$BF,$12,$00 ; "3..`.?.."
000C79r 1  03 BF 12 00  
000C7Dr 1  40 89 C9 47          .byte   $40,$89,$C9,$47,$9D,$17,$68,$9D ; "@.IG..h."
000C81r 1  9D 17 68 9D  
000C85r 1  0A 00 40 60          .byte   $0A,$00,$40,$60,$8D,$60,$8B,$00 ; "..@`.`.."
000C89r 1  8D 60 8B 00  
000C8Dr 1  7E 8C 3C 00          .byte   $7E,$8C,$3C,$00,$00,$60,$03,$BF ; "~.<..`.?"
000C91r 1  00 60 03 BF  
000C95r 1  1B 4B 67 B4          .byte   $1B,$4B,$67,$B4,$A1,$07,$8C,$07 ; ".Kg4!..."
000C99r 1  A1 07 8C 07  
000C9Dr 1  AE A9 AC A8          .byte   $AE,$A9,$AC,$A8,$67,$8C,$07,$B4 ; ".),(g..4"
000CA1r 1  67 8C 07 B4  
000CA5r 1  AF AC B0 67          .byte   $AF,$AC,$B0,$67,$9D,$B2,$AF,$AC ; "/,0g.2/,"
000CA9r 1  9D B2 AF AC  
000CADr 1  AF A3 67 8C          .byte   $AF,$A3,$67,$8C,$07,$A5,$AB,$AF ; "/#g..%+/"
000CB1r 1  07 A5 AB AF  
000CB5r 1  B0 F4 AE A9          .byte   $B0,$F4,$AE,$A9,$B2,$B0,$7F,$0E ; "0t.)20.."
000CB9r 1  B2 B0 7F 0E  
000CBDr 1  27 B4 AE A9          .byte   $27,$B4,$AE,$A9,$B2,$B0,$7F,$0E ; "'4.)20.."
000CC1r 1  B2 B0 7F 0E  
000CC5r 1  28 B4 AE A9          .byte   $28,$B4,$AE,$A9,$B2,$B0,$64,$07 ; "(4.)20d."
000CC9r 1  B2 B0 64 07  
000CCDr 1  A6 A9 67 AF          .byte   $A6,$A9,$67,$AF,$B4,$AF,$A7,$78 ; "&)g/4/'x"
000CD1r 1  B4 AF A7 78  
000CD5r 1  B4 A5 AC 78          .byte   $B4,$A5,$AC,$78,$7F,$02,$AD,$A5 ; "4%,x..-%"
000CD9r 1  7F 02 AD A5  
000CDDr 1  B2 67 A2 B5          .byte   $B2,$67,$A2,$B5,$B3,$AF,$A7,$EE ; "2g"53/'n"
000CE1r 1  B3 AF A7 EE  
000CE5r 1  B2 B5 B4 A5          .byte   $B2,$B5,$B4,$A5,$B2,$7E,$8C,$39 ; "254%2~.9"
000CE9r 1  B2 7E 8C 39  
000CEDr 1  B4 B8 A5 AE          .byte   $B4,$B8,$A5,$AE,$67,$B0,$A5,$B4 ; "48%.g0%4"
000CF1r 1  67 B0 A5 B4  
000CF5r 1  B3 27 AF B4          .byte   $B3,$27,$AF,$B4,$07,$9D,$19,$B2 ; "3'/4...2"
000CF9r 1  07 9D 19 B2  
000CFDr 1  AF A6 7F 05          .byte   $AF,$A6,$7F,$05,$37,$B4,$B5,$B0 ; "/&..7450"
000D01r 1  37 B4 B5 B0  
000D05r 1  AE A9 7F 05          .byte   $AE,$A9,$7F,$05,$28,$B4,$B5,$B0 ; ".)..(450"
000D09r 1  28 B4 B5 B0  
000D0Dr 1  AE A9 7F 05          .byte   $AE,$A9,$7F,$05,$2A,$B4,$B5,$B0 ; ".)..*450"
000D11r 1  2A B4 B5 B0  
000D15r 1  AE A9 E4 AE          .byte   $AE,$A9,$E4,$AE,$A5,$00,$FF,$FF ; ".)d.%..."
000D19r 1  A5 00 FF FF  
000D1Dr 1               syntabl2:
000D1Dr 1  47 A2 A1 B4          .byte   $47,$A2,$A1,$B4,$7F,$0D,$30,$AD ; "G"!4..0-"
000D21r 1  7F 0D 30 AD  
000D25r 1  A9 A4 7F 0D          .byte   $A9,$A4,$7F,$0D,$23,$AD,$A9,$A4 ; ")$..#-)$"
000D29r 1  23 AD A9 A4  
000D2Dr 1  67 AC AC A1          .byte   $67,$AC,$AC,$A1,$A3,$00,$40,$80 ; "g,,!#.@."
000D31r 1  A3 00 40 80  
000D35r 1  C0 C1 80 00          .byte   $C0,$C1,$80,$00,$47,$8C,$68,$8C ; "@A..G.h."
000D39r 1  47 8C 68 8C  
000D3Dr 1  DB 67 9B 68          .byte   $DB,$67,$9B,$68,$9B,$50,$8C,$63 ; "[g.h.P.c"
000D41r 1  9B 50 8C 63  
000D45r 1  8C 7F 01 51          .byte   $8C,$7F,$01,$51,$07,$88,$29,$84 ; "...Q..)."
000D49r 1  07 88 29 84  
000D4Dr 1  80 C4 80 57          .byte   $80,$C4,$80,$57,$71,$07,$88,$14 ; ".D.Wq..."
000D51r 1  71 07 88 14  
000D55r 1  ED A5 AD AF          .byte   $ED,$A5,$AD,$AF,$AC,$ED,$A5,$AD ; "m%-/,m%-"
000D59r 1  AC ED A5 AD  
000D5Dr 1  A9 A8 F2 AF          .byte   $A9,$A8,$F2,$AF,$AC,$AF,$A3,$71 ; ")(r/,/#q"
000D61r 1  AC AF A3 71  
000D65r 1  08 88 AE A5          .byte   $08,$88,$AE,$A5,$AC,$68,$83,$08 ; "...%,h.."
000D69r 1  AC 68 83 08  
000D6Dr 1  68 9D 08 71          .byte   $68,$9D,$08,$71,$07,$88,$60,$76 ; "h..q..`v"
000D71r 1  07 88 60 76  
000D75r 1  B4 AF AE 76          .byte   $B4,$AF,$AE,$76,$8D,$76,$8B,$51 ; "4/.v.v.Q"
000D79r 1  8D 76 8B 51  
000D7Dr 1  07 88 19 B8          .byte   $07,$88,$19,$B8,$A4,$AE,$B2,$F2 ; "...8$.2r"
000D81r 1  A4 AE B2 F2  
000D85r 1  B3 B5 F3 A2          .byte   $B3,$B5,$F3,$A2,$A1,$EE,$A7,$B3 ; "35s"!n'3"
000D89r 1  A1 EE A7 B3  
000D8Dr 1  E4 AE B2 EB          .byte   $E4,$AE,$B2,$EB,$A5,$A5,$B0,$51 ; "d.2k%%0Q"
000D91r 1  A5 A5 B0 51  
000D95r 1  07 88 39 81          .byte   $07,$88,$39,$81,$C1,$4F,$7F,$0F ; "..9.AO.."
000D99r 1  C1 4F 7F 0F  
000D9Dr 1  2F 00 51 06          .byte   $2F,$00,$51,$06,$88,$29,$C2,$0C ; "/.Q..)B."
000DA1r 1  88 29 C2 0C  
000DA5r 1  82 57 8C 6A          .byte   $82,$57,$8C,$6A,$8C,$42,$AE,$A5 ; ".W.j.B.%"
000DA9r 1  8C 42 AE A5  
000DADr 1  A8 B4 60 AE          .byte   $A8,$B4,$60,$AE,$A5,$A8,$B4,$4F ; "(4`.%(4O"
000DB1r 1  A5 A8 B4 4F  
000DB5r 1  7E 1E 35 8C          .byte   $7E,$1E,$35,$8C,$27,$51,$07,$88 ; "~.5.'Q.."
000DB9r 1  27 51 07 88  
000DBDr 1  09 8B FE E4          .byte   $09,$8B,$FE,$E4,$AF,$AD,$F2,$AF ; "..~d/-r/"
000DC1r 1  AF AD F2 AF  
000DC5r 1  E4 AE A1 DC          .byte   $E4,$AE,$A1,$DC,$DE,$9C,$DD,$9C ; "d.!\^.]."
000DC9r 1  DE 9C DD 9C  
000DCDr 1  DE DD 9E C3          .byte   $DE,$DD,$9E,$C3,$DD,$CF,$CA,$CD ; "^].C]OJM"
000DD1r 1  DD CF CA CD  
000DD5r 1  CB 00 47 9D          .byte   $CB,$00,$47,$9D,$AD,$A5,$AD,$AF ; "K.G.-%-/"
000DD9r 1  AD A5 AD AF  
000DDDr 1  AC 76 9D AD          .byte   $AC,$76,$9D,$AD,$A5,$AD,$A9,$A8 ; ",v.-%-)("
000DE1r 1  A5 AD A9 A8  
000DE5r 1  E6 A6 AF 60          .byte   $E6,$A6,$AF,$60,$8C,$20,$AF,$B4 ; "f&/`. /4"
000DE9r 1  8C 20 AF B4  
000DEDr 1  B5 A1 F2 AC          .byte   $B5,$A1,$F2,$AC,$A3,$F2,$A3,$B3 ; "5!r,#r#3"
000DF1r 1  A3 F2 A3 B3  
000DF5r 1  60 8C 20 AC          .byte   $60,$8C,$20,$AC,$A5,$A4,$EE,$B5 ; "`. ,%$n5"
000DF9r 1  A5 A4 EE B5  
000DFDr 1  B2 60 AE B5          .byte   $B2,$60,$AE,$B5,$B2,$F4,$B3,$A9 ; "2`.52t3)"
000E01r 1  B2 F4 B3 A9  
000E05r 1  AC 60 8C 20          .byte   $AC,$60,$8C,$20,$B4,$B3,$A9,$AC ; ",`. 43),"
000E09r 1  B4 B3 A9 AC  
000E0Dr 1  7A 7E 9A 22          .byte   $7A,$7E,$9A,$22,$20,$00,$60,$03 ; "z~." .`."
000E11r 1  20 00 60 03  
000E15r 1  BF 60 03 BF          .byte   $BF,$60,$03,$BF,$1F             ; "?`.?."
000E19r 1  1F           
000E1Ar 1               
000E1Ar 1               ; token $48 - "," string output
000E1Ar 1  20 rr rr     print_str_comma:        JSR     tabout
000E1Dr 1               
000E1Dr 1               ; token $45 - ";" string output
000E1Dr 1               ; token $61 - "PRINT" string
000E1Dr 1  E8           print_str:      INX
000E1Er 1  E8                   INX
000E1Fr 1  B5 4F                LDA     rnd+1,X
000E21r 1  85 DA                STA     aux
000E23r 1  B5 77                LDA     syn_stk_h+31,X
000E25r 1  85 DB                STA     aux+1
000E27r 1  B4 4E                LDY     rnd,X
000E29r 1  98           Lee0f:  TYA
000E2Ar 1  D5 76                CMP     syn_stk_h+30,X
000E2Cr 1  B0 09                BCS     Lee1d
000E2Er 1  B1 DA                LDA     (aux),Y
000E30r 1  20 rr rr             JSR     cout
000E33r 1  C8                   INY
000E34r 1  4C rr rr             JMP     Lee0f
000E37r 1  A9 FF        Lee1d:  LDA     #$FF
000E39r 1  85 D5                STA     cr_flag
000E3Br 1  60                   RTS
000E3Cr 1               
000E3Cr 1               ; token $3B - "LEN(" function
000E3Cr 1  E8           len_fn: INX
000E3Dr 1  A9 00                LDA     #$00
000E3Fr 1  95 78                STA     noun_stk_h_str,X
000E41r 1  95 A0                STA     noun_stk_h_int,X
000E43r 1  B5 77                LDA     syn_stk_h+31,X
000E45r 1  38                   SEC
000E46r 1  F5 4F                SBC     rnd+1,X
000E48r 1  95 50                STA     noun_stk_l,X
000E4Ar 1  4C rr rr             JMP     left_paren
000E4Dr 1               
000E4Dr 1  FF                   .byte   $FF
000E4Er 1               
000E4Er 1  20 rr rr     getbyte:        JSR     get16bit
000E51r 1  A5 CF                LDA     acc+1
000E53r 1  D0 28                BNE     gr_255_err
000E55r 1  A5 CE                LDA     acc
000E57r 1  60                   RTS
000E58r 1               
000E58r 1               ; token $68 - "," for PLOT statement (???)
000E58r 1  20 rr rr     plot_comma:     JSR     getbyte
000E5Br 1  A4 C8                LDY     text_index
000E5Dr 1  C9 30                CMP     #$30
000E5Fr 1  B0 21                BCS     range_err
000E61r 1  C0 28                CPY     #$28
000E63r 1  B0 1D                BCS     range_err
000E65r 1  60                   RTS
000E66r 1  EA                   NOP
000E67r 1  EA                   NOP
000E68r 1               
000E68r 1  20 rr rr     Tee4e:  JSR     getbyte
000E6Br 1  60                   RTS
000E6Cr 1  EA                   NOP
000E6Dr 1  8A           Tee5e:  TXA
000E6Er 1  A2 01                LDX     #$01
000E70r 1  B4 CE        l123:   LDY     acc,X
000E72r 1  94 4C                STY     himem,X
000E74r 1  B4 48                LDY     var,X
000E76r 1  94 CA                STY     pp,X
000E78r 1  CA                   DEX
000E79r 1  F0 F5                BEQ     l123
000E7Br 1  AA                   TAX
000E7Cr 1  60                   RTS
000E7Dr 1  A0 77        gr_255_err:     LDY     #$77            ; > 255 error
000E7Fr 1  4C rr rr     go_errmess_5:   JMP     print_err_msg
000E82r 1  A0 7B        range_err:      LDY     #$7B            ; range error
000E84r 1  D0 F9                BNE     go_errmess_5
000E86r 1               
000E86r 1  20 rr rr     See6c:  JSR     Se254
000E89r 1  A5 DA                LDA     aux
000E8Br 1  D0 07                BNE     Lee7a
000E8Dr 1  A5 DB                LDA     aux+1
000E8Fr 1  D0 03                BNE     Lee7a
000E91r 1  4C rr rr             JMP     Le77e
000E94r 1  06 CE        Lee7a:  ASL     acc
000E96r 1  26 CF                ROL     acc+1
000E98r 1  26 E6                ROL     p3
000E9Ar 1  26 E7                ROL     p3+1
000E9Cr 1  A5 E6                LDA     p3
000E9Er 1  C5 DA                CMP     aux
000EA0r 1  A5 E7                LDA     p3+1
000EA2r 1  E5 DB                SBC     aux+1
000EA4r 1  90 0A                BCC     Lee96
000EA6r 1  85 E7                STA     p3+1
000EA8r 1  A5 E6                LDA     p3
000EAAr 1  E5 DA                SBC     aux
000EACr 1  85 E6                STA     p3
000EAEr 1  E6 CE                INC     acc
000EB0r 1  88           Lee96:  DEY
000EB1r 1  D0 E1                BNE     Lee7a
000EB3r 1  60                   RTS
000EB4r 1               
000EB4r 1  FF FF FF FF          .byte   $FF,$FF,$FF,$FF,$FF,$FF
000EB8r 1  FF FF        
000EBAr 1               
000EBAr 1               ; token $4D - "CALL" statement
000EBAr 1  20 rr rr     call_stmt:      JSR     get16bit
000EBDr 1  6C CE 00             JMP     (acc)
000EC0r 1  A5 4C        l1233:  LDA     himem
000EC2r 1  D0 02                BNE     l1235
000EC4r 1  C6 4D                DEC     himem+1
000EC6r 1  C6 4C        l1235:  DEC     himem
000EC8r 1  A5 48                LDA     var
000ECAr 1  D0 02                BNE     l1236
000ECCr 1  C6 49                DEC     var+1
000ECEr 1  C6 48        l1236:  DEC     var
000ED0r 1  A0 00        l1237:  LDY     #$00
000ED2r 1  B1 4C                LDA     (himem),Y
000ED4r 1  91 48                STA     (var),Y
000ED6r 1  A5 CA                LDA     pp
000ED8r 1  C5 4C                CMP     himem
000EDAr 1  A5 CB                LDA     pp+1
000EDCr 1  E5 4D                SBC     himem+1
000EDEr 1  90 E0                BCC     l1233
000EE0r 1  4C rr rr             JMP     Tee5e
000EE3r 1  C9 28                CMP     #$28
000EE5r 1  B0 9B        Leecb:  BCS     range_err
000EE7r 1  A8                   TAY
000EE8r 1  A5 C8                LDA     text_index
000EEAr 1  60                   RTS
000EEBr 1  EA                   NOP
000EECr 1  EA                   NOP
000EEDr 1               
000EEDr 1               print_err_msg1:
000EEDr 1  98                   TYA
000EEEr 1  AA                   TAX
000EEFr 1  A0 6E                LDY     #$6E
000EF1r 1  20 rr rr             JSR     Se3c4
000EF4r 1  8A                   TXA
000EF5r 1  A8                   TAY
000EF6r 1  20 rr rr             JSR     Se3c4
000EF9r 1  A0 72                LDY     #$72
000EFBr 1  4C rr rr             JMP     Se3c4
000EFEr 1               
000EFEr 1  20 rr rr     Seee4:  JSR     get16bit
000F01r 1  06 CE        Leee7:  ASL     acc
000F03r 1  26 CF                ROL     acc+1
000F05r 1  30 FA                BMI     Leee7
000F07r 1  B0 DC                BCS     Leecb
000F09r 1  D0 04                BNE     Leef5
000F0Br 1  C5 CE                CMP     acc
000F0Dr 1  B0 D6                BCS     Leecb
000F0Fr 1  60           Leef5:  RTS
000F10r 1               
000F10r 1               ; token $2E - "PEEK" fn (uses $3F left paren)
000F10r 1  20 rr rr     peek_fn:        JSR     get16bit
000F13r 1  B1 CE                LDA     (acc),Y
000F15r 1  94 9F                STY     syn_stk_l+31,X
000F17r 1  4C rr rr             JMP     push_ya_noun_stk
000F1Ar 1               
000F1Ar 1               ; token $65 - "," for POKE statement
000F1Ar 1  20 rr rr     poke_stmt:      JSR     getbyte
000F1Dr 1  A5 CE                LDA     acc
000F1Fr 1  48                   PHA
000F20r 1  20 rr rr             JSR     get16bit
000F23r 1  68                   PLA
000F24r 1  91 CE                STA     (acc),Y
000F26r 1               
000F26r 1  60           Tef0c:  RTS
000F27r 1               
000F27r 1  FF FF FF             .byte   $FF,$FF,$FF
000F2Ar 1               
000F2Ar 1               ; token $15 - "/" for numeric division
000F2Ar 1  20 rr rr     divide: JSR     See6c
000F2Dr 1  A5 CE                LDA     acc
000F2Fr 1  85 E6                STA     p3
000F31r 1  A5 CF                LDA     acc+1
000F33r 1  85 E7                STA     p3+1
000F35r 1  4C rr rr             JMP     Le244
000F38r 1               
000F38r 1               ; token $44 - "," next var in DIM statement is numeric
000F38r 1               ; token $4F - "DIM", next var is numeric
000F38r 1  20 rr rr     dim_num:        JSR     Seee4
000F3Br 1  4C rr rr             JMP     Le134
000F3Er 1               
000F3Er 1               ; token $2D - "(" for numeric array subscript
000F3Er 1  20 rr rr     num_array_subs: JSR     Seee4
000F41r 1  B4 78                LDY     noun_stk_h_str,X
000F43r 1  B5 50                LDA     noun_stk_l,X
000F45r 1  69 FE                ADC     #$FE
000F47r 1  B0 01                BCS     Lef30
000F49r 1  88                   DEY
000F4Ar 1  85 DA        Lef30:  STA     aux
000F4Cr 1  84 DB                STY     aux+1
000F4Er 1  18                   CLC
000F4Fr 1  65 CE                ADC     acc
000F51r 1  95 50                STA     noun_stk_l,X
000F53r 1  98                   TYA
000F54r 1  65 CF                ADC     acc+1
000F56r 1  95 78                STA     noun_stk_h_str,X
000F58r 1  A0 00                LDY     #$00
000F5Ar 1  B5 50                LDA     noun_stk_l,X
000F5Cr 1  D1 DA                CMP     (aux),Y
000F5Er 1  C8                   INY
000F5Fr 1  B5 78                LDA     noun_stk_h_str,X
000F61r 1  F1 DA                SBC     (aux),Y
000F63r 1  B0 80                BCS     Leecb
000F65r 1  4C rr rr             JMP     left_paren
000F68r 1               
000F68r 1               ; token $2F - "RND" fn (uses $3F left paren)
000F68r 1  20 rr rr     rnd_fn: JSR     get16bit
000F6Br 1  A5 4E                LDA     rnd
000F6Dr 1  20 rr rr             JSR     push_ya_noun_stk
000F70r 1  A5 4F                LDA     rnd+1
000F72r 1  D0 04                BNE     Lef5e
000F74r 1  C5 4E                CMP     rnd
000F76r 1  69 00                ADC     #$00
000F78r 1  29 7F        Lef5e:  AND     #$7F
000F7Ar 1  85 4F                STA     rnd+1
000F7Cr 1  95 A0                STA     noun_stk_h_int,X
000F7Er 1  A0 11                LDY     #$11
000F80r 1  A5 4F        Lef66:  LDA     rnd+1
000F82r 1  0A                   ASL
000F83r 1  18                   CLC
000F84r 1  69 40                ADC     #$40
000F86r 1  0A                   ASL
000F87r 1  26 4E                ROL     rnd
000F89r 1  26 4F                ROL     rnd+1
000F8Br 1  88                   DEY
000F8Cr 1  D0 F2                BNE     Lef66
000F8Er 1  A5 CE                LDA     acc
000F90r 1  20 rr rr             JSR     push_ya_noun_stk
000F93r 1  A5 CF                LDA     acc+1
000F95r 1  95 A0                STA     noun_stk_h_int,X
000F97r 1  4C rr rr             JMP     mod_op
000F9Ar 1               
000F9Ar 1  20 rr rr     Tef80:  JSR     get16bit
000F9Dr 1  A4 CE                LDY     acc
000F9Fr 1  C4 4C                CPY     himem
000FA1r 1  A5 CF                LDA     acc+1
000FA3r 1  E5 4D                SBC     himem+1
000FA5r 1  90 1F                BCC     Lefab
000FA7r 1  84 48                STY     var
000FA9r 1  A5 CF                LDA     acc+1
000FABr 1  85 49                STA     var+1
000FADr 1  4C rr rr     Lef93:  JMP     l1237
000FB0r 1               
000FB0r 1  20 rr rr     Tef96:  JSR     get16bit
000FB3r 1  A4 CE                LDY     acc
000FB5r 1  C4 CA                CPY     pp
000FB7r 1  A5 CF                LDA     acc+1
000FB9r 1  E5 CB                SBC     pp+1
000FBBr 1  B0 09                BCS     Lefab
000FBDr 1  84 4A                STY     lomem
000FBFr 1  A5 CF                LDA     acc+1
000FC1r 1  85 4B                STA     lomem+1
000FC3r 1  4C rr rr             JMP     clr
000FC6r 1  4C rr rr     Lefab:  JMP     Leecb
000FC9r 1  EA                   NOP
000FCAr 1  EA                   NOP
000FCBr 1  EA                   NOP
000FCCr 1  EA                   NOP
000FCDr 1  20 rr rr     Lefb3:  JSR     Sefc9
000FD0r 1               
000FD0r 1               ; token $26 - "," for string input
000FD0r 1               ; token $52 - "INPUT" statement for string
000FD0r 1  20 rr rr     string_input:   JSR     input_str
000FD3r 1  4C rr rr             JMP     Lefbf
000FD6r 1               
000FD6r 1               ; token $53 - "INPUT" with literal string prompt
000FD6r 1  20 rr rr     input_prompt:   JSR     print_str
000FD9r 1  A9 FF        Lefbf:  LDA     #$FF
000FDBr 1  85 C8                STA     text_index
000FDDr 1  A9 74                LDA     #$74
000FDFr 1  8D 00 02             STA     buffer
000FE2r 1  60                   RTS
000FE3r 1               
000FE3r 1  20 rr rr     Sefc9:  JSR     not_op
000FE6r 1  E8                   INX
000FE7r 1               
000FE7r 1  20 rr rr     Sefcd:  JSR     not_op
000FEAr 1  B5 50                LDA     noun_stk_l,X
000FECr 1  60                   RTS
000FEDr 1               
000FEDr 1               ; memory initialization for 4K RAM
000FEDr 1  A9 00        mem_init_4k:    LDA     #$00
000FEFr 1  85 4A                STA     lomem
000FF1r 1  85 4C                STA     himem
000FF3r 1  A9 08                LDA     #$08
000FF5r 1  85 4B                STA     lomem+1         ; LOMEM defaults to $0800
000FF7r 1  A9 10                LDA     #$10
000FF9r 1  85 4D                STA     himem+1         ; HIMEM defaults to $1000
000FFBr 1  4C rr rr             JMP     new_cmd
000FFEr 1               
000FFEr 1  D5 78        Sefe4:  CMP     noun_stk_h_str,X
001000r 1  D0 01                BNE     Lefe9
001002r 1  18                   CLC
001003r 1  4C rr rr     Lefe9:  JMP     Le102
001006r 1               
001006r 1  20 rr rr     Tefec:  JSR     clr
001009r 1  4C rr rr             JMP     run_warm
00100Cr 1               
00100Cr 1  20 rr rr     Teff2:  JSR     clr
00100Fr 1  4C rr rr             JMP     goto_stmt
001012r 1               
001012r 1  E0 80        Seff8:  CPX     #$80
001014r 1  D0 01                BNE     Leffd
001016r 1  88                   DEY
001017r 1  4C rr rr     Leffd:  JMP     Se00c
001017r 1               
