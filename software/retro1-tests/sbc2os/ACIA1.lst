ca65 V2.15 - Git f7cdfbf
Main file   : ACIA1.asm
Current file: ACIA1.asm

000000r 1               .include "basic.asm"
000000r 2               
000000r 2               ; Enhanced BASIC to assemble under 6502 simulator, $ver 2.22
000000r 2               
000000r 2               ; $E7E1 $E7CF $E7C6 $E7D3 $E7D1 $E7D5 $E7CF $E81E $E825
000000r 2               
000000r 2               ; 2.00	new revision numbers start here
000000r 2               ; 2.01	fixed LCASE$() and UCASE$()
000000r 2               ; 2.02	new get value routine done
000000r 2               ; 2.03	changed RND() to galoise method
000000r 2               ; 2.04	fixed SPC()
000000r 2               ; 2.05	new get value routine fixed
000000r 2               ; 2.06	changed USR() code
000000r 2               ; 2.07	fixed STR$()
000000r 2               ; 2.08	changed INPUT and READ to remove need for $00 start to input buffer
000000r 2               ; 2.09	fixed RND()
000000r 2               ; 2.10	integrated missed changes from an earlier version
000000r 2               ; 2.20	added ELSE to IF .. THEN and fixed IF .. GOTO <statement> to cause error
000000r 2               ; 2.21	fixed IF .. THEN RETURN to not cause error
000000r 2               ; 2.22	fixed RND() breaking the get byte routine
000000r 2               
000000r 2               ; zero page use ..
000000r 2               
000000r 2               LAB_WARM 		= $00		; BASIC warm start entry point
000000r 2               Wrmjpl 		= LAB_WARM+1; BASIC warm start vector jump low byte
000000r 2               Wrmjph 		= LAB_WARM+2; BASIC warm start vector jump high byte
000000r 2               
000000r 2               Usrjmp		= $0A		; USR function JMP address
000000r 2               Usrjpl		= Usrjmp+1	; USR function JMP vector low byte
000000r 2               Usrjph		= Usrjmp+2	; USR function JMP vector high byte
000000r 2               Nullct		= $0D		; nulls output after each line
000000r 2               TPos			= $0E		; BASIC terminal position byte
000000r 2               TWidth		= $0F		; BASIC terminal width byte
000000r 2               Iclim			= $10		; input column limit
000000r 2               Itempl		= $11		; temporary integer low byte
000000r 2               Itemph		= Itempl+1	; temporary integer high byte
000000r 2               
000000r 2               nums_1		= Itempl	; number to bin/hex string convert MSB
000000r 2               nums_2		= nums_1+1	; number to bin/hex string convert
000000r 2               nums_3		= nums_1+2	; number to bin/hex string convert LSB
000000r 2               
000000r 2               Srchc			= $5B		; search character
000000r 2               Temp3			= Srchc	; temp byte used in number routines
000000r 2               Scnquo		= $5C		; scan-between-quotes flag
000000r 2               Asrch			= Scnquo	; alt search character
000000r 2               
000000r 2               XOAw_l		= Srchc	; eXclusive OR, OR and AND word low byte
000000r 2               XOAw_h		= Scnquo	; eXclusive OR, OR and AND word high byte
000000r 2               
000000r 2               Ibptr			= $5D		; input buffer pointer
000000r 2               Dimcnt		= Ibptr	; # of dimensions
000000r 2               Tindx			= Ibptr	; token index
000000r 2               
000000r 2               Defdim		= $5E		; default DIM flag
000000r 2               Dtypef		= $5F		; data type flag, $FF=string, $00=numeric
000000r 2               Oquote		= $60		; open quote flag (b7) (Flag: DATA scan; LIST quote; memory)
000000r 2               Gclctd		= $60		; garbage collected flag
000000r 2               Sufnxf		= $61		; subscript/FNX flag, 1xxx xxx = FN(0xxx xxx)
000000r 2               Imode			= $62		; input mode flag, $00=INPUT, $80=READ
000000r 2               
000000r 2               Cflag			= $63		; comparison evaluation flag
000000r 2               
000000r 2               TabSiz		= $64		; TAB step size (was input flag)
000000r 2               
000000r 2               next_s		= $65		; next descriptor stack address
000000r 2               
000000r 2               					; these two bytes form a word pointer to the item
000000r 2               					; currently on top of the descriptor stack
000000r 2               last_sl		= $66		; last descriptor stack address low byte
000000r 2               last_sh		= $67		; last descriptor stack address high byte (always $00)
000000r 2               
000000r 2               des_sk		= $68		; descriptor stack start address (temp strings)
000000r 2               
000000r 2               ;			= $70		; End of descriptor stack
000000r 2               
000000r 2               ut1_pl		= $71		; utility pointer 1 low byte
000000r 2               ut1_ph		= ut1_pl+1	; utility pointer 1 high byte
000000r 2               ut2_pl		= $73		; utility pointer 2 low byte
000000r 2               ut2_ph		= ut2_pl+1	; utility pointer 2 high byte
000000r 2               
000000r 2               Temp_2		= ut1_pl	; temp byte for block move
000000r 2               
000000r 2               FACt_1		= $75		; FAC temp mantissa1
000000r 2               FACt_2		= FACt_1+1	; FAC temp mantissa2
000000r 2               FACt_3		= FACt_2+1	; FAC temp mantissa3
000000r 2               
000000r 2               dims_l		= FACt_2	; array dimension size low byte
000000r 2               dims_h		= FACt_3	; array dimension size high byte
000000r 2               
000000r 2               TempB			= $78		; temp page 0 byte
000000r 2               
000000r 2               Smeml			= $79		; start of mem low byte		(Start-of-Basic)
000000r 2               Smemh			= Smeml+1	; start of mem high byte	(Start-of-Basic)
000000r 2               Svarl			= $7B		; start of vars low byte	(Start-of-Variables)
000000r 2               Svarh			= Svarl+1	; start of vars high byte	(Start-of-Variables)
000000r 2               Sarryl		= $7D		; var mem end low byte		(Start-of-Arrays)
000000r 2               Sarryh		= Sarryl+1	; var mem end high byte		(Start-of-Arrays)
000000r 2               Earryl		= $7F		; array mem end low byte	(End-of-Arrays)
000000r 2               Earryh		= Earryl+1	; array mem end high byte	(End-of-Arrays)
000000r 2               Sstorl		= $81		; string storage low byte	(String storage (moving down))
000000r 2               Sstorh		= Sstorl+1	; string storage high byte	(String storage (moving down))
000000r 2               Sutill		= $83		; string utility ptr low byte
000000r 2               Sutilh		= Sutill+1	; string utility ptr high byte
000000r 2               Ememl			= $85		; end of mem low byte		(Limit-of-memory)
000000r 2               Ememh			= Ememl+1	; end of mem high byte		(Limit-of-memory)
000000r 2               Clinel		= $87		; current line low byte		(Basic line number)
000000r 2               Clineh		= Clinel+1	; current line high byte	(Basic line number)
000000r 2               Blinel		= $89		; break line low byte		(Previous Basic line number)
000000r 2               Blineh		= Blinel+1	; break line high byte		(Previous Basic line number)
000000r 2               
000000r 2               Cpntrl		= $8B		; continue pointer low byte
000000r 2               Cpntrh		= Cpntrl+1	; continue pointer high byte
000000r 2               
000000r 2               Dlinel		= $8D		; current DATA line low byte
000000r 2               Dlineh		= Dlinel+1	; current DATA line high byte
000000r 2               
000000r 2               Dptrl			= $8F		; DATA pointer low byte
000000r 2               Dptrh			= Dptrl+1	; DATA pointer high byte
000000r 2               
000000r 2               Rdptrl		= $91		; read pointer low byte
000000r 2               Rdptrh		= Rdptrl+1	; read pointer high byte
000000r 2               
000000r 2               Varnm1		= $93		; current var name 1st byte
000000r 2               Varnm2		= Varnm1+1	; current var name 2nd byte
000000r 2               
000000r 2               Cvaral		= $95		; current var address low byte
000000r 2               Cvarah		= Cvaral+1	; current var address high byte
000000r 2               
000000r 2               Frnxtl		= $97		; var pointer for FOR/NEXT low byte
000000r 2               Frnxth		= Frnxtl+1	; var pointer for FOR/NEXT high byte
000000r 2               
000000r 2               Tidx1			= Frnxtl	; temp line index
000000r 2               
000000r 2               Lvarpl		= Frnxtl	; let var pointer low byte
000000r 2               Lvarph		= Frnxth	; let var pointer high byte
000000r 2               
000000r 2               prstk			= $99		; precedence stacked flag
000000r 2               
000000r 2               comp_f		= $9B		; compare function flag, bits 0,1 and 2 used
000000r 2               					; bit 2 set if >
000000r 2               					; bit 1 set if =
000000r 2               					; bit 0 set if <
000000r 2               
000000r 2               func_l		= $9C		; function pointer low byte
000000r 2               func_h		= func_l+1	; function pointer high byte
000000r 2               
000000r 2               garb_l		= func_l	; garbage collection working pointer low byte
000000r 2               garb_h		= func_h	; garbage collection working pointer high byte
000000r 2               
000000r 2               des_2l		= $9E		; string descriptor_2 pointer low byte
000000r 2               des_2h		= des_2l+1	; string descriptor_2 pointer high byte
000000r 2               
000000r 2               g_step		= $A0		; garbage collect step size
000000r 2               
000000r 2               Fnxjmp		= $A1		; jump vector for functions
000000r 2               Fnxjpl		= Fnxjmp+1	; functions jump vector low byte
000000r 2               Fnxjph		= Fnxjmp+2	; functions jump vector high byte
000000r 2               
000000r 2               g_indx		= Fnxjpl	; garbage collect temp index
000000r 2               
000000r 2               FAC2_r		= $A3		; FAC2 rounding byte
000000r 2               
000000r 2               Adatal		= $A4		; array data pointer low byte
000000r 2               Adatah		= Adatal+1	; array data pointer high  byte
000000r 2               
000000r 2               Nbendl		= Adatal	; new block end pointer low byte
000000r 2               Nbendh		= Adatah	; new block end pointer high  byte
000000r 2               
000000r 2               Obendl		= $A6		; old block end pointer low byte
000000r 2               Obendh		= Obendl+1	; old block end pointer high  byte
000000r 2               
000000r 2               numexp		= $A8		; string to float number exponent count
000000r 2               expcnt		= $A9		; string to float exponent count
000000r 2               
000000r 2               numbit		= numexp	; bit count for array element calculations
000000r 2               
000000r 2               numdpf		= $AA		; string to float decimal point flag
000000r 2               expneg		= $AB		; string to float eval exponent -ve flag
000000r 2               
000000r 2               Astrtl		= numdpf	; array start pointer low byte
000000r 2               Astrth		= expneg	; array start pointer high  byte
000000r 2               
000000r 2               Histrl		= numdpf	; highest string low byte
000000r 2               Histrh		= expneg	; highest string high  byte
000000r 2               
000000r 2               Baslnl		= numdpf	; BASIC search line pointer low byte
000000r 2               Baslnh		= expneg	; BASIC search line pointer high  byte
000000r 2               
000000r 2               Fvar_l		= numdpf	; find/found variable pointer low byte
000000r 2               Fvar_h		= expneg	; find/found variable pointer high  byte
000000r 2               
000000r 2               Ostrtl		= numdpf	; old block start pointer low byte
000000r 2               Ostrth		= expneg	; old block start pointer high  byte
000000r 2               
000000r 2               Vrschl		= numdpf	; variable search pointer low byte
000000r 2               Vrschh		= expneg	; variable search pointer high  byte
000000r 2               
000000r 2               FAC1_e		= $AC		; FAC1 exponent
000000r 2               FAC1_1		= FAC1_e+1	; FAC1 mantissa1
000000r 2               FAC1_2		= FAC1_e+2	; FAC1 mantissa2
000000r 2               FAC1_3		= FAC1_e+3	; FAC1 mantissa3
000000r 2               FAC1_s		= FAC1_e+4	; FAC1 sign (b7)
000000r 2               
000000r 2               str_ln		= FAC1_e	; string length
000000r 2               str_pl		= FAC1_1	; string pointer low byte
000000r 2               str_ph		= FAC1_2	; string pointer high byte
000000r 2               
000000r 2               des_pl		= FAC1_2	; string descriptor pointer low byte
000000r 2               des_ph		= FAC1_3	; string descriptor pointer high byte
000000r 2               
000000r 2               mids_l		= FAC1_3	; MID$ string temp length byte
000000r 2               
000000r 2               negnum		= $B1		; string to float eval -ve flag
000000r 2               numcon		= $B1		; series evaluation constant count
000000r 2               
000000r 2               FAC1_o		= $B2		; FAC1 overflow byte
000000r 2               
000000r 2               FAC2_e		= $B3		; FAC2 exponent
000000r 2               FAC2_1		= FAC2_e+1	; FAC2 mantissa1
000000r 2               FAC2_2		= FAC2_e+2	; FAC2 mantissa2
000000r 2               FAC2_3		= FAC2_e+3	; FAC2 mantissa3
000000r 2               FAC2_s		= FAC2_e+4	; FAC2 sign (b7)
000000r 2               
000000r 2               FAC_sc		= $B8		; FAC sign comparison, Acc#1 vs #2
000000r 2               FAC1_r		= $B9		; FAC1 rounding byte
000000r 2               
000000r 2               ssptr_l		= FAC_sc	; string start pointer low byte
000000r 2               ssptr_h		= FAC1_r	; string start pointer high byte
000000r 2               
000000r 2               sdescr		= FAC_sc	; string descriptor pointer
000000r 2               
000000r 2               csidx			= $BA		; line crunch save index
000000r 2               Asptl			= csidx	; array size/pointer low byte
000000r 2               Aspth			= $BB		; array size/pointer high byte
000000r 2               
000000r 2               Btmpl			= Asptl	; BASIC pointer temp low byte
000000r 2               Btmph			= Aspth	; BASIC pointer temp low byte
000000r 2               
000000r 2               Cptrl			= Asptl	; BASIC pointer temp low byte
000000r 2               Cptrh			= Aspth	; BASIC pointer temp low byte
000000r 2               
000000r 2               Sendl			= Asptl	; BASIC pointer temp low byte
000000r 2               Sendh			= Aspth	; BASIC pointer temp low byte
000000r 2               
000000r 2               LAB_IGBY		= $BC		; get next BASIC byte subroutine
000000r 2               
000000r 2               LAB_GBYT		= $C2		; get current BASIC byte subroutine
000000r 2               Bpntrl		= $C3		; BASIC execute (get byte) pointer low byte
000000r 2               Bpntrh		= Bpntrl+1	; BASIC execute (get byte) pointer high byte
000000r 2               
000000r 2               ;			= $D7		; end of get BASIC char subroutine
000000r 2               
000000r 2               Rbyte4		= $D8		; extra PRNG byte
000000r 2               Rbyte1		= Rbyte4+1	; most significant PRNG byte
000000r 2               Rbyte2		= Rbyte4+2	; middle PRNG byte
000000r 2               Rbyte3		= Rbyte4+3	; least significant PRNG byte
000000r 2               
000000r 2               NmiBase		= $DC		; NMI handler enabled/setup/triggered flags
000000r 2               					; bit	function
000000r 2               					; ===	========
000000r 2               					; 7	interrupt enabled
000000r 2               					; 6	interrupt setup
000000r 2               					; 5	interrupt happened
000000r 2               ;			= $DD		; NMI handler addr low byte
000000r 2               ;			= $DE		; NMI handler addr high byte
000000r 2               IrqBase		= $DF		; IRQ handler enabled/setup/triggered flags
000000r 2               ;			= $E0		; IRQ handler addr low byte
000000r 2               ;			= $E1		; IRQ handler addr high byte
000000r 2               
000000r 2               ;			= $DE		; unused
000000r 2               ;			= $DF		; unused
000000r 2               ;			= $E0		; unused
000000r 2               ;			= $E1		; unused
000000r 2               ;			= $E2		; unused
000000r 2               ;			= $E3		; unused
000000r 2               ;			= $E4		; unused
000000r 2               ;			= $E5		; unused
000000r 2               ;			= $E6		; unused
000000r 2               ;			= $E7		; unused
000000r 2               ;			= $E8		; unused
000000r 2               ;			= $E9		; unused
000000r 2               ;			= $EA		; unused
000000r 2               ;			= $EB		; unused
000000r 2               ;			= $EC		; unused
000000r 2               ;			= $ED		; unused
000000r 2               ;			= $EE		; unused
000000r 2               
000000r 2               Decss			= $EF		; number to decimal string start
000000r 2               Decssp1		= Decss+1	; number to decimal string start
000000r 2               
000000r 2               ;			= $FF		; decimal string end
000000r 2               
000000r 2               ; token values needed for BASIC
000000r 2               
000000r 2               ; primary command tokens (can start a statement)
000000r 2               
000000r 2               TK_END		= $80			; END token
000000r 2               TK_FOR		= TK_END+1		; FOR token
000000r 2               TK_NEXT		= TK_FOR+1		; NEXT token
000000r 2               TK_DATA		= TK_NEXT+1		; DATA token
000000r 2               TK_INPUT		= TK_DATA+1		; INPUT token
000000r 2               TK_DIM		= TK_INPUT+1	; DIM token
000000r 2               TK_READ		= TK_DIM+1		; READ token
000000r 2               TK_LET		= TK_READ+1		; LET token
000000r 2               TK_DEC		= TK_LET+1		; DEC token
000000r 2               TK_GOTO		= TK_DEC+1		; GOTO token
000000r 2               TK_RUN		= TK_GOTO+1		; RUN token
000000r 2               TK_IF			= TK_RUN+1		; IF token
000000r 2               TK_RESTORE		= TK_IF+1		; RESTORE token
000000r 2               TK_GOSUB		= TK_RESTORE+1	; GOSUB token
000000r 2               TK_RETIRQ		= TK_GOSUB+1	; RETIRQ token
000000r 2               TK_RETNMI		= TK_RETIRQ+1	; RETNMI token
000000r 2               TK_RETURN		= TK_RETNMI+1	; RETURN token
000000r 2               TK_REM		= TK_RETURN+1	; REM token
000000r 2               TK_STOP		= TK_REM+1		; STOP token
000000r 2               TK_ON			= TK_STOP+1		; ON token
000000r 2               TK_NULL		= TK_ON+1		; NULL token
000000r 2               TK_INC		= TK_NULL+1		; INC token
000000r 2               TK_WAIT		= TK_INC+1		; WAIT token
000000r 2               TK_LOAD		= TK_WAIT+1		; LOAD token
000000r 2               TK_SAVE		= TK_LOAD+1		; SAVE token
000000r 2               TK_DEF		= TK_SAVE+1		; DEF token
000000r 2               TK_POKE		= TK_DEF+1		; POKE token
000000r 2               TK_DOKE		= TK_POKE+1		; DOKE token
000000r 2               TK_CALL		= TK_DOKE+1		; CALL token
000000r 2               TK_DO			= TK_CALL+1		; DO token
000000r 2               TK_LOOP		= TK_DO+1		; LOOP token
000000r 2               TK_PRINT		= TK_LOOP+1		; PRINT token
000000r 2               TK_CONT		= TK_PRINT+1	; CONT token
000000r 2               TK_LIST		= TK_CONT+1		; LIST token
000000r 2               TK_CLEAR		= TK_LIST+1		; CLEAR token
000000r 2               TK_NEW		= TK_CLEAR+1	; NEW token
000000r 2               TK_WIDTH		= TK_NEW+1		; WIDTH token
000000r 2               TK_GET		= TK_WIDTH+1	; GET token
000000r 2               TK_SWAP		= TK_GET+1		; SWAP token
000000r 2               TK_BITSET		= TK_SWAP+1		; BITSET token
000000r 2               TK_BITCLR		= TK_BITSET+1	; BITCLR token
000000r 2               TK_IRQ		= TK_BITCLR+1	; IRQ token
000000r 2               TK_NMI		= TK_IRQ+1		; NMI token
000000r 2               TK_SYS          = TK_NMI+1              ; SYS token *** added for SBC-2
000000r 2               
000000r 2               ; secondary command tokens, can't start a statement
000000r 2               
000000r 2               TK_TAB		= TK_SYS+1		; TAB token
000000r 2               TK_ELSE		= TK_TAB+1		; ELSE token
000000r 2               TK_TO			= TK_ELSE+1		; TO token
000000r 2               TK_FN			= TK_TO+1		; FN token
000000r 2               TK_SPC		= TK_FN+1		; SPC token
000000r 2               TK_THEN		= TK_SPC+1		; THEN token
000000r 2               TK_NOT		= TK_THEN+1		; NOT token
000000r 2               TK_STEP		= TK_NOT+1		; STEP token
000000r 2               TK_UNTIL		= TK_STEP+1		; UNTIL token
000000r 2               TK_WHILE		= TK_UNTIL+1	; WHILE token
000000r 2               TK_OFF		= TK_WHILE+1	; OFF token
000000r 2               
000000r 2               ; opperator tokens
000000r 2               
000000r 2               TK_PLUS		= TK_OFF+1		; + token
000000r 2               TK_MINUS		= TK_PLUS+1		; - token
000000r 2               TK_MUL		= TK_MINUS+1	; * token
000000r 2               TK_DIV		= TK_MUL+1		; / token
000000r 2               TK_POWER		= TK_DIV+1		; ^ token
000000r 2               TK_AND		= TK_POWER+1	; AND token
000000r 2               TK_EOR		= TK_AND+1		; EOR token
000000r 2               TK_OR			= TK_EOR+1		; OR token
000000r 2               TK_RSHIFT		= TK_OR+1		; RSHIFT token
000000r 2               TK_LSHIFT		= TK_RSHIFT+1	; LSHIFT token
000000r 2               TK_GT			= TK_LSHIFT+1	; > token
000000r 2               TK_EQUAL		= TK_GT+1		; = token
000000r 2               TK_LT			= TK_EQUAL+1	; < token
000000r 2               
000000r 2               ; functions tokens
000000r 2               
000000r 2               TK_SGN		= TK_LT+1		; SGN token
000000r 2               TK_INT		= TK_SGN+1		; INT token
000000r 2               TK_ABS		= TK_INT+1		; ABS token
000000r 2               TK_USR		= TK_ABS+1		; USR token
000000r 2               TK_FRE		= TK_USR+1		; FRE token
000000r 2               TK_POS		= TK_FRE+1		; POS token
000000r 2               TK_SQR		= TK_POS+1		; SQR token
000000r 2               TK_RND		= TK_SQR+1		; RND token
000000r 2               TK_LOG		= TK_RND+1		; LOG token
000000r 2               TK_EXP		= TK_LOG+1		; EXP token
000000r 2               TK_COS		= TK_EXP+1		; COS token
000000r 2               TK_SIN		= TK_COS+1		; SIN token
000000r 2               TK_TAN		= TK_SIN+1		; TAN token
000000r 2               TK_ATN		= TK_TAN+1		; ATN token
000000r 2               TK_PEEK		= TK_ATN+1		; PEEK token
000000r 2               TK_DEEK		= TK_PEEK+1		; DEEK token
000000r 2               TK_SADD		= TK_DEEK+1		; SADD token
000000r 2               TK_LEN		= TK_SADD+1		; LEN token
000000r 2               TK_STRS		= TK_LEN+1		; STR$ token
000000r 2               TK_VAL		= TK_STRS+1		; VAL token
000000r 2               TK_ASC		= TK_VAL+1		; ASC token
000000r 2               TK_UCASES		= TK_ASC+1		; UCASE$ token
000000r 2               TK_LCASES		= TK_UCASES+1	; LCASE$ token
000000r 2               TK_CHRS		= TK_LCASES+1	; CHR$ token
000000r 2               TK_HEXS		= TK_CHRS+1		; HEX$ token
000000r 2               TK_BINS		= TK_HEXS+1		; BIN$ token
000000r 2               TK_BITTST		= TK_BINS+1		; BITTST token
000000r 2               TK_MAX		= TK_BITTST+1	; MAX token
000000r 2               TK_MIN		= TK_MAX+1		; MIN token
000000r 2               TK_PI			= TK_MIN+1		; PI token
000000r 2               TK_TWOPI		= TK_PI+1		; TWOPI token
000000r 2               TK_VPTR		= TK_TWOPI+1	; VARPTR token
000000r 2               TK_LEFTS		= TK_VPTR+1		; LEFT$ token
000000r 2               TK_RIGHTS		= TK_LEFTS+1	; RIGHT$ token
000000r 2               TK_MIDS		= TK_RIGHTS+1	; MID$ token
000000r 2               
000000r 2               ; offsets from a base of X or Y
000000r 2               
000000r 2               PLUS_0		= $00		; X or Y plus 0
000000r 2               PLUS_1		= $01		; X or Y plus 1
000000r 2               PLUS_2		= $02		; X or Y plus 2
000000r 2               PLUS_3		= $03		; X or Y plus 3
000000r 2               
000000r 2               LAB_STAK		= $0100	; stack bottom, no offset
000000r 2               
000000r 2               LAB_SKFE		= LAB_STAK+$FE
000000r 2               					; flushed stack address
000000r 2               LAB_SKFF		= LAB_STAK+$FF
000000r 2               					; flushed stack address
000000r 2               
000000r 2               ccflag		= $0200	; BASIC CTRL-C flag, 00 = enabled, 01 = dis
000000r 2               ccbyte		= ccflag+1	; BASIC CTRL-C byte
000000r 2               ccnull		= ccbyte+1	; BASIC CTRL-C byte timeout
000000r 2               
000000r 2               VEC_CC		= ccnull+1	; ctrl c check vector
000000r 2               
000000r 2               VEC_IN		= VEC_CC+2	; input vector
000000r 2               VEC_OUT		= VEC_IN+2	; output vector
000000r 2               VEC_LD		= VEC_OUT+2	; load vector
000000r 2               VEC_SV		= VEC_LD+2	; save vector
000000r 2               
000000r 2               ; Ibuffs can now be anywhere in RAM, ensure that the max length is < $80
000000r 2               
000000r 2               Ibuffs		= VEC_SV+2      ; ***changed for SBC-2
000000r 2               					; start of input buffer after IRQ/NMI code
000000r 2               Ibuffe		= Ibuffs+$47; end of input buffer
000000r 2               
000000r 2               Ram_base		= $0400	; start of user RAM (set as needed, should be page aligned)
000000r 2               Ram_top		= $8000	; end of user RAM+1 (set as needed, should be page aligned)
000000r 2               
000000r 2               ; This start can be changed to suit your system
000000r 2               
000000r 2               	;*=	$BC00
000000r 2                   .code
000000r 2               ; BASIC cold start entry point
000000r 2               
000000r 2               ; new page 2 initialisation, copy block to ccflag on
000000r 2               
000000r 2               LAB_COLD
000000r 2  A0 04        	LDY	#PG2_TABE-PG2_TABS-1
000002r 2               					; byte count-1
000002r 2               LAB_2D13
000002r 2  B9 rr rr     	LDA	PG2_TABS,Y		; get byte
000005r 2  99 00 02     	STA	ccflag,Y		; store in page 2
000008r 2  88           	DEY				; decrement count
000009r 2  10 F7        	BPL	LAB_2D13		; loop if not done
00000Br 2               
00000Br 2  A2 FF        	LDX	#$FF			; set byte
00000Dr 2  86 88        	STX	Clineh		; set current line high byte (set immediate mode)
00000Fr 2  9A           	TXS				; reset stack pointer
000010r 2               
000010r 2  A9 4C        	LDA	#$4C			; code for JMP
000012r 2  85 A1        	STA	Fnxjmp		; save for jump vector for functions
000014r 2               
000014r 2               ; copy block from LAB_2CEE to $00BC - $00D3
000014r 2               
000014r 2  A2 1C        	LDX	#StrTab-LAB_2CEE	; set byte count
000016r 2               LAB_2D4E
000016r 2  BD rr rr     	LDA	LAB_2CEE-1,X	; get byte from table
000019r 2  95 BB        	STA	LAB_IGBY-1,X	; save byte in page zero
00001Br 2  CA           	DEX				; decrement count
00001Cr 2  D0 F8        	BNE	LAB_2D4E		; loop if not all done
00001Er 2               
00001Er 2               ; copy block from StrTab to $0000 - $0012
00001Er 2               
00001Er 2               LAB_GMEM
00001Er 2  A2 12        	LDX	#EndTab-StrTab-1	; set byte count-1
000020r 2               TabLoop
000020r 2  BD rr rr     	LDA	StrTab,X		; get byte from table
000023r 2  95 00        	STA	PLUS_0,X		; save byte in page zero
000025r 2  CA           	DEX				; decrement count
000026r 2  10 F8        	BPL	TabLoop		; loop if not all done
000028r 2               
000028r 2               ; set-up start values
000028r 2               
000028r 2  A9 00        	LDA	#$00			; clear A
00002Ar 2  85 DC        	STA	NmiBase		; clear NMI handler enabled flag
00002Cr 2  85 DF        	STA	IrqBase		; clear IRQ handler enabled flag
00002Er 2  85 B2        	STA	FAC1_o		; clear FAC1 overflow byte
000030r 2  85 67        	STA	last_sh		; clear descriptor stack top item pointer high byte
000032r 2               
000032r 2  A9 0E        	LDA	#$0E			; set default tab size
000034r 2  85 64        	STA	TabSiz		; save it
000036r 2  A9 03        	LDA	#$03			; set garbage collect step size for descriptor stack
000038r 2  85 A0        	STA	g_step		; save it
00003Ar 2  A2 68        	LDX	#des_sk		; descriptor stack start
00003Cr 2  86 65        	STX	next_s		; set descriptor stack pointer
00003Er 2  20 rr rr     	JSR	LAB_CRLF		; print CR/LF
000041r 2  A9 rr        	LDA	#<LAB_MSZM		; point to memory size message (low addr)
000043r 2  A0 rr        	LDY	#>LAB_MSZM		; point to memory size message (high addr)
000045r 2  20 rr rr     	JSR	LAB_18C3		; print null terminated string from memory
000048r 2  20 rr rr     	JSR	LAB_INLN		; print "? " and get BASIC input
00004Br 2  86 C3        	STX	Bpntrl		; set BASIC execute pointer low byte
00004Dr 2  84 C4        	STY	Bpntrh		; set BASIC execute pointer high byte
00004Fr 2  20 C2 00     	JSR	LAB_GBYT		; get last byte back
000052r 2               
000052r 2  D0 1F        	BNE	LAB_2DAA		; branch if not null (user typed something)
000054r 2               
000054r 2  A0 00        	LDY	#$00			; else clear Y
000056r 2               					; character was null so get memory size the hard way
000056r 2               					; we get here with Y=0 and Itempl/h = Ram_base
000056r 2               LAB_2D93
000056r 2  E6 11        	INC	Itempl		; increment temporary integer low byte
000058r 2  D0 08        	BNE	LAB_2D99		; branch if no overflow
00005Ar 2               
00005Ar 2  E6 12        	INC	Itemph		; increment temporary integer high byte
00005Cr 2  A5 12        	LDA	Itemph		; get high byte
00005Er 2  C9 80        	CMP	#>Ram_top		; compare with top of RAM+1
000060r 2  F0 1D        	BEQ	LAB_2DB6		; branch if match (end of user RAM)
000062r 2               
000062r 2               LAB_2D99
000062r 2  A9 55        	LDA	#$55			; set test byte
000064r 2  91 11        	STA	(Itempl),Y		; save via temporary integer
000066r 2  D1 11        	CMP	(Itempl),Y		; compare via temporary integer
000068r 2  D0 15        	BNE	LAB_2DB6		; branch if fail
00006Ar 2               
00006Ar 2  0A           	ASL				; shift test byte left (now $AA)
00006Br 2  91 11        	STA	(Itempl),Y		; save via temporary integer
00006Dr 2  D1 11        	CMP	(Itempl),Y		; compare via temporary integer
00006Fr 2  F0 E5        	BEQ	LAB_2D93		; if ok go do next byte
000071r 2               
000071r 2  D0 0C        	BNE	LAB_2DB6		; branch if fail
000073r 2               
000073r 2               LAB_2DAA
000073r 2  20 rr rr     	JSR	LAB_2887		; get FAC1 from string
000076r 2  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
000078r 2  C9 98        	CMP	#$98			; compare with exponent = 2^24
00007Ar 2  B0 A2        	BCS	LAB_GMEM		; if too large go try again
00007Cr 2               
00007Cr 2  20 rr rr     	JSR	LAB_F2FU		; save integer part of FAC1 in temporary integer
00007Fr 2               					; (no range check)
00007Fr 2               
00007Fr 2               LAB_2DB6
00007Fr 2  A5 11        	LDA	Itempl		; get temporary integer low byte
000081r 2  A4 12        	LDY	Itemph		; get temporary integer high byte
000083r 2  C0 01        	CPY	#<Ram_base+1	; compare with start of RAM+$100 high byte
000085r 2  90 97        	BCC	LAB_GMEM		; if too small go try again
000087r 2               
000087r 2               
000087r 2               ; uncomment these lines if you want to check on the high limit of memory. Note if
000087r 2               ; Ram_top is set too low then this will fail. default is ignore it and assume the
000087r 2               ; users know what they"re doing!
000087r 2               
000087r 2               ;	CPY	#>Ram_top		; compare with top of RAM high byte
000087r 2               ;	BCC	MEM_OK		; branch if < RAM top
000087r 2               
000087r 2               ;	BNE	LAB_GMEM		; if too large go try again
000087r 2               					; else was = so compare low bytes
000087r 2               ;	CMP	#<Ram_top		; compare with top of RAM low byte
000087r 2               ;	BEQ	MEM_OK		; branch if = RAM top
000087r 2               
000087r 2               ;	BCS	LAB_GMEM		; if too large go try again
000087r 2               
000087r 2               ;MEM_OK
000087r 2  85 85        	STA	Ememl			; set end of mem low byte
000089r 2  84 86        	STY	Ememh			; set end of mem high byte
00008Br 2  85 81        	STA	Sstorl		; set bottom of string space low byte
00008Dr 2  84 82        	STY	Sstorh		; set bottom of string space high byte
00008Fr 2               
00008Fr 2  A0 00        	LDY	#<Ram_base		; set start addr low byte
000091r 2  A2 04        	LDX	#>Ram_base		; set start addr high byte
000093r 2  84 79        	STY	Smeml			; save start of mem low byte
000095r 2  86 7A        	STX	Smemh			; save start of mem high byte
000097r 2               
000097r 2               ; this line is only needed if Ram_base is not $xx00
000097r 2               
000097r 2               ;	LDY	#$00			; clear Y
000097r 2  98           	TYA				; clear A
000098r 2  91 79        	STA	(Smeml),Y		; clear first byte
00009Ar 2  E6 79        	INC	Smeml			; increment start of mem low byte
00009Cr 2               
00009Cr 2               ; these two lines are only needed if Ram_base is $xxFF
00009Cr 2               
00009Cr 2               ;	BNE	LAB_2E05		; branch if no rollover
00009Cr 2               
00009Cr 2               ;	INC	Smemh			; increment start of mem high byte
00009Cr 2               LAB_2E05
00009Cr 2  20 rr rr     	JSR	LAB_CRLF		; print CR/LF
00009Fr 2  20 rr rr     	JSR	LAB_1463		; do "NEW" and "CLEAR"
0000A2r 2  A5 85        	LDA	Ememl			; get end of mem low byte
0000A4r 2  38           	SEC				; set carry for subtract
0000A5r 2  E5 79        	SBC	Smeml			; subtract start of mem low byte
0000A7r 2  AA           	TAX				; copy to X
0000A8r 2  A5 86        	LDA	Ememh			; get end of mem high byte
0000AAr 2  E5 7A        	SBC	Smemh			; subtract start of mem high byte
0000ACr 2  20 rr rr     	JSR	LAB_295E		; print XA as unsigned integer (bytes free)
0000AFr 2  A9 rr        	LDA	#<LAB_SMSG		; point to sign-on message (low addr)
0000B1r 2  A0 rr        	LDY	#>LAB_SMSG		; point to sign-on message (high addr)
0000B3r 2  20 rr rr     	JSR	LAB_18C3		; print null terminated string from memory
0000B6r 2  A9 rr        	LDA	#<LAB_1274		; warm start vector low byte
0000B8r 2  A0 rr        	LDY	#>LAB_1274		; warm start vector high byte
0000BAr 2  85 01        	STA	Wrmjpl		; save warm start vector low byte
0000BCr 2  84 02        	STY	Wrmjph		; save warm start vector high byte
0000BEr 2  6C 01 00     	JMP	(Wrmjpl)		; go do warm start
0000C1r 2               
0000C1r 2               ; open up space in memory
0000C1r 2               ; move (Ostrtl)-(Obendl) to new block ending at (Nbendl)
0000C1r 2               
0000C1r 2               ; Nbendl,Nbendh - new block end address (A/Y)
0000C1r 2               ; Obendl,Obendh - old block end address
0000C1r 2               ; Ostrtl,Ostrth - old block start address
0000C1r 2               
0000C1r 2               ; returns with ..
0000C1r 2               
0000C1r 2               ; Nbendl,Nbendh - new block start address (high byte - $100)
0000C1r 2               ; Obendl,Obendh - old block start address (high byte - $100)
0000C1r 2               ; Ostrtl,Ostrth - old block start address (unchanged)
0000C1r 2               
0000C1r 2               LAB_11CF
0000C1r 2  20 rr rr     	JSR	LAB_121F		; check available memory, "Out of memory" error if no room
0000C4r 2               					; addr to check is in AY (low/high)
0000C4r 2  85 7F        	STA	Earryl		; save new array mem end low byte
0000C6r 2  84 80        	STY	Earryh		; save new array mem end high byte
0000C8r 2               
0000C8r 2               ; open up space in memory
0000C8r 2               ; move (Ostrtl)-(Obendl) to new block ending at (Nbendl)
0000C8r 2               ; don't set array end
0000C8r 2               
0000C8r 2               LAB_11D6
0000C8r 2  38           	SEC				; set carry for subtract
0000C9r 2  A5 A6        	LDA	Obendl		; get block end low byte
0000CBr 2  E5 AA        	SBC	Ostrtl		; subtract block start low byte
0000CDr 2  A8           	TAY				; copy MOD(block length/$100) byte to Y
0000CEr 2  A5 A7        	LDA	Obendh		; get block end high byte
0000D0r 2  E5 AB        	SBC	Ostrth		; subtract block start high byte
0000D2r 2  AA           	TAX				; copy block length high byte to X
0000D3r 2  E8           	INX				; +1 to allow for count=0 exit
0000D4r 2  98           	TYA				; copy block length low byte to A
0000D5r 2  F0 24        	BEQ	LAB_120A		; branch if length low byte=0
0000D7r 2               
0000D7r 2               					; block is (X-1)*256+Y bytes, do the Y bytes first
0000D7r 2               
0000D7r 2  38           	SEC				; set carry for add + 1, two's complement
0000D8r 2  49 FF        	EOR	#$FF			; invert low byte for subtract
0000DAr 2  65 A6        	ADC	Obendl		; add block end low byte
0000DCr 2               
0000DCr 2  85 A6        	STA	Obendl		; save corrected old block end low byte
0000DEr 2  B0 03        	BCS	LAB_11F3		; branch if no underflow
0000E0r 2               
0000E0r 2  C6 A7        	DEC	Obendh		; else decrement block end high byte
0000E2r 2  38           	SEC				; set carry for add + 1, two's complement
0000E3r 2               LAB_11F3
0000E3r 2  98           	TYA				; get MOD(block length/$100) byte
0000E4r 2  49 FF        	EOR	#$FF			; invert low byte for subtract
0000E6r 2  65 A4        	ADC	Nbendl		; add destination end low byte
0000E8r 2  85 A4        	STA	Nbendl		; save modified new block end low byte
0000EAr 2  B0 08        	BCS	LAB_1203		; branch if no underflow
0000ECr 2               
0000ECr 2  C6 A5        	DEC	Nbendh		; else decrement block end high byte
0000EEr 2  90 04        	BCC	LAB_1203		; branch always
0000F0r 2               
0000F0r 2               LAB_11FF
0000F0r 2  B1 A6        	LDA	(Obendl),Y		; get byte from source
0000F2r 2  91 A4        	STA	(Nbendl),Y		; copy byte to destination
0000F4r 2               LAB_1203
0000F4r 2  88           	DEY				; decrement index
0000F5r 2  D0 F9        	BNE	LAB_11FF		; loop until Y=0
0000F7r 2               
0000F7r 2               					; now do Y=0 indexed byte
0000F7r 2  B1 A6        	LDA	(Obendl),Y		; get byte from source
0000F9r 2  91 A4        	STA	(Nbendl),Y		; save byte to destination
0000FBr 2               LAB_120A
0000FBr 2  C6 A7        	DEC	Obendh		; decrement source pointer high byte
0000FDr 2  C6 A5        	DEC	Nbendh		; decrement destination pointer high byte
0000FFr 2  CA           	DEX				; decrement block count
000100r 2  D0 F2        	BNE	LAB_1203		; loop until count = $0
000102r 2               
000102r 2  60           	RTS
000103r 2               
000103r 2               ; check room on stack for A bytes
000103r 2               ; stack too deep? do OM error
000103r 2               
000103r 2               LAB_1212
000103r 2  85 78        	STA	TempB			; save result in temp byte
000105r 2  BA           	TSX				; copy stack
000106r 2  E4 78        	CPX	TempB			; compare new "limit" with stack
000108r 2  90 30        	BCC	LAB_OMER		; if stack < limit do "Out of memory" error then warm start
00010Ar 2               
00010Ar 2  60           	RTS
00010Br 2               
00010Br 2               ; check available memory, "Out of memory" error if no room
00010Br 2               ; addr to check is in AY (low/high)
00010Br 2               
00010Br 2               LAB_121F
00010Br 2  C4 82        	CPY	Sstorh		; compare bottom of string mem high byte
00010Dr 2  90 2A        	BCC	LAB_124B		; if less then exit (is ok)
00010Fr 2               
00010Fr 2  D0 04        	BNE	LAB_1229		; skip next test if greater (tested <)
000111r 2               
000111r 2               					; high byte was =, now do low byte
000111r 2  C5 81        	CMP	Sstorl		; compare with bottom of string mem low byte
000113r 2  90 24        	BCC	LAB_124B		; if less then exit (is ok)
000115r 2               
000115r 2               					; addr is > string storage ptr (oops!)
000115r 2               LAB_1229
000115r 2  48           	PHA				; push addr low byte
000116r 2  A2 08        	LDX	#$08			; set index to save Adatal to expneg inclusive
000118r 2  98           	TYA				; copy addr high byte (to push on stack)
000119r 2               
000119r 2               					; save misc numeric work area
000119r 2               LAB_122D
000119r 2  48           	PHA				; push byte
00011Ar 2  B5 A3        	LDA	Adatal-1,X		; get byte from Adatal to expneg ( ,$00 not pushed)
00011Cr 2  CA           	DEX				; decrement index
00011Dr 2  10 FA        	BPL	LAB_122D		; loop until all done
00011Fr 2               
00011Fr 2  20 rr rr     	JSR	LAB_GARB		; garbage collection routine
000122r 2               
000122r 2               					; restore misc numeric work area
000122r 2  A2 00        	LDX	#$00			; clear the index to restore bytes
000124r 2               LAB_1238
000124r 2  68           	PLA				; pop byte
000125r 2  95 A4        	STA	Adatal,X		; save byte to Adatal to expneg
000127r 2  E8           	INX				; increment index
000128r 2  E0 08        	CPX	#$08			; compare with end + 1
00012Ar 2  30 F8        	BMI	LAB_1238		; loop if more to do
00012Cr 2               
00012Cr 2  68           	PLA				; pop addr high byte
00012Dr 2  A8           	TAY				; copy back to Y
00012Er 2  68           	PLA				; pop addr low byte
00012Fr 2  C4 82        	CPY	Sstorh		; compare bottom of string mem high byte
000131r 2  90 06        	BCC	LAB_124B		; if less then exit (is ok)
000133r 2               
000133r 2  D0 05        	BNE	LAB_OMER		; if greater do "Out of memory" error then warm start
000135r 2               
000135r 2               					; high byte was =, now do low byte
000135r 2  C5 81        	CMP	Sstorl		; compare with bottom of string mem low byte
000137r 2  B0 01        	BCS	LAB_OMER		; if >= do "Out of memory" error then warm start
000139r 2               
000139r 2               					; ok exit, carry clear
000139r 2               LAB_124B
000139r 2  60           	RTS
00013Ar 2               
00013Ar 2               ; do "Out of memory" error then warm start
00013Ar 2               
00013Ar 2               LAB_OMER
00013Ar 2  A2 0C        	LDX	#$0C			; error code $0C ("Out of memory" error)
00013Cr 2               
00013Cr 2               ; do error #X, then warm start
00013Cr 2               
00013Cr 2               LAB_XERR
00013Cr 2  20 rr rr     	JSR	LAB_CRLF		; print CR/LF
00013Fr 2               
00013Fr 2  BD rr rr     	LDA	LAB_BAER,X		; get error message pointer low byte
000142r 2  BC rr rr     	LDY	LAB_BAER+1,X	; get error message pointer high byte
000145r 2  20 rr rr     	JSR	LAB_18C3		; print null terminated string from memory
000148r 2               
000148r 2  20 rr rr     	JSR	LAB_1491		; flush stack and clear continue flag
00014Br 2  A9 rr        	LDA	#<LAB_EMSG		; point to " Error" low addr
00014Dr 2  A0 rr        	LDY	#>LAB_EMSG		; point to " Error" high addr
00014Fr 2               LAB_1269
00014Fr 2  20 rr rr     	JSR	LAB_18C3		; print null terminated string from memory
000152r 2  A4 88        	LDY	Clineh		; get current line high byte
000154r 2  C8           	INY				; increment it
000155r 2  F0 03        	BEQ	LAB_1274		; go do warm start (was immediate mode)
000157r 2               
000157r 2               					; else print line number
000157r 2  20 rr rr     	JSR	LAB_2953		; print " in line [LINE #]"
00015Ar 2               
00015Ar 2               ; BASIC warm start entry point
00015Ar 2               ; wait for Basic command
00015Ar 2               
00015Ar 2               LAB_1274
00015Ar 2               					; clear ON IRQ/NMI bytes
00015Ar 2  A9 00        	LDA	#$00			; clear A
00015Cr 2  85 DF        	STA	IrqBase		; clear enabled byte
00015Er 2  85 DC        	STA	NmiBase		; clear enabled byte
000160r 2  A9 rr        	LDA	#<LAB_RMSG		; point to "Ready" message low byte
000162r 2  A0 rr        	LDY	#>LAB_RMSG		; point to "Ready" message high byte
000164r 2               
000164r 2  20 rr rr     	JSR	LAB_18C3		; go do print string
000167r 2               
000167r 2               ; wait for Basic command (no "Ready")
000167r 2               
000167r 2               LAB_127D
000167r 2  20 rr rr     	JSR	LAB_1357		; call for BASIC input
00016Ar 2               LAB_1280
00016Ar 2  86 C3        	STX	Bpntrl		; set BASIC execute pointer low byte
00016Cr 2  84 C4        	STY	Bpntrh		; set BASIC execute pointer high byte
00016Er 2  20 C2 00     	JSR	LAB_GBYT		; scan memory
000171r 2  F0 F4        	BEQ	LAB_127D		; loop while null
000173r 2               
000173r 2               ; got to interpret input line now ..
000173r 2               
000173r 2  A2 FF        	LDX	#$FF			; current line to null value
000175r 2  86 88        	STX	Clineh		; set current line high byte
000177r 2  90 06        	BCC	LAB_1295		; branch if numeric character (handle new BASIC line)
000179r 2               
000179r 2               					; no line number .. immediate mode
000179r 2  20 rr rr     	JSR	LAB_13A6		; crunch keywords into Basic tokens
00017Cr 2  4C rr rr     	JMP	LAB_15F6		; go scan and interpret code
00017Fr 2               
00017Fr 2               ; handle new BASIC line
00017Fr 2               
00017Fr 2               LAB_1295
00017Fr 2  20 rr rr     	JSR	LAB_GFPN		; get fixed-point number into temp integer
000182r 2  20 rr rr     	JSR	LAB_13A6		; crunch keywords into Basic tokens
000185r 2  84 5D        	STY	Ibptr			; save index pointer to end of crunched line
000187r 2  20 rr rr     	JSR	LAB_SSLN		; search BASIC for temp integer line number
00018Ar 2  90 44        	BCC	LAB_12E6		; branch if not found
00018Cr 2               
00018Cr 2               					; aroooogah! line # already exists! delete it
00018Cr 2  A0 01        	LDY	#$01			; set index to next line pointer high byte
00018Er 2  B1 AA        	LDA	(Baslnl),Y		; get next line pointer high byte
000190r 2  85 72        	STA	ut1_ph		; save it
000192r 2  A5 7B        	LDA	Svarl			; get start of vars low byte
000194r 2  85 71        	STA	ut1_pl		; save it
000196r 2  A5 AB        	LDA	Baslnh		; get found line pointer high byte
000198r 2  85 74        	STA	ut2_ph		; save it
00019Ar 2  A5 AA        	LDA	Baslnl		; get found line pointer low byte
00019Cr 2  88           	DEY				; decrement index
00019Dr 2  F1 AA        	SBC	(Baslnl),Y		; subtract next line pointer low byte
00019Fr 2  18           	CLC				; clear carry for add
0001A0r 2  65 7B        	ADC	Svarl			; add start of vars low byte
0001A2r 2  85 7B        	STA	Svarl			; save new start of vars low byte
0001A4r 2  85 73        	STA	ut2_pl		; save destination pointer low byte
0001A6r 2  A5 7C        	LDA	Svarh			; get start of vars high byte
0001A8r 2  69 FF        	ADC	#$FF			; -1 + carry
0001AAr 2  85 7C        	STA	Svarh			; save start of vars high byte
0001ACr 2  E5 AB        	SBC	Baslnh		; subtract found line pointer high byte
0001AEr 2  AA           	TAX				; copy to block count
0001AFr 2  38           	SEC				; set carry for subtract
0001B0r 2  A5 AA        	LDA	Baslnl		; get found line pointer low byte
0001B2r 2  E5 7B        	SBC	Svarl			; subtract start of vars low byte
0001B4r 2  A8           	TAY				; copy to bytes in first block count
0001B5r 2  B0 03        	BCS	LAB_12D0		; branch if overflow
0001B7r 2               
0001B7r 2  E8           	INX				; increment block count (correct for =0 loop exit)
0001B8r 2  C6 74        	DEC	ut2_ph		; decrement destination high byte
0001BAr 2               LAB_12D0
0001BAr 2  18           	CLC				; clear carry for add
0001BBr 2  65 71        	ADC	ut1_pl		; add source pointer low byte
0001BDr 2  90 03        	BCC	LAB_12D8		; branch if no overflow
0001BFr 2               
0001BFr 2  C6 72        	DEC	ut1_ph		; else decrement source pointer high byte
0001C1r 2  18           	CLC				; clear carry
0001C2r 2               
0001C2r 2               					; close up memory to delete old line
0001C2r 2               LAB_12D8
0001C2r 2  B1 71        	LDA	(ut1_pl),Y		; get byte from source
0001C4r 2  91 73        	STA	(ut2_pl),Y		; copy to destination
0001C6r 2  C8           	INY				; increment index
0001C7r 2  D0 F9        	BNE	LAB_12D8		; while <> 0 do this block
0001C9r 2               
0001C9r 2  E6 72        	INC	ut1_ph		; increment source pointer high byte
0001CBr 2  E6 74        	INC	ut2_ph		; increment destination pointer high byte
0001CDr 2  CA           	DEX				; decrement block count
0001CEr 2  D0 F2        	BNE	LAB_12D8		; loop until all done
0001D0r 2               
0001D0r 2               					; got new line in buffer and no existing same #
0001D0r 2               LAB_12E6
0001D0r 2  AD 0D 02     	LDA	Ibuffs		; get byte from start of input buffer
0001D3r 2  F0 3F        	BEQ	LAB_1319		; if null line just go flush stack/vars and exit
0001D5r 2               
0001D5r 2               					; got new line and it isn't empty line
0001D5r 2  A5 85        	LDA	Ememl			; get end of mem low byte
0001D7r 2  A4 86        	LDY	Ememh			; get end of mem high byte
0001D9r 2  85 81        	STA	Sstorl		; set bottom of string space low byte
0001DBr 2  84 82        	STY	Sstorh		; set bottom of string space high byte
0001DDr 2  A5 7B        	LDA	Svarl			; get start of vars low byte	(end of BASIC)
0001DFr 2  85 A6        	STA	Obendl		; save old block end low byte
0001E1r 2  A4 7C        	LDY	Svarh			; get start of vars high byte	(end of BASIC)
0001E3r 2  84 A7        	STY	Obendh		; save old block end high byte
0001E5r 2  65 5D        	ADC	Ibptr			; add input buffer pointer	(also buffer length)
0001E7r 2  90 01        	BCC	LAB_1301		; branch if no overflow from add
0001E9r 2               
0001E9r 2  C8           	INY				; else increment high byte
0001EAr 2               LAB_1301
0001EAr 2  85 A4        	STA	Nbendl		; save new block end low byte	(move to, low byte)
0001ECr 2  84 A5        	STY	Nbendh		; save new block end high byte
0001EEr 2  20 rr rr     	JSR	LAB_11CF		; open up space in memory
0001F1r 2               					; old start pointer Ostrtl,Ostrth set by the find line call
0001F1r 2  A5 7F        	LDA	Earryl		; get array mem end low byte
0001F3r 2  A4 80        	LDY	Earryh		; get array mem end high byte
0001F5r 2  85 7B        	STA	Svarl			; save start of vars low byte
0001F7r 2  84 7C        	STY	Svarh			; save start of vars high byte
0001F9r 2  A4 5D        	LDY	Ibptr			; get input buffer pointer	(also buffer length)
0001FBr 2  88           	DEY				; adjust for loop type
0001FCr 2               LAB_1311
0001FCr 2  B9 09 02     	LDA	Ibuffs-4,Y		; get byte from crunched line
0001FFr 2  91 AA        	STA	(Baslnl),Y		; save it to program memory
000201r 2  88           	DEY				; decrement count
000202r 2  C0 03        	CPY	#$03			; compare with first byte-1
000204r 2  D0 F6        	BNE	LAB_1311		; continue while count <> 3
000206r 2               
000206r 2  A5 12        	LDA	Itemph		; get line # high byte
000208r 2  91 AA        	STA	(Baslnl),Y		; save it to program memory
00020Ar 2  88           	DEY				; decrement count
00020Br 2  A5 11        	LDA	Itempl		; get line # low byte
00020Dr 2  91 AA        	STA	(Baslnl),Y		; save it to program memory
00020Fr 2  88           	DEY				; decrement count
000210r 2  A9 FF        	LDA	#$FF			; set byte to allow chain rebuild. if you didn't set this
000212r 2               					; byte then a zero already here would stop the chain rebuild
000212r 2               					; as it would think it was the [EOT] marker.
000212r 2  91 AA        	STA	(Baslnl),Y		; save it to program memory
000214r 2               
000214r 2               LAB_1319
000214r 2  20 rr rr     	JSR	LAB_1477		; reset execution to start, clear vars and flush stack
000217r 2  A6 79        	LDX	Smeml			; get start of mem low byte
000219r 2  A5 7A        	LDA	Smemh			; get start of mem high byte
00021Br 2  A0 01        	LDY	#$01			; index to high byte of next line pointer
00021Dr 2               LAB_1325
00021Dr 2  86 71        	STX	ut1_pl		; set line start pointer low byte
00021Fr 2  85 72        	STA	ut1_ph		; set line start pointer high byte
000221r 2  B1 71        	LDA	(ut1_pl),Y		; get it
000223r 2  F0 18        	BEQ	LAB_133E		; exit if end of program
000225r 2               
000225r 2               ; rebuild chaining of Basic lines
000225r 2               
000225r 2  A0 04        	LDY	#$04			; point to first code byte of line
000227r 2               					; there is always 1 byte + [EOL] as null entries are deleted
000227r 2               LAB_1330
000227r 2  C8           	INY				; next code byte
000228r 2  B1 71        	LDA	(ut1_pl),Y		; get byte
00022Ar 2  D0 FB        	BNE	LAB_1330		; loop if not [EOL]
00022Cr 2               
00022Cr 2  38           	SEC				; set carry for add + 1
00022Dr 2  98           	TYA				; copy end index
00022Er 2  65 71        	ADC	ut1_pl		; add to line start pointer low byte
000230r 2  AA           	TAX				; copy to X
000231r 2  A0 00        	LDY	#$00			; clear index, point to this line's next line pointer
000233r 2  91 71        	STA	(ut1_pl),Y		; set next line pointer low byte
000235r 2  98           	TYA				; clear A
000236r 2  65 72        	ADC	ut1_ph		; add line start pointer high byte + carry
000238r 2  C8           	INY				; increment index to high byte
000239r 2  91 71        	STA	(ut1_pl),Y		; save next line pointer low byte
00023Br 2  90 E0        	BCC	LAB_1325		; go do next line, branch always, carry clear
00023Dr 2               
00023Dr 2               
00023Dr 2               LAB_133E
00023Dr 2  4C rr rr     	JMP	LAB_127D		; else we just wait for Basic command, no "Ready"
000240r 2               
000240r 2               ; print "? " and get BASIC input
000240r 2               
000240r 2               LAB_INLN
000240r 2  20 rr rr     	JSR	LAB_18E3		; print "?" character
000243r 2  20 rr rr     	JSR	LAB_18E0		; print " "
000246r 2  D0 05        	BNE	LAB_1357		; call for BASIC input and return
000248r 2               
000248r 2               ; receive line from keyboard
000248r 2               
000248r 2               					; $08 as delete key (BACKSPACE on standard keyboard)
000248r 2               LAB_134B
000248r 2  20 rr rr     	JSR	LAB_PRNA		; go print the character
00024Br 2  CA           	DEX				; decrement the buffer counter (delete)
00024Cr 2  2C           	.byte	$2C			; make LDX into BIT abs
00024Dr 2               
00024Dr 2               ; call for BASIC input (main entry point)
00024Dr 2               
00024Dr 2               LAB_1357
00024Dr 2  A2 00        	LDX	#$00			; clear BASIC line buffer pointer
00024Fr 2               LAB_1359
00024Fr 2  20 rr rr     	JSR	V_INPT		; call scan input device
000252r 2  90 FB        	BCC	LAB_1359		; loop if no byte
000254r 2               
000254r 2  F0 F9        	BEQ	LAB_1359		; loop until valid input (ignore NULLs)
000256r 2               
000256r 2  C9 07        	CMP	#$07			; compare with [BELL]
000258r 2  F0 10        	BEQ	LAB_1378		; branch if [BELL]
00025Ar 2               
00025Ar 2  C9 0D        	CMP	#$0D			; compare with [CR]
00025Cr 2  F0 19        	BEQ	LAB_1384		; do CR/LF exit if [CR]
00025Er 2               
00025Er 2  E0 00        	CPX	#$00			; compare pointer with $00
000260r 2  D0 04        	BNE	LAB_1374		; branch if not empty
000262r 2               
000262r 2               ; next two lines ignore any non print character and [SPACE] if input buffer empty
000262r 2               
000262r 2  C9 21        	CMP	#$21			; compare with [SP]+1
000264r 2  90 E9        	BCC	LAB_1359		; if < ignore character
000266r 2               
000266r 2               LAB_1374
000266r 2  C9 08        	CMP	#$08			; compare with [BACKSPACE] (delete last character)
000268r 2  F0 DE        	BEQ	LAB_134B		; go delete last character
00026Ar 2               
00026Ar 2               LAB_1378
00026Ar 2  E0 47        	CPX	#Ibuffe-Ibuffs	; compare character count with max
00026Cr 2  B0 0C        	BCS	LAB_138E		; skip store and do [BELL] if buffer full
00026Er 2               
00026Er 2  9D 0D 02     	STA	Ibuffs,X		; else store in buffer
000271r 2  E8           	INX				; increment pointer
000272r 2               LAB_137F
000272r 2  20 rr rr     	JSR	LAB_PRNA		; go print the character
000275r 2  D0 D8        	BNE	LAB_1359		; always loop for next character
000277r 2               
000277r 2               LAB_1384
000277r 2  4C rr rr     	JMP	LAB_1866		; do CR/LF exit to BASIC
00027Ar 2               
00027Ar 2               ; announce buffer full
00027Ar 2               
00027Ar 2               LAB_138E
00027Ar 2  A9 07        	LDA	#$07			; [BELL] character into A
00027Cr 2  D0 F4        	BNE	LAB_137F		; go print the [BELL] but ignore input character
00027Er 2               					; branch always
00027Er 2               
00027Er 2               ; crunch keywords into Basic tokens
00027Er 2               ; position independent buffer version ..
00027Er 2               ; faster, dictionary search version ....
00027Er 2               
00027Er 2               LAB_13A6
00027Er 2  A0 FF        	LDY	#$FF			; set save index (makes for easy math later)
000280r 2               
000280r 2  38           	SEC				; set carry for subtract
000281r 2  A5 C3        	LDA	Bpntrl		; get basic execute pointer low byte
000283r 2  E9 0D        	SBC	#<Ibuffs		; subtract input buffer start pointer
000285r 2  AA           	TAX				; copy result to X (index past line # if any)
000286r 2               
000286r 2  86 60        	STX	Oquote		; clear open quote/DATA flag
000288r 2               LAB_13AC
000288r 2  BD 0D 02     	LDA	Ibuffs,X		; get byte from input buffer
00028Br 2  F0 51        	BEQ	LAB_13EC		; if null save byte then exit
00028Dr 2               
00028Dr 2  C9 5F        	CMP	#'_'			; compare with "_"
00028Fr 2  B0 4D        	BCS	LAB_13EC		; if >= go save byte then continue crunching
000291r 2               
000291r 2  C9 3C        	CMP	#'<'			; compare with "<"
000293r 2  B0 0E        	BCS	LAB_13CC		; if >= go crunch now
000295r 2               
000295r 2  C9 30        	CMP	#'0'			; compare with "0"
000297r 2  B0 45        	BCS	LAB_13EC		; if >= go save byte then continue crunching
000299r 2               
000299r 2  85 5C        	STA	Scnquo		; save buffer byte as search character
00029Br 2  C9 22        	CMP	#$22			; is it quote character?
00029Dr 2  F0 61        	BEQ	LAB_1410		; branch if so (copy quoted string)
00029Fr 2               
00029Fr 2  C9 2A        	CMP	#'*'			; compare with "*"
0002A1r 2  90 3B        	BCC	LAB_13EC		; if < go save byte then continue crunching
0002A3r 2               
0002A3r 2               					; else crunch now
0002A3r 2               LAB_13CC
0002A3r 2  24 60        	BIT	Oquote		; get open quote/DATA token flag
0002A5r 2  70 37        	BVS	LAB_13EC		; branch if b6 of Oquote set (was DATA)
0002A7r 2               					; go save byte then continue crunching
0002A7r 2               
0002A7r 2  86 78        	STX	TempB			; save buffer read index
0002A9r 2  84 BA        	STY	csidx			; copy buffer save index
0002ABr 2  A0 rr        	LDY	#<TAB_1STC		; get keyword first character table low address
0002ADr 2  84 73        	STY	ut2_pl		; save pointer low byte
0002AFr 2  A0 rr        	LDY	#>TAB_1STC		; get keyword first character table high address
0002B1r 2  84 74        	STY	ut2_ph		; save pointer high byte
0002B3r 2  A0 00        	LDY	#$00			; clear table pointer
0002B5r 2               
0002B5r 2               LAB_13D0
0002B5r 2  D1 73        	CMP	(ut2_pl),Y		; compare with keyword first character table byte
0002B7r 2  F0 05        	BEQ	LAB_13D1		; go do word_table_chr if match
0002B9r 2               
0002B9r 2  90 21        	BCC	LAB_13EA		; if < keyword first character table byte go restore
0002BBr 2               					; Y and save to crunched
0002BBr 2               
0002BBr 2  C8           	INY				; else increment pointer
0002BCr 2  D0 F7        	BNE	LAB_13D0		; and loop (branch always)
0002BEr 2               
0002BEr 2               ; have matched first character of some keyword
0002BEr 2               
0002BEr 2               LAB_13D1
0002BEr 2  98           	TYA				; copy matching index
0002BFr 2  0A           	ASL				; *2 (bytes per pointer)
0002C0r 2  AA           	TAX				; copy to new index
0002C1r 2  BD rr rr     	LDA	TAB_CHRT,X		; get keyword table pointer low byte
0002C4r 2  85 73        	STA	ut2_pl		; save pointer low byte
0002C6r 2  BD rr rr     	LDA	TAB_CHRT+1,X	; get keyword table pointer high byte
0002C9r 2  85 74        	STA	ut2_ph		; save pointer high byte
0002CBr 2               
0002CBr 2  A0 FF        	LDY	#$FF			; clear table pointer (make -1 for start)
0002CDr 2               
0002CDr 2  A6 78        	LDX	TempB			; restore buffer read index
0002CFr 2               
0002CFr 2               LAB_13D6
0002CFr 2  C8           	INY				; next table byte
0002D0r 2  B1 73        	LDA	(ut2_pl),Y		; get byte from table
0002D2r 2               LAB_13D8
0002D2r 2  30 08        	BMI	LAB_13EA		; all bytes matched so go save token
0002D4r 2               
0002D4r 2  E8           	INX				; next buffer byte
0002D5r 2  DD 0D 02     	CMP	Ibuffs,X		; compare with byte from input buffer
0002D8r 2  F0 F5        	BEQ	LAB_13D6		; go compare next if match
0002DAr 2               
0002DAr 2  D0 2B        	BNE	LAB_1417		; branch if >< (not found keyword)
0002DCr 2               
0002DCr 2               LAB_13EA
0002DCr 2  A4 BA        	LDY	csidx			; restore save index
0002DEr 2               
0002DEr 2               					; save crunched to output
0002DEr 2               LAB_13EC
0002DEr 2  E8           	INX				; increment buffer index (to next input byte)
0002DFr 2  C8           	INY				; increment save index (to next output byte)
0002E0r 2  99 0D 02     	STA	Ibuffs,Y		; save byte to output
0002E3r 2  C9 00        	CMP	#$00			; set the flags, set carry
0002E5r 2  F0 32        	BEQ	LAB_142A		; do exit if was null [EOL]
0002E7r 2               
0002E7r 2               					; A holds token or byte here
0002E7r 2  E9 3A        	SBC	#':'			; subtract ":" (carry set by CMP #00)
0002E9r 2  F0 04        	BEQ	LAB_13FF		; branch if it was ":" (is now $00)
0002EBr 2               
0002EBr 2               					; A now holds token-$3A
0002EBr 2  C9 49        	CMP	#TK_DATA-$3A	; compare with DATA token - $3A
0002EDr 2  D0 02        	BNE	LAB_1401		; branch if not DATA
0002EFr 2               
0002EFr 2               					; token was : or DATA
0002EFr 2               LAB_13FF
0002EFr 2  85 60        	STA	Oquote		; save token-$3A (clear for ":", TK_DATA-$3A for DATA)
0002F1r 2               LAB_1401
0002F1r 2  49 57        	EOR	#TK_REM-$3A		; effectively subtract REM token offset
0002F3r 2  D0 93        	BNE	LAB_13AC		; If wasn't REM then go crunch rest of line
0002F5r 2               
0002F5r 2  85 5C        	STA	Asrch			; else was REM so set search for [EOL]
0002F7r 2               
0002F7r 2               					; loop for REM, "..." etc.
0002F7r 2               LAB_1408
0002F7r 2  BD 0D 02     	LDA	Ibuffs,X		; get byte from input buffer
0002FAr 2  F0 E2        	BEQ	LAB_13EC		; branch if null [EOL]
0002FCr 2               
0002FCr 2  C5 5C        	CMP	Asrch			; compare with stored character
0002FEr 2  F0 DE        	BEQ	LAB_13EC		; branch if match (end quote)
000300r 2               
000300r 2               					; entry for copy string in quotes, don't crunch
000300r 2               LAB_1410
000300r 2  C8           	INY				; increment buffer save index
000301r 2  99 0D 02     	STA	Ibuffs,Y		; save byte to output
000304r 2  E8           	INX				; increment buffer read index
000305r 2  D0 F0        	BNE	LAB_1408		; loop while <> 0 (should never be 0!)
000307r 2               
000307r 2               					; not found keyword this go
000307r 2               LAB_1417
000307r 2  A6 78        	LDX	TempB			; compare has failed, restore buffer index (start byte!)
000309r 2               
000309r 2               					; now find the end of this word in the table
000309r 2               LAB_141B
000309r 2  B1 73        	LDA	(ut2_pl),Y		; get table byte
00030Br 2  08           	PHP				; save status
00030Cr 2  C8           	INY				; increment table index
00030Dr 2  28           	PLP				; restore byte status
00030Er 2  10 F9        	BPL	LAB_141B		; if not end of keyword go do next
000310r 2               
000310r 2  B1 73        	LDA	(ut2_pl),Y		; get byte from keyword table
000312r 2  D0 BE        	BNE	LAB_13D8		; go test next word if not zero byte (end of table)
000314r 2               
000314r 2               					; reached end of table with no match
000314r 2  BD 0D 02     	LDA	Ibuffs,X		; restore byte from input buffer
000317r 2  10 C3        	BPL	LAB_13EA		; branch always (all bytes in buffer are $00-$7F)
000319r 2               					; go save byte in output and continue crunching
000319r 2               
000319r 2               					; reached [EOL]
000319r 2               LAB_142A
000319r 2  C8           	INY				; increment pointer
00031Ar 2  C8           	INY				; increment pointer (makes it next line pointer high byte)
00031Br 2  99 0D 02     	STA	Ibuffs,Y		; save [EOL] (marks [EOT] in immediate mode)
00031Er 2  C8           	INY				; adjust for line copy
00031Fr 2  C8           	INY				; adjust for line copy
000320r 2  C8           	INY				; adjust for line copy
000321r 2  C6 C3        	DEC	Bpntrl		; allow for increment (change if buffer starts at $xxFF)
000323r 2  60           	RTS
000324r 2               
000324r 2               ; search Basic for temp integer line number from start of mem
000324r 2               
000324r 2               LAB_SSLN
000324r 2  A5 79        	LDA	Smeml			; get start of mem low byte
000326r 2  A6 7A        	LDX	Smemh			; get start of mem high byte
000328r 2               
000328r 2               ; search Basic for temp integer line number from AX
000328r 2               ; returns carry set if found
000328r 2               ; returns Baslnl/Baslnh pointer to found or next higher (not found) line
000328r 2               
000328r 2               ; old 541 new 507
000328r 2               
000328r 2               LAB_SHLN
000328r 2  A0 01        	LDY	#$01			; set index
00032Ar 2  85 AA        	STA	Baslnl		; save low byte as current
00032Cr 2  86 AB        	STX	Baslnh		; save high byte as current
00032Er 2  B1 AA        	LDA	(Baslnl),Y		; get pointer high byte from addr
000330r 2  F0 1A        	BEQ	LAB_145F		; pointer was zero so we"re done, do "not found" exit
000332r 2               
000332r 2  A0 03        	LDY	#$03			; set index to line # high byte
000334r 2  B1 AA        	LDA	(Baslnl),Y		; get line # high byte
000336r 2  88           	DEY				; decrement index (point to low byte)
000337r 2  C5 12        	CMP	Itemph		; compare with temporary integer high byte
000339r 2  D0 04        	BNE	LAB_1455		; if <> skip low byte check
00033Br 2               
00033Br 2  B1 AA        	LDA	(Baslnl),Y		; get line # low byte
00033Dr 2  C5 11        	CMP	Itempl		; compare with temporary integer low byte
00033Fr 2               LAB_1455
00033Fr 2  B0 09        	BCS	LAB_145E		; else if temp < this line, exit (passed line#)
000341r 2               
000341r 2               LAB_1456
000341r 2  88           	DEY				; decrement index to next line ptr high byte
000342r 2  B1 AA        	LDA	(Baslnl),Y		; get next line pointer high byte
000344r 2  AA           	TAX				; copy to X
000345r 2  88           	DEY				; decrement index to next line ptr low byte
000346r 2  B1 AA        	LDA	(Baslnl),Y		; get next line pointer low byte
000348r 2  90 DE        	BCC	LAB_SHLN		; go search for line # in temp (Itempl/Itemph) from AX
00034Ar 2               					; (carry always clear)
00034Ar 2               
00034Ar 2               LAB_145E
00034Ar 2  F0 01        	BEQ	LAB_1460		; exit if temp = found line #, carry is set
00034Cr 2               
00034Cr 2               LAB_145F
00034Cr 2  18           	CLC				; clear found flag
00034Dr 2               LAB_1460
00034Dr 2  60           	RTS
00034Er 2               
00034Er 2               ; perform NEW
00034Er 2               
00034Er 2               LAB_NEW
00034Er 2  D0 FD        	BNE	LAB_1460		; exit if not end of statement (to do syntax error)
000350r 2               
000350r 2               LAB_1463
000350r 2  A9 00        	LDA	#$00			; clear A
000352r 2  A8           	TAY				; clear Y
000353r 2  91 79        	STA	(Smeml),Y		; clear first line, next line pointer, low byte
000355r 2  C8           	INY				; increment index
000356r 2  91 79        	STA	(Smeml),Y		; clear first line, next line pointer, high byte
000358r 2  18           	CLC				; clear carry
000359r 2  A5 79        	LDA	Smeml			; get start of mem low byte
00035Br 2  69 02        	ADC	#$02			; calculate end of BASIC low byte
00035Dr 2  85 7B        	STA	Svarl			; save start of vars low byte
00035Fr 2  A5 7A        	LDA	Smemh			; get start of mem high byte
000361r 2  69 00        	ADC	#$00			; add any carry
000363r 2  85 7C        	STA	Svarh			; save start of vars high byte
000365r 2               
000365r 2               ; reset execution to start, clear vars and flush stack
000365r 2               
000365r 2               LAB_1477
000365r 2  18           	CLC				; clear carry
000366r 2  A5 79        	LDA	Smeml			; get start of mem low byte
000368r 2  69 FF        	ADC	#$FF			; -1
00036Ar 2  85 C3        	STA	Bpntrl		; save BASIC execute pointer low byte
00036Cr 2  A5 7A        	LDA	Smemh			; get start of mem high byte
00036Er 2  69 FF        	ADC	#$FF			; -1+carry
000370r 2  85 C4        	STA	Bpntrh		; save BASIC execute pointer high byte
000372r 2               
000372r 2               ; "CLEAR" command gets here
000372r 2               
000372r 2               LAB_147A
000372r 2  A5 85        	LDA	Ememl			; get end of mem low byte
000374r 2  A4 86        	LDY	Ememh			; get end of mem high byte
000376r 2  85 81        	STA	Sstorl		; set bottom of string space low byte
000378r 2  84 82        	STY	Sstorh		; set bottom of string space high byte
00037Ar 2  A5 7B        	LDA	Svarl			; get start of vars low byte
00037Cr 2  A4 7C        	LDY	Svarh			; get start of vars high byte
00037Er 2  85 7D        	STA	Sarryl		; save var mem end low byte
000380r 2  84 7E        	STY	Sarryh		; save var mem end high byte
000382r 2  85 7F        	STA	Earryl		; save array mem end low byte
000384r 2  84 80        	STY	Earryh		; save array mem end high byte
000386r 2  20 rr rr     	JSR	LAB_161A		; perform RESTORE command
000389r 2               
000389r 2               ; flush stack and clear continue flag
000389r 2               
000389r 2               LAB_1491
000389r 2  A2 68        	LDX	#des_sk		; set descriptor stack pointer
00038Br 2  86 65        	STX	next_s		; save descriptor stack pointer
00038Dr 2  68           	PLA				; pull return address low byte
00038Er 2  AA           	TAX				; copy return address low byte
00038Fr 2  68           	PLA				; pull return address high byte
000390r 2  8E FE 01     	STX	LAB_SKFE		; save to cleared stack
000393r 2  8D FF 01     	STA	LAB_SKFF		; save to cleared stack
000396r 2  A2 FD        	LDX	#$FD			; new stack pointer
000398r 2  9A           	TXS				; reset stack
000399r 2  A9 00        	LDA	#$00			; clear byte
00039Br 2  85 8C        	STA	Cpntrh		; clear continue pointer high byte
00039Dr 2  85 61        	STA	Sufnxf		; clear subscript/FNX flag
00039Fr 2               LAB_14A6
00039Fr 2  60           	RTS
0003A0r 2               
0003A0r 2               ; perform CLEAR
0003A0r 2               
0003A0r 2               LAB_CLEAR
0003A0r 2  F0 D0        	BEQ	LAB_147A		; if no following token go do "CLEAR"
0003A2r 2               
0003A2r 2               					; else there was a following token (go do syntax error)
0003A2r 2  60           	RTS
0003A3r 2               
0003A3r 2               ; perform LIST [n][-m]
0003A3r 2               ; bigger, faster version (a _lot_ faster)
0003A3r 2               
0003A3r 2               LAB_LIST
0003A3r 2  90 06        	BCC	LAB_14BD		; branch if next character numeric (LIST n..)
0003A5r 2               
0003A5r 2  F0 04        	BEQ	LAB_14BD		; branch if next character [NULL] (LIST)
0003A7r 2               
0003A7r 2  C9 B8        	CMP	#TK_MINUS		; compare with token for -
0003A9r 2  D0 F4        	BNE	LAB_14A6		; exit if not - (LIST -m)
0003ABr 2               
0003ABr 2               					; LIST [[n][-m]]
0003ABr 2               					; this bit sets the n , if present, as the start and end
0003ABr 2               LAB_14BD
0003ABr 2  20 rr rr     	JSR	LAB_GFPN		; get fixed-point number into temp integer
0003AEr 2  20 rr rr     	JSR	LAB_SSLN		; search BASIC for temp integer line number
0003B1r 2               					; (pointer in Baslnl/Baslnh)
0003B1r 2  20 C2 00     	JSR	LAB_GBYT		; scan memory
0003B4r 2  F0 0C        	BEQ	LAB_14D4		; branch if no more characters
0003B6r 2               
0003B6r 2               					; this bit checks the - is present
0003B6r 2  C9 B8        	CMP	#TK_MINUS		; compare with token for -
0003B8r 2  D0 93        	BNE	LAB_1460		; return if not "-" (will be Syntax error)
0003BAr 2               
0003BAr 2               					; LIST [n]-m
0003BAr 2               					; the - was there so set m as the end value
0003BAr 2  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
0003BDr 2  20 rr rr     	JSR	LAB_GFPN		; get fixed-point number into temp integer
0003C0r 2  D0 8B        	BNE	LAB_1460		; exit if not ok
0003C2r 2               
0003C2r 2               LAB_14D4
0003C2r 2  A5 11        	LDA	Itempl		; get temporary integer low byte
0003C4r 2  05 12        	ORA	Itemph		; OR temporary integer high byte
0003C6r 2  D0 06        	BNE	LAB_14E2		; branch if start set
0003C8r 2               
0003C8r 2  A9 FF        	LDA	#$FF			; set for -1
0003CAr 2  85 11        	STA	Itempl		; set temporary integer low byte
0003CCr 2  85 12        	STA	Itemph		; set temporary integer high byte
0003CEr 2               LAB_14E2
0003CEr 2  A0 01        	LDY	#$01			; set index for line
0003D0r 2  84 60        	STY	Oquote		; clear open quote flag
0003D2r 2  20 rr rr     	JSR	LAB_CRLF		; print CR/LF
0003D5r 2  B1 AA        	LDA	(Baslnl),Y		; get next line pointer high byte
0003D7r 2               					; pointer initially set by search at LAB_14BD
0003D7r 2  F0 3E        	BEQ	LAB_152B		; if null all done so exit
0003D9r 2  20 rr rr     	JSR	LAB_1629		; do CRTL-C check vector
0003DCr 2               
0003DCr 2  C8           	INY				; increment index for line
0003DDr 2  B1 AA        	LDA	(Baslnl),Y		; get line # low byte
0003DFr 2  AA           	TAX				; copy to X
0003E0r 2  C8           	INY				; increment index
0003E1r 2  B1 AA        	LDA	(Baslnl),Y		; get line # high byte
0003E3r 2  C5 12        	CMP	Itemph		; compare with temporary integer high byte
0003E5r 2  D0 04        	BNE	LAB_14FF		; branch if no high byte match
0003E7r 2               
0003E7r 2  E4 11        	CPX	Itempl		; compare with temporary integer low byte
0003E9r 2  F0 02        	BEQ	LAB_1501		; branch if = last line to do (< will pass next branch)
0003EBr 2               
0003EBr 2               LAB_14FF				; else ..
0003EBr 2  B0 2A        	BCS	LAB_152B		; if greater all done so exit
0003EDr 2               
0003EDr 2               LAB_1501
0003EDr 2  84 97        	STY	Tidx1			; save index for line
0003EFr 2  20 rr rr     	JSR	LAB_295E		; print XA as unsigned integer
0003F2r 2  A9 20        	LDA	#$20			; space is the next character
0003F4r 2               LAB_1508
0003F4r 2  A4 97        	LDY	Tidx1			; get index for line
0003F6r 2  29 7F        	AND	#$7F			; mask top out bit of character
0003F8r 2               LAB_150C
0003F8r 2  20 rr rr     	JSR	LAB_PRNA		; go print the character
0003FBr 2  C9 22        	CMP	#$22			; was it " character
0003FDr 2  D0 06        	BNE	LAB_1519		; branch if not
0003FFr 2               
0003FFr 2               					; we are either entering or leaving a pair of quotes
0003FFr 2  A5 60        	LDA	Oquote		; get open quote flag
000401r 2  49 FF        	EOR	#$FF			; toggle it
000403r 2  85 60        	STA	Oquote		; save it back
000405r 2               LAB_1519
000405r 2  C8           	INY				; increment index
000406r 2  B1 AA        	LDA	(Baslnl),Y		; get next byte
000408r 2  D0 0E        	BNE	LAB_152E		; branch if not [EOL] (go print character)
00040Ar 2  A8           	TAY				; else clear index
00040Br 2  B1 AA        	LDA	(Baslnl),Y		; get next line pointer low byte
00040Dr 2  AA           	TAX				; copy to X
00040Er 2  C8           	INY				; increment index
00040Fr 2  B1 AA        	LDA	(Baslnl),Y		; get next line pointer high byte
000411r 2  86 AA        	STX	Baslnl		; set pointer to line low byte
000413r 2  85 AB        	STA	Baslnh		; set pointer to line high byte
000415r 2  D0 B7        	BNE	LAB_14E2		; go do next line if not [EOT]
000417r 2               					; else ..
000417r 2               LAB_152B
000417r 2  60           	RTS
000418r 2               
000418r 2               LAB_152E
000418r 2  10 DE        	BPL	LAB_150C		; just go print it if not token byte
00041Ar 2               
00041Ar 2               					; else was token byte so uncrunch it (maybe)
00041Ar 2  24 60        	BIT	Oquote		; test the open quote flag
00041Cr 2  30 DA        	BMI	LAB_150C		; just go print character if open quote set
00041Er 2               
00041Er 2  A2 rr        	LDX	#>LAB_KEYT		; get table address high byte
000420r 2  0A           	ASL				; *2
000421r 2  0A           	ASL				; *4
000422r 2  90 02        	BCC	LAB_152F		; branch if no carry
000424r 2               
000424r 2  E8           	INX				; else increment high byte
000425r 2  18           	CLC				; clear carry for add
000426r 2               LAB_152F
000426r 2  69 rr        	ADC	#<LAB_KEYT		; add low byte
000428r 2  90 01        	BCC	LAB_1530		; branch if no carry
00042Ar 2               
00042Ar 2  E8           	INX				; else increment high byte
00042Br 2               LAB_1530
00042Br 2  85 73        	STA	ut2_pl		; save table pointer low byte
00042Dr 2  86 74        	STX	ut2_ph		; save table pointer high byte
00042Fr 2  84 97        	STY	Tidx1			; save index for line
000431r 2  A0 00        	LDY	#$00			; clear index
000433r 2  B1 73        	LDA	(ut2_pl),Y		; get length
000435r 2  AA           	TAX				; copy length
000436r 2  C8           	INY				; increment index
000437r 2  B1 73        	LDA	(ut2_pl),Y		; get 1st character
000439r 2  CA           	DEX				; decrement length
00043Ar 2  F0 B8        	BEQ	LAB_1508		; if no more characters exit and print
00043Cr 2               
00043Cr 2  20 rr rr     	JSR	LAB_PRNA		; go print the character
00043Fr 2  C8           	INY				; increment index
000440r 2  B1 73        	LDA	(ut2_pl),Y		; get keyword address low byte
000442r 2  48           	PHA				; save it for now
000443r 2  C8           	INY				; increment index
000444r 2  B1 73        	LDA	(ut2_pl),Y		; get keyword address high byte
000446r 2  A0 00        	LDY	#$00
000448r 2  85 74        	STA	ut2_ph		; save keyword pointer high byte
00044Ar 2  68           	PLA				; pull low byte
00044Br 2  85 73        	STA	ut2_pl		; save keyword pointer low byte
00044Dr 2               LAB_1540
00044Dr 2  B1 73        	LDA	(ut2_pl),Y		; get character
00044Fr 2  CA           	DEX				; decrement character count
000450r 2  F0 A2        	BEQ	LAB_1508		; if last character exit and print
000452r 2               
000452r 2  20 rr rr     	JSR	LAB_PRNA		; go print the character
000455r 2  C8           	INY				; increment index
000456r 2  D0 F5        	BNE	LAB_1540		; loop for next character
000458r 2               
000458r 2               ; perform FOR
000458r 2               
000458r 2               LAB_FOR
000458r 2  A9 80        	LDA	#$80			; set FNX
00045Ar 2  85 61        	STA	Sufnxf		; set subscript/FNX flag
00045Cr 2  20 rr rr     	JSR	LAB_LET		; go do LET
00045Fr 2  68           	PLA				; pull return address
000460r 2  68           	PLA				; pull return address
000461r 2  A9 10        	LDA	#$10			; we need 16d bytes !
000463r 2  20 rr rr     	JSR	LAB_1212		; check room on stack for A bytes
000466r 2  20 rr rr     	JSR	LAB_SNBS		; scan for next BASIC statement ([:] or [EOL])
000469r 2  18           	CLC				; clear carry for add
00046Ar 2  98           	TYA				; copy index to A
00046Br 2  65 C3        	ADC	Bpntrl		; add BASIC execute pointer low byte
00046Dr 2  48           	PHA				; push onto stack
00046Er 2  A5 C4        	LDA	Bpntrh		; get BASIC execute pointer high byte
000470r 2  69 00        	ADC	#$00			; add carry
000472r 2  48           	PHA				; push onto stack
000473r 2  A5 88        	LDA	Clineh		; get current line high byte
000475r 2  48           	PHA				; push onto stack
000476r 2  A5 87        	LDA	Clinel		; get current line low byte
000478r 2  48           	PHA				; push onto stack
000479r 2  A9 AE        	LDA	#TK_TO		; get "TO" token
00047Br 2  20 rr rr     	JSR	LAB_SCCA		; scan for CHR$(A) , else do syntax error then warm start
00047Er 2  20 rr rr     	JSR	LAB_CTNM		; check if source is numeric, else do type mismatch
000481r 2  20 rr rr     	JSR	LAB_EVNM		; evaluate expression and check is numeric,
000484r 2               					; else do type mismatch
000484r 2  A5 B0        	LDA	FAC1_s		; get FAC1 sign (b7)
000486r 2  09 7F        	ORA	#$7F			; set all non sign bits
000488r 2  25 AD        	AND	FAC1_1		; and FAC1 mantissa1
00048Ar 2  85 AD        	STA	FAC1_1		; save FAC1 mantissa1
00048Cr 2  A9 rr        	LDA	#<LAB_159F		; set return address low byte
00048Er 2  A0 rr        	LDY	#>LAB_159F		; set return address high byte
000490r 2  85 71        	STA	ut1_pl		; save return address low byte
000492r 2  84 72        	STY	ut1_ph		; save return address high byte
000494r 2  4C rr rr     	JMP	LAB_1B66		; round FAC1 and put on stack (returns to next instruction)
000497r 2               
000497r 2               LAB_159F
000497r 2  A9 rr        	LDA	#<LAB_259C		; set 1 pointer low addr (default step size)
000499r 2  A0 rr        	LDY	#>LAB_259C		; set 1 pointer high addr
00049Br 2  20 rr rr     	JSR	LAB_UFAC		; unpack memory (AY) into FAC1
00049Er 2  20 C2 00     	JSR	LAB_GBYT		; scan memory
0004A1r 2  C9 B3        	CMP	#TK_STEP		; compare with STEP token
0004A3r 2  D0 06        	BNE	LAB_15B3		; jump if not "STEP"
0004A5r 2               
0004A5r 2               					;.was step so ..
0004A5r 2  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
0004A8r 2  20 rr rr     	JSR	LAB_EVNM		; evaluate expression and check is numeric,
0004ABr 2               					; else do type mismatch
0004ABr 2               LAB_15B3
0004ABr 2  20 rr rr     	JSR	LAB_27CA		; return A=FF,C=1/-ve A=01,C=0/+ve
0004AEr 2  85 B0        	STA	FAC1_s		; set FAC1 sign (b7)
0004B0r 2               					; this is +1 for +ve step and -1 for -ve step, in NEXT we
0004B0r 2               					; compare the FOR value and the TO value and return +1 if
0004B0r 2               					; FOR > TO, 0 if FOR = TO and -1 if FOR < TO. the value
0004B0r 2               					; here (+/-1) is then compared to that result and if they
0004B0r 2               					; are the same (+ve and FOR > TO or -ve and FOR < TO) then
0004B0r 2               					; the loop is done
0004B0r 2  20 rr rr     	JSR	LAB_1B5B		; push sign, round FAC1 and put on stack
0004B3r 2  A5 98        	LDA	Frnxth		; get var pointer for FOR/NEXT high byte
0004B5r 2  48           	PHA				; push on stack
0004B6r 2  A5 97        	LDA	Frnxtl		; get var pointer for FOR/NEXT low byte
0004B8r 2  48           	PHA				; push on stack
0004B9r 2  A9 81        	LDA	#TK_FOR		; get FOR token
0004BBr 2  48           	PHA				; push on stack
0004BCr 2               
0004BCr 2               ; interpreter inner loop
0004BCr 2               
0004BCr 2               LAB_15C2
0004BCr 2  20 rr rr     	JSR	LAB_1629		; do CRTL-C check vector
0004BFr 2  A5 C3        	LDA	Bpntrl		; get BASIC execute pointer low byte
0004C1r 2  A4 C4        	LDY	Bpntrh		; get BASIC execute pointer high byte
0004C3r 2               
0004C3r 2  A6 88        	LDX	Clineh		; continue line is $FFxx for immediate mode
0004C5r 2               					; ($00xx for RUN from immediate mode)
0004C5r 2  E8           	INX				; increment it (now $00 if immediate mode)
0004C6r 2  F0 04        	BEQ	LAB_15D1		; branch if null (immediate mode)
0004C8r 2               
0004C8r 2  85 8B        	STA	Cpntrl		; save continue pointer low byte
0004CAr 2  84 8C        	STY	Cpntrh		; save continue pointer high byte
0004CCr 2               LAB_15D1
0004CCr 2  A0 00        	LDY	#$00			; clear index
0004CEr 2  B1 C3        	LDA	(Bpntrl),Y		; get next byte
0004D0r 2  F0 07        	BEQ	LAB_15DC		; branch if null [EOL]
0004D2r 2               
0004D2r 2  C9 3A        	CMP	#':'			; compare with ":"
0004D4r 2  F0 1D        	BEQ	LAB_15F6		; branch if = (statement separator)
0004D6r 2               
0004D6r 2               LAB_15D9
0004D6r 2  4C rr rr     	JMP	LAB_SNER		; else syntax error then warm start
0004D9r 2               
0004D9r 2               					; have reached [EOL]
0004D9r 2               LAB_15DC
0004D9r 2  A0 02        	LDY	#$02			; set index
0004DBr 2  B1 C3        	LDA	(Bpntrl),Y		; get next line pointer high byte
0004DDr 2  18           	CLC				; clear carry for no "BREAK" message
0004DEr 2  F0 56        	BEQ	LAB_1651		; if null go to immediate mode (was immediate or [EOT]
0004E0r 2               					; marker)
0004E0r 2               
0004E0r 2  C8           	INY				; increment index
0004E1r 2  B1 C3        	LDA	(Bpntrl),Y		; get line # low byte
0004E3r 2  85 87        	STA	Clinel		; save current line low byte
0004E5r 2  C8           	INY				; increment index
0004E6r 2  B1 C3        	LDA	(Bpntrl),Y		; get line # high byte
0004E8r 2  85 88        	STA	Clineh		; save current line high byte
0004EAr 2  98           	TYA				; A now = 4
0004EBr 2  65 C3        	ADC	Bpntrl		; add BASIC execute pointer low byte
0004EDr 2  85 C3        	STA	Bpntrl		; save BASIC execute pointer low byte
0004EFr 2  90 02        	BCC	LAB_15F6		; branch if no overflow
0004F1r 2               
0004F1r 2  E6 C4        	INC	Bpntrh		; else increment BASIC execute pointer high byte
0004F3r 2               LAB_15F6
0004F3r 2  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
0004F6r 2               
0004F6r 2               LAB_15F9
0004F6r 2  20 rr rr     	JSR	LAB_15FF		; go interpret BASIC code from (Bpntrl)
0004F9r 2               
0004F9r 2               LAB_15FC
0004F9r 2  4C rr rr     	JMP	LAB_15C2		; loop
0004FCr 2               
0004FCr 2               ; interpret BASIC code from (Bpntrl)
0004FCr 2               
0004FCr 2               LAB_15FF
0004FCr 2  F0 54        	BEQ	LAB_1628		; exit if zero [EOL]
0004FEr 2               
0004FEr 2               LAB_1602
0004FEr 2  0A           	ASL				; *2 bytes per vector and normalise token
0004FFr 2  B0 03        	BCS	LAB_1609		; branch if was token
000501r 2               
000501r 2  4C rr rr     	JMP	LAB_LET		; else go do implied LET
000504r 2               
000504r 2               LAB_1609
000504r 2  C9 58        	CMP	#(TK_TAB-$80)*2	; compare normalised token * 2 with TAB
000506r 2  B0 CE        	BCS	LAB_15D9		; branch if A>=TAB (do syntax error then warm start)
000508r 2               					; only tokens before TAB can start a line
000508r 2  A8           	TAY				; copy to index
000509r 2  B9 rr rr     	LDA	LAB_CTBL+1,Y	; get vector high byte
00050Cr 2  48           	PHA				; onto stack
00050Dr 2  B9 rr rr     	LDA	LAB_CTBL,Y		; get vector low byte
000510r 2  48           	PHA				; onto stack
000511r 2  4C BC 00     	JMP	LAB_IGBY		; jump to increment and scan memory
000514r 2               					; then "return" to vector
000514r 2               
000514r 2               ; CTRL-C check jump. this is called as a subroutine but exits back via a jump if a
000514r 2               ; key press is detected.
000514r 2               
000514r 2               LAB_1629
000514r 2  6C 03 02     	JMP	(VEC_CC)		; ctrl c check vector
000517r 2               
000517r 2               ; if there was a key press it gets back here ..
000517r 2               
000517r 2               LAB_1636
000517r 2  C9 03        	CMP	#$03			; compare with CTRL-C
000519r 2               
000519r 2               ; perform STOP
000519r 2               
000519r 2               LAB_STOP
000519r 2  B0 01        	BCS	LAB_163B		; branch if token follows STOP
00051Br 2               					; else just END
00051Br 2               ; END
00051Br 2               
00051Br 2               LAB_END
00051Br 2  18           	CLC				; clear the carry, indicate a normal program end
00051Cr 2               LAB_163B
00051Cr 2  D0 67        	BNE	LAB_167A		; if wasn't CTRL-C or there is a following byte return
00051Er 2               
00051Er 2  A5 C4        	LDA	Bpntrh		; get the BASIC execute pointer high byte
000520r 2  49 02        	EOR	#>Ibuffs		; compare with buffer address high byte (Cb unchanged)
000522r 2  F0 10        	BEQ	LAB_164F		; branch if the BASIC pointer is in the input buffer
000524r 2               					; (can't continue in immediate mode)
000524r 2               
000524r 2               					; else ..
000524r 2  49 02        	EOR	#>Ibuffs		; correct the bits
000526r 2  A4 C3        	LDY	Bpntrl		; get BASIC execute pointer low byte
000528r 2  84 8B        	STY	Cpntrl		; save continue pointer low byte
00052Ar 2  85 8C        	STA	Cpntrh		; save continue pointer high byte
00052Cr 2               LAB_1647
00052Cr 2  A5 87        	LDA	Clinel		; get current line low byte
00052Er 2  A4 88        	LDY	Clineh		; get current line high byte
000530r 2  85 89        	STA	Blinel		; save break line low byte
000532r 2  84 8A        	STY	Blineh		; save break line high byte
000534r 2               LAB_164F
000534r 2  68           	PLA				; pull return address low
000535r 2  68           	PLA				; pull return address high
000536r 2               LAB_1651
000536r 2  90 07        	BCC	LAB_165E		; if was program end just do warm start
000538r 2               
000538r 2               					; else ..
000538r 2  A9 rr        	LDA	#<LAB_BMSG		; point to "Break" low byte
00053Ar 2  A0 rr        	LDY	#>LAB_BMSG		; point to "Break" high byte
00053Cr 2  4C rr rr     	JMP	LAB_1269		; print "Break" and do warm start
00053Fr 2               
00053Fr 2               LAB_165E
00053Fr 2  4C rr rr     	JMP	LAB_1274		; go do warm start
000542r 2               
000542r 2               ; perform RESTORE
000542r 2               
000542r 2               LAB_RESTORE
000542r 2  D0 0F        	BNE	LAB_RESTOREn	; branch if next character not null (RESTORE n)
000544r 2               
000544r 2               LAB_161A
000544r 2  38           	SEC				; set carry for subtract
000545r 2  A5 79        	LDA	Smeml			; get start of mem low byte
000547r 2  E9 01        	SBC	#$01			; -1
000549r 2  A4 7A        	LDY	Smemh			; get start of mem high byte
00054Br 2  B0 01        	BCS	LAB_1624		; branch if no underflow
00054Dr 2               
00054Dr 2               LAB_uflow
00054Dr 2  88           	DEY				; else decrement high byte
00054Er 2               LAB_1624
00054Er 2  85 8F        	STA	Dptrl			; save DATA pointer low byte
000550r 2  84 90        	STY	Dptrh			; save DATA pointer high byte
000552r 2               LAB_1628
000552r 2  60           	RTS
000553r 2               
000553r 2               					; is RESTORE n
000553r 2               LAB_RESTOREn
000553r 2  20 rr rr     	JSR	LAB_GFPN		; get fixed-point number into temp integer
000556r 2  20 rr rr     	JSR	LAB_SNBL		; scan for next BASIC line
000559r 2  A5 88        	LDA	Clineh		; get current line high byte
00055Br 2  C5 12        	CMP	Itemph		; compare with temporary integer high byte
00055Dr 2  B0 0B        	BCS	LAB_reset_search	; branch if >= (start search from beginning)
00055Fr 2               
00055Fr 2  98           	TYA				; else copy line index to A
000560r 2  38           	SEC				; set carry (+1)
000561r 2  65 C3        	ADC	Bpntrl		; add BASIC execute pointer low byte
000563r 2  A6 C4        	LDX	Bpntrh		; get BASIC execute pointer high byte
000565r 2  90 07        	BCC	LAB_go_search	; branch if no overflow to high byte
000567r 2               
000567r 2  E8           	INX				; increment high byte
000568r 2  B0 04        	BCS	LAB_go_search	; branch always (can never be carry clear)
00056Ar 2               
00056Ar 2               ; search for line # in temp (Itempl/Itemph) from start of mem pointer (Smeml)
00056Ar 2               
00056Ar 2               LAB_reset_search
00056Ar 2  A5 79        	LDA	Smeml			; get start of mem low byte
00056Cr 2  A6 7A        	LDX	Smemh			; get start of mem high byte
00056Er 2               
00056Er 2               ; search for line # in temp (Itempl/Itemph) from (AX)
00056Er 2               
00056Er 2               LAB_go_search
00056Er 2               
00056Er 2  20 rr rr     	JSR	LAB_SHLN		; search Basic for temp integer line number from AX
000571r 2  B0 03        	BCS	LAB_line_found	; if carry set go set pointer
000573r 2               
000573r 2  4C rr rr     	JMP	LAB_16F7		; else go do "Undefined statement" error
000576r 2               
000576r 2               LAB_line_found
000576r 2               					; carry already set for subtract
000576r 2  A5 AA        	LDA	Baslnl		; get pointer low byte
000578r 2  E9 01        	SBC	#$01			; -1
00057Ar 2  A4 AB        	LDY	Baslnh		; get pointer high byte
00057Cr 2  B0 D0        	BCS	LAB_1624		; branch if no underflow (save DATA pointer and return)
00057Er 2               
00057Er 2  90 CD        	BCC	LAB_uflow		; else decrement high byte then save DATA pointer and
000580r 2               					; return (branch always)
000580r 2               
000580r 2               ; perform NULL
000580r 2               
000580r 2               LAB_NULL
000580r 2  20 rr rr     	JSR	LAB_GTBY		; get byte parameter
000583r 2  86 0D        	STX	Nullct		; save new NULL count
000585r 2               LAB_167A
000585r 2  60           	RTS
000586r 2               
000586r 2               ; perform CONT
000586r 2               
000586r 2               LAB_CONT
000586r 2  D0 FD        	BNE	LAB_167A		; if following byte exit to do syntax error
000588r 2               
000588r 2  A4 8C        	LDY	Cpntrh		; get continue pointer high byte
00058Ar 2  D0 05        	BNE	LAB_166C		; go do continue if we can
00058Cr 2               
00058Cr 2  A2 1E        	LDX	#$1E			; error code $1E ("Can't continue" error)
00058Er 2  4C rr rr     	JMP	LAB_XERR		; do error #X, then warm start
000591r 2               
000591r 2               					; we can continue so ..
000591r 2               LAB_166C
000591r 2  A9 93        	LDA	#TK_ON		; set token for ON
000593r 2  20 rr rr     	JSR	LAB_IRQ		; set IRQ flags
000596r 2  A9 93        	LDA	#TK_ON		; set token for ON
000598r 2  20 rr rr     	JSR	LAB_NMI		; set NMI flags
00059Br 2               
00059Br 2  84 C4        	STY	Bpntrh		; save BASIC execute pointer high byte
00059Dr 2  A5 8B        	LDA	Cpntrl		; get continue pointer low byte
00059Fr 2  85 C3        	STA	Bpntrl		; save BASIC execute pointer low byte
0005A1r 2  A5 89        	LDA	Blinel		; get break line low byte
0005A3r 2  A4 8A        	LDY	Blineh		; get break line high byte
0005A5r 2  85 87        	STA	Clinel		; set current line low byte
0005A7r 2  84 88        	STY	Clineh		; set current line high byte
0005A9r 2  60           	RTS
0005AAr 2               
0005AAr 2               ; perform RUN
0005AAr 2               
0005AAr 2               LAB_RUN
0005AAr 2  D0 03        	BNE	LAB_1696		; branch if RUN n
0005ACr 2  4C rr rr     	JMP	LAB_1477		; reset execution to start, clear variables, flush stack and
0005AFr 2               					; return
0005AFr 2               
0005AFr 2               ; does RUN n
0005AFr 2               
0005AFr 2               LAB_1696
0005AFr 2  20 rr rr     	JSR	LAB_147A		; go do "CLEAR"
0005B2r 2  F0 2E        	BEQ	LAB_16B0		; get n and do GOTO n (branch always as CLEAR sets Z=1)
0005B4r 2               
0005B4r 2               ; perform DO
0005B4r 2               
0005B4r 2               LAB_DO
0005B4r 2  A9 05        	LDA	#$05			; need 5 bytes for DO
0005B6r 2  20 rr rr     	JSR	LAB_1212		; check room on stack for A bytes
0005B9r 2  A5 C4        	LDA	Bpntrh		; get BASIC execute pointer high byte
0005BBr 2  48           	PHA				; push on stack
0005BCr 2  A5 C3        	LDA	Bpntrl		; get BASIC execute pointer low byte
0005BEr 2  48           	PHA				; push on stack
0005BFr 2  A5 88        	LDA	Clineh		; get current line high byte
0005C1r 2  48           	PHA				; push on stack
0005C2r 2  A5 87        	LDA	Clinel		; get current line low byte
0005C4r 2  48           	PHA				; push on stack
0005C5r 2  A9 9D        	LDA	#TK_DO		; token for DO
0005C7r 2  48           	PHA				; push on stack
0005C8r 2  20 C2 00     	JSR	LAB_GBYT		; scan memory
0005CBr 2  4C rr rr     	JMP	LAB_15C2		; go do interpreter inner loop
0005CEr 2               
0005CEr 2               ; perform GOSUB
0005CEr 2               
0005CEr 2               LAB_GOSUB
0005CEr 2  A9 05        	LDA	#$05			; need 5 bytes for GOSUB
0005D0r 2  20 rr rr     	JSR	LAB_1212		; check room on stack for A bytes
0005D3r 2  A5 C4        	LDA	Bpntrh		; get BASIC execute pointer high byte
0005D5r 2  48           	PHA				; push on stack
0005D6r 2  A5 C3        	LDA	Bpntrl		; get BASIC execute pointer low byte
0005D8r 2  48           	PHA				; push on stack
0005D9r 2  A5 88        	LDA	Clineh		; get current line high byte
0005DBr 2  48           	PHA				; push on stack
0005DCr 2  A5 87        	LDA	Clinel		; get current line low byte
0005DEr 2  48           	PHA				; push on stack
0005DFr 2  A9 8D        	LDA	#TK_GOSUB		; token for GOSUB
0005E1r 2  48           	PHA				; push on stack
0005E2r 2               LAB_16B0
0005E2r 2  20 C2 00     	JSR	LAB_GBYT		; scan memory
0005E5r 2  20 rr rr     	JSR	LAB_GOTO		; perform GOTO n
0005E8r 2  4C rr rr     	JMP	LAB_15C2		; go do interpreter inner loop
0005EBr 2               					; (can't RTS, we used the stack!)
0005EBr 2               
0005EBr 2               ; perform GOTO
0005EBr 2               
0005EBr 2               LAB_GOTO
0005EBr 2  20 rr rr     	JSR	LAB_GFPN		; get fixed-point number into temp integer
0005EEr 2  20 rr rr     	JSR	LAB_SNBL		; scan for next BASIC line
0005F1r 2  A5 88        	LDA	Clineh		; get current line high byte
0005F3r 2  C5 12        	CMP	Itemph		; compare with temporary integer high byte
0005F5r 2  B0 0B        	BCS	LAB_16D0		; branch if >= (start search from beginning)
0005F7r 2               
0005F7r 2  98           	TYA				; else copy line index to A
0005F8r 2  38           	SEC				; set carry (+1)
0005F9r 2  65 C3        	ADC	Bpntrl		; add BASIC execute pointer low byte
0005FBr 2  A6 C4        	LDX	Bpntrh		; get BASIC execute pointer high byte
0005FDr 2  90 07        	BCC	LAB_16D4		; branch if no overflow to high byte
0005FFr 2               
0005FFr 2  E8           	INX				; increment high byte
000600r 2  B0 04        	BCS	LAB_16D4		; branch always (can never be carry)
000602r 2               
000602r 2               ; search for line # in temp (Itempl/Itemph) from start of mem pointer (Smeml)
000602r 2               
000602r 2               LAB_16D0
000602r 2  A5 79        	LDA	Smeml			; get start of mem low byte
000604r 2  A6 7A        	LDX	Smemh			; get start of mem high byte
000606r 2               
000606r 2               ; search for line # in temp (Itempl/Itemph) from (AX)
000606r 2               
000606r 2               LAB_16D4
000606r 2  20 rr rr     	JSR	LAB_SHLN		; search Basic for temp integer line number from AX
000609r 2  90 67        	BCC	LAB_16F7		; if carry clear go do "Undefined statement" error
00060Br 2               					; (unspecified statement)
00060Br 2               
00060Br 2               					; carry already set for subtract
00060Br 2  A5 AA        	LDA	Baslnl		; get pointer low byte
00060Dr 2  E9 01        	SBC	#$01			; -1
00060Fr 2  85 C3        	STA	Bpntrl		; save BASIC execute pointer low byte
000611r 2  A5 AB        	LDA	Baslnh		; get pointer high byte
000613r 2  E9 00        	SBC	#$00			; subtract carry
000615r 2  85 C4        	STA	Bpntrh		; save BASIC execute pointer high byte
000617r 2               LAB_16E5
000617r 2  60           	RTS
000618r 2               
000618r 2               LAB_DONOK
000618r 2  A2 22        	LDX	#$22			; error code $22 ("LOOP without DO" error)
00061Ar 2  4C rr rr     	JMP	LAB_XERR		; do error #X, then warm start
00061Dr 2               
00061Dr 2               ; perform LOOP
00061Dr 2               
00061Dr 2               LAB_LOOP
00061Dr 2  A8           	TAY				; save following token
00061Er 2  BA           	TSX				; copy stack pointer
00061Fr 2  BD 03 01     	LDA	LAB_STAK+3,X	; get token byte from stack
000622r 2  C9 9D        	CMP	#TK_DO		; compare with DO token
000624r 2  D0 F2        	BNE	LAB_DONOK		; branch if no matching DO
000626r 2               
000626r 2  E8           	INX				; dump calling routine return address
000627r 2  E8           	INX				; dump calling routine return address
000628r 2  9A           	TXS				; correct stack
000629r 2  98           	TYA				; get saved following token back
00062Ar 2  F0 20        	BEQ	LoopAlways		; if no following token loop forever
00062Cr 2               					; (stack pointer in X)
00062Cr 2               
00062Cr 2  C9 3A        	CMP	#':'			; could be ":"
00062Er 2  F0 1C        	BEQ	LoopAlways		; if :... loop forever
000630r 2               
000630r 2  E9 B4        	SBC	#TK_UNTIL		; subtract token for UNTIL, we know carry is set here
000632r 2  AA           	TAX				; copy to X (if it was UNTIL then Y will be correct)
000633r 2  F0 04        	BEQ	DoRest		; branch if was UNTIL
000635r 2               
000635r 2  CA           	DEX				; decrement result
000636r 2  D0 62        	BNE	LAB_16FC		; if not WHILE go do syntax error and warm start
000638r 2               					; only if the token was WHILE will this fail
000638r 2               
000638r 2  CA           	DEX				; set invert result byte
000639r 2               DoRest
000639r 2  86 98        	STX	Frnxth		; save invert result byte
00063Br 2  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
00063Er 2  20 rr rr     	JSR	LAB_EVEX		; evaluate expression
000641r 2  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
000643r 2  F0 02        	BEQ	DoCmp			; if =0 go do straight compare
000645r 2               
000645r 2  A9 FF        	LDA	#$FF			; else set all bits
000647r 2               DoCmp
000647r 2  BA           	TSX				; copy stack pointer
000648r 2  45 98        	EOR	Frnxth		; EOR with invert byte
00064Ar 2  D0 1A        	BNE	LoopDone		; if <> 0 clear stack and back to interpreter loop
00064Cr 2               
00064Cr 2               					; loop condition wasn't met so do it again
00064Cr 2               LoopAlways
00064Cr 2  BD 02 01     	LDA	LAB_STAK+2,X	; get current line low byte
00064Fr 2  85 87        	STA	Clinel		; save current line low byte
000651r 2  BD 03 01     	LDA	LAB_STAK+3,X	; get current line high byte
000654r 2  85 88        	STA	Clineh		; save current line high byte
000656r 2  BD 04 01     	LDA	LAB_STAK+4,X	; get BASIC execute pointer low byte
000659r 2  85 C3        	STA	Bpntrl		; save BASIC execute pointer low byte
00065Br 2  BD 05 01     	LDA	LAB_STAK+5,X	; get BASIC execute pointer high byte
00065Er 2  85 C4        	STA	Bpntrh		; save BASIC execute pointer high byte
000660r 2  20 C2 00     	JSR	LAB_GBYT		; scan memory
000663r 2  4C rr rr     	JMP	LAB_15C2		; go do interpreter inner loop
000666r 2               
000666r 2               					; clear stack and back to interpreter loop
000666r 2               LoopDone
000666r 2  E8           	INX				; dump DO token
000667r 2  E8           	INX				; dump current line low byte
000668r 2  E8           	INX				; dump current line high byte
000669r 2  E8           	INX				; dump BASIC execute pointer low byte
00066Ar 2  E8           	INX				; dump BASIC execute pointer high byte
00066Br 2  9A           	TXS				; correct stack
00066Cr 2  4C rr rr     	JMP	LAB_DATA		; go perform DATA (find : or [EOL])
00066Fr 2               
00066Fr 2               ; do the return without gosub error
00066Fr 2               
00066Fr 2               LAB_16F4
00066Fr 2  A2 04        	LDX	#$04			; error code $04 ("RETURN without GOSUB" error)
000671r 2  2C           	.byte	$2C			; makes next line BIT LAB_0EA2
000672r 2               
000672r 2               LAB_16F7				; do undefined statement error
000672r 2  A2 0E        	LDX	#$0E			; error code $0E ("Undefined statement" error)
000674r 2  4C rr rr     	JMP	LAB_XERR		; do error #X, then warm start
000677r 2               
000677r 2               ; perform RETURN
000677r 2               
000677r 2               LAB_RETURN
000677r 2  D0 9E        	BNE	LAB_16E5		; exit if following token (to allow syntax error)
000679r 2               
000679r 2               LAB_16E8
000679r 2  68           	PLA				; dump calling routine return address
00067Ar 2  68           	PLA				; dump calling routine return address
00067Br 2  68           	PLA				; pull token
00067Cr 2  C9 8D        	CMP	#TK_GOSUB		; compare with GOSUB token
00067Er 2  D0 EF        	BNE	LAB_16F4		; branch if no matching GOSUB
000680r 2               
000680r 2               LAB_16FF
000680r 2  68           	PLA				; pull current line low byte
000681r 2  85 87        	STA	Clinel		; save current line low byte
000683r 2  68           	PLA				; pull current line high byte
000684r 2  85 88        	STA	Clineh		; save current line high byte
000686r 2  68           	PLA				; pull BASIC execute pointer low byte
000687r 2  85 C3        	STA	Bpntrl		; save BASIC execute pointer low byte
000689r 2  68           	PLA				; pull BASIC execute pointer high byte
00068Ar 2  85 C4        	STA	Bpntrh		; save BASIC execute pointer high byte
00068Cr 2               
00068Cr 2               					; now do the DATA statement as we could be returning into
00068Cr 2               					; the middle of an ON <var> GOSUB n,m,p,q line
00068Cr 2               					; (the return address used by the DATA statement is the one
00068Cr 2               					; pushed before the GOSUB was executed!)
00068Cr 2               
00068Cr 2               ; perform DATA
00068Cr 2               
00068Cr 2               LAB_DATA
00068Cr 2  20 rr rr     	JSR	LAB_SNBS		; scan for next BASIC statement ([:] or [EOL])
00068Fr 2               
00068Fr 2               					; set BASIC execute pointer
00068Fr 2               LAB_170F
00068Fr 2  98           	TYA				; copy index to A
000690r 2  18           	CLC				; clear carry for add
000691r 2  65 C3        	ADC	Bpntrl		; add BASIC execute pointer low byte
000693r 2  85 C3        	STA	Bpntrl		; save BASIC execute pointer low byte
000695r 2  90 02        	BCC	LAB_1719		; skip next if no carry
000697r 2               
000697r 2  E6 C4        	INC	Bpntrh		; else increment BASIC execute pointer high byte
000699r 2               LAB_1719
000699r 2  60           	RTS
00069Ar 2               
00069Ar 2               LAB_16FC
00069Ar 2  4C rr rr     	JMP	LAB_SNER		; do syntax error then warm start
00069Dr 2               
00069Dr 2               ; scan for next BASIC statement ([:] or [EOL])
00069Dr 2               ; returns Y as index to [:] or [EOL]
00069Dr 2               
00069Dr 2               LAB_SNBS
00069Dr 2  A2 3A        	LDX	#':'			; set look for character = ":"
00069Fr 2  2C           	.byte	$2C			; makes next line BIT $00A2
0006A0r 2               
0006A0r 2               ; scan for next BASIC line
0006A0r 2               ; returns Y as index to [EOL]
0006A0r 2               
0006A0r 2               LAB_SNBL
0006A0r 2  A2 00        	LDX	#$00			; set alt search character = [EOL]
0006A2r 2  A0 00        	LDY	#$00			; set search character = [EOL]
0006A4r 2  84 5C        	STY	Asrch			; store search character
0006A6r 2               LAB_1725
0006A6r 2  8A           	TXA				; get alt search character
0006A7r 2  45 5C        	EOR	Asrch			; toggle search character, effectively swap with $00
0006A9r 2  85 5C        	STA	Asrch			; save swapped search character
0006ABr 2               LAB_172D
0006ABr 2  B1 C3        	LDA	(Bpntrl),Y		; get next byte
0006ADr 2  F0 EA        	BEQ	LAB_1719		; exit if null [EOL]
0006AFr 2               
0006AFr 2  C5 5C        	CMP	Asrch			; compare with search character
0006B1r 2  F0 E6        	BEQ	LAB_1719		; exit if found
0006B3r 2               
0006B3r 2  C8           	INY				; increment index
0006B4r 2  C9 22        	CMP	#$22			; compare current character with open quote
0006B6r 2  D0 F3        	BNE	LAB_172D		; if not open quote go get next character
0006B8r 2               
0006B8r 2  F0 EC        	BEQ	LAB_1725		; if found go swap search character for alt search character
0006BAr 2               
0006BAr 2               ; perform IF
0006BAr 2               
0006BAr 2               LAB_IF
0006BAr 2  20 rr rr     	JSR	LAB_EVEX		; evaluate the expression
0006BDr 2  20 C2 00     	JSR	LAB_GBYT		; scan memory
0006C0r 2  C9 B1        	CMP	#TK_THEN		; compare with THEN token
0006C2r 2  F0 11        	BEQ	LAB_174B		; if it was THEN go do IF
0006C4r 2               
0006C4r 2               					; wasn't IF .. THEN so must be IF .. GOTO
0006C4r 2  C9 89        	CMP	#TK_GOTO		; compare with GOTO token
0006C6r 2  D0 D2        	BNE	LAB_16FC		; if it wasn't GOTO go do syntax error
0006C8r 2               
0006C8r 2  A6 C3        	LDX	Bpntrl		; save the basic pointer low byte
0006CAr 2  A4 C4        	LDY	Bpntrh		; save the basic pointer high byte
0006CCr 2  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
0006CFr 2  B0 C9        	BCS	LAB_16FC		; if not numeric go do syntax error
0006D1r 2               
0006D1r 2  86 C3        	STX	Bpntrl		; restore the basic pointer low byte
0006D3r 2  84 C4        	STY	Bpntrh		; restore the basic pointer high byte
0006D5r 2               LAB_174B
0006D5r 2  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
0006D7r 2  F0 1B        	BEQ	LAB_174E		; if the result was zero go look for an ELSE
0006D9r 2               
0006D9r 2  20 BC 00     	JSR	LAB_IGBY		; else increment and scan memory
0006DCr 2  B0 03        	BCS	LAB_174D		; if not numeric go do var or keyword
0006DEr 2               
0006DEr 2               LAB_174C
0006DEr 2  4C rr rr     	JMP	LAB_GOTO		; else was numeric so do GOTO n
0006E1r 2               
0006E1r 2               					; is var or keyword
0006E1r 2               LAB_174D
0006E1r 2  C9 90        	CMP	#TK_RETURN		; compare the byte with the token for RETURN
0006E3r 2  D0 03        	BNE	LAB_174G		; if it wasn't RETURN go interpret BASIC code from (Bpntrl)
0006E5r 2               					; and return to this code to process any following code
0006E5r 2               
0006E5r 2  4C rr rr     	JMP	LAB_1602		; else it was RETURN so interpret BASIC code from (Bpntrl)
0006E8r 2               					; but don't return here
0006E8r 2               
0006E8r 2               LAB_174G
0006E8r 2  20 rr rr     	JSR	LAB_15FF		; interpret BASIC code from (Bpntrl)
0006EBr 2               
0006EBr 2               ; the IF was executed and there may be a following ELSE so the code needs to return
0006EBr 2               ; here to check and ignore the ELSE if present
0006EBr 2               
0006EBr 2  A0 00        	LDY	#$00			; clear the index
0006EDr 2  B1 C3        	LDA	(Bpntrl),Y		; get the next BASIC byte
0006EFr 2  C9 AD        	CMP	#TK_ELSE		; compare it with the token for ELSE
0006F1r 2  F0 99        	BEQ	LAB_DATA		; if ELSE ignore the following statement
0006F3r 2               
0006F3r 2               ; there was no ELSE so continue execution of IF <expr> THEN <stat> [: <stat>]. any
0006F3r 2               ; following ELSE will, correctly, cause a syntax error
0006F3r 2               
0006F3r 2  60           	RTS				; else return to the interpreter inner loop
0006F4r 2               
0006F4r 2               ; perform ELSE after IF
0006F4r 2               
0006F4r 2               LAB_174E
0006F4r 2  A0 00        	LDY	#$00			; clear the BASIC byte index
0006F6r 2  A2 01        	LDX	#$01			; clear the nesting depth
0006F8r 2               LAB_1750
0006F8r 2  C8           	INY				; increment the BASIC byte index
0006F9r 2  B1 C3        	LDA	(Bpntrl),Y		; get the next BASIC byte
0006FBr 2  F0 0F        	BEQ	LAB_1753		; if EOL go add the pointer and return
0006FDr 2               
0006FDr 2  C9 8B        	CMP	#TK_IF		; compare the byte with the token for IF
0006FFr 2  D0 03        	BNE	LAB_1752		; if not IF token skip the depth increment
000701r 2               
000701r 2  E8           	INX				; else increment the nesting depth ..
000702r 2  D0 F4        	BNE	LAB_1750		; .. and continue looking
000704r 2               
000704r 2               LAB_1752
000704r 2  C9 AD        	CMP	#TK_ELSE		; compare the byte with the token for ELSE
000706r 2  D0 F0        	BNE	LAB_1750		; if not ELSE token continue looking
000708r 2               
000708r 2  CA           	DEX				; was ELSE so decrement the nesting depth
000709r 2  D0 ED        	BNE	LAB_1750		; loop if still nested
00070Br 2               
00070Br 2  C8           	INY				; increment the BASIC byte index past the ELSE
00070Cr 2               
00070Cr 2               ; found the matching ELSE, now do <{n|statement}>
00070Cr 2               
00070Cr 2               LAB_1753
00070Cr 2  98           	TYA				; else copy line index to A
00070Dr 2  18           	CLC				; clear carry for add
00070Er 2  65 C3        	ADC	Bpntrl		; add the BASIC execute pointer low byte
000710r 2  85 C3        	STA	Bpntrl		; save the BASIC execute pointer low byte
000712r 2  90 02        	BCC	LAB_1754		; branch if no overflow to high byte
000714r 2               
000714r 2  E6 C4        	INC	Bpntrh		; else increment the BASIC execute pointer high byte
000716r 2               LAB_1754
000716r 2  20 C2 00     	JSR	LAB_GBYT		; scan memory
000719r 2  90 C3        	BCC	LAB_174C		; if numeric do GOTO n
00071Br 2               					; the code will return to the interpreter loop at the
00071Br 2               					; tail end of the GOTO <n>
00071Br 2               
00071Br 2  4C rr rr     	JMP	LAB_15FF		; interpret BASIC code from (Bpntrl)
00071Er 2               					; the code will return to the interpreter loop at the
00071Er 2               					; tail end of the <statement>
00071Er 2               
00071Er 2               ; perform REM, skip (rest of) line
00071Er 2               
00071Er 2               LAB_REM
00071Er 2  20 rr rr     	JSR	LAB_SNBL		; scan for next BASIC line
000721r 2  4C rr rr     	JMP	LAB_170F		; go set BASIC execute pointer and return, branch always
000724r 2               
000724r 2               LAB_16FD
000724r 2  4C rr rr     	JMP	LAB_SNER		; do syntax error then warm start
000727r 2               
000727r 2               ; perform ON
000727r 2               
000727r 2               LAB_ON
000727r 2  C9 A9        	CMP	#TK_IRQ		; was it IRQ token ?
000729r 2  D0 03        	BNE	LAB_NOIN		; if not go check NMI
00072Br 2               
00072Br 2  4C rr rr     	JMP	LAB_SIRQ		; else go set-up IRQ
00072Er 2               
00072Er 2               LAB_NOIN
00072Er 2  C9 AA        	CMP	#TK_NMI		; was it NMI token ?
000730r 2  D0 03        	BNE	LAB_NONM		; if not go do normal ON command
000732r 2               
000732r 2  4C rr rr     	JMP	LAB_SNMI		; else go set-up NMI
000735r 2               
000735r 2               LAB_NONM
000735r 2  20 rr rr     	JSR	LAB_GTBY		; get byte parameter
000738r 2  48           	PHA				; push GOTO/GOSUB token
000739r 2  C9 8D        	CMP	#TK_GOSUB		; compare with GOSUB token
00073Br 2  F0 04        	BEQ	LAB_176B		; branch if GOSUB
00073Dr 2               
00073Dr 2  C9 89        	CMP	#TK_GOTO		; compare with GOTO token
00073Fr 2               LAB_1767
00073Fr 2  D0 E3        	BNE	LAB_16FD		; if not GOTO do syntax error then warm start
000741r 2               
000741r 2               
000741r 2               ; next character was GOTO or GOSUB
000741r 2               
000741r 2               LAB_176B
000741r 2  C6 AF        	DEC	FAC1_3		; decrement index (byte value)
000743r 2  D0 04        	BNE	LAB_1773		; branch if not zero
000745r 2               
000745r 2  68           	PLA				; pull GOTO/GOSUB token
000746r 2  4C rr rr     	JMP	LAB_1602		; go execute it
000749r 2               
000749r 2               LAB_1773
000749r 2  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
00074Cr 2  20 rr rr     	JSR	LAB_GFPN		; get fixed-point number into temp integer (skip this n)
00074Fr 2               					; (we could LDX #"," and JSR LAB_SNBL+2, then we
00074Fr 2               					; just BNE LAB_176B for the loop. should be quicker ..
00074Fr 2               					; no we can't, what if we meet a colon or [EOL]?)
00074Fr 2  C9 2C        	CMP	#$2C			; compare next character with ","
000751r 2  F0 EE        	BEQ	LAB_176B		; loop if ","
000753r 2               
000753r 2               LAB_177E
000753r 2  68           	PLA				; else pull keyword token (run out of options)
000754r 2               					; also dump +/-1 pointer low byte and exit
000754r 2               LAB_177F
000754r 2  60           	RTS
000755r 2               
000755r 2               ; takes n * 106 + 11 cycles where n is the number of digits
000755r 2               
000755r 2               ; get fixed-point number into temp integer
000755r 2               
000755r 2               LAB_GFPN
000755r 2  A2 00        	LDX	#$00			; clear reg
000757r 2  86 11        	STX	Itempl		; clear temporary integer low byte
000759r 2               LAB_1785
000759r 2  86 12        	STX	Itemph		; save temporary integer high byte
00075Br 2  B0 F7        	BCS	LAB_177F		; return if carry set, end of scan, character was
00075Dr 2               					; not 0-9
00075Dr 2               
00075Dr 2  E0 19        	CPX	#$19			; compare high byte with $19
00075Fr 2  A8           	TAY				; ensure Zb = 0 if the branch is taken
000760r 2  B0 DD        	BCS	LAB_1767		; branch if >=, makes max line # 63999 because next
000762r 2               					; bit does *$0A, = 64000, compare at target will fail
000762r 2               					; and do syntax error
000762r 2               
000762r 2  E9 2F        	SBC	#'0'-1		; subtract "0", $2F + carry, from byte
000764r 2  A8           	TAY				; copy binary digit
000765r 2  A5 11        	LDA	Itempl		; get temporary integer low byte
000767r 2  0A           	ASL				; *2 low byte
000768r 2  26 12        	ROL	Itemph		; *2 high byte
00076Ar 2  0A           	ASL				; *2 low byte
00076Br 2  26 12        	ROL	Itemph		; *2 high byte, *4
00076Dr 2  65 11        	ADC	Itempl		; + low byte, *5
00076Fr 2  85 11        	STA	Itempl		; save it
000771r 2  8A           	TXA				; get high byte copy to A
000772r 2  65 12        	ADC	Itemph		; + high byte, *5
000774r 2  06 11        	ASL	Itempl		; *2 low byte, *10d
000776r 2  2A           	ROL				; *2 high byte, *10d
000777r 2  AA           	TAX				; copy high byte back to X
000778r 2  98           	TYA				; get binary digit back
000779r 2  65 11        	ADC	Itempl		; add number low byte
00077Br 2  85 11        	STA	Itempl		; save number low byte
00077Dr 2  90 01        	BCC	LAB_17B3		; if no overflow to high byte get next character
00077Fr 2               
00077Fr 2  E8           	INX				; else increment high byte
000780r 2               LAB_17B3
000780r 2  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
000783r 2  4C rr rr     	JMP	LAB_1785		; loop for next character
000786r 2               
000786r 2               ; perform DEC
000786r 2               
000786r 2               LAB_DEC
000786r 2  A9 rr        	LDA	#<LAB_2AFD		; set -1 pointer low byte
000788r 2  2C           	.byte	$2C			; BIT abs to skip the LDA below
000789r 2               
000789r 2               ; perform INC
000789r 2               
000789r 2               LAB_INC
000789r 2  A9 rr        	LDA	#<LAB_259C		; set 1 pointer low byte
00078Br 2               LAB_17B5
00078Br 2  48           	PHA				; save +/-1 pointer low byte
00078Cr 2               LAB_17B7
00078Cr 2  20 rr rr     	JSR	LAB_GVAR		; get var address
00078Fr 2  A6 5F        	LDX	Dtypef		; get data type flag, $FF=string, $00=numeric
000791r 2  30 1E        	BMI	IncrErr		; exit if string
000793r 2               
000793r 2  85 97        	STA	Lvarpl		; save var address low byte
000795r 2  84 98        	STY	Lvarph		; save var address high byte
000797r 2  20 rr rr     	JSR	LAB_UFAC		; unpack memory (AY) into FAC1
00079Ar 2  68           	PLA				; get +/-1 pointer low byte
00079Br 2  48           	PHA				; save +/-1 pointer low byte
00079Cr 2  A0 rr        	LDY	#>LAB_259C		; set +/-1 pointer high byte (both the same)
00079Er 2  20 rr rr     	JSR	LAB_246C		; add (AY) to FAC1
0007A1r 2  20 rr rr     	JSR	LAB_PFAC		; pack FAC1 into variable (Lvarpl)
0007A4r 2               
0007A4r 2  20 C2 00     	JSR	LAB_GBYT		; scan memory
0007A7r 2  C9 2C        	CMP	#','			; compare with ","
0007A9r 2  D0 A8        	BNE	LAB_177E		; exit if not "," (either end or error)
0007ABr 2               
0007ABr 2               					; was "," so another INCR variable to do
0007ABr 2  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
0007AEr 2  4C rr rr     	JMP	LAB_17B7		; go do next var
0007B1r 2               
0007B1r 2               IncrErr
0007B1r 2  4C rr rr     	JMP	LAB_1ABC		; do "Type mismatch" error then warm start
0007B4r 2               
0007B4r 2               ; perform LET
0007B4r 2               
0007B4r 2               LAB_LET
0007B4r 2  20 rr rr     	JSR	LAB_GVAR		; get var address
0007B7r 2  85 97        	STA	Lvarpl		; save var address low byte
0007B9r 2  84 98        	STY	Lvarph		; save var address high byte
0007BBr 2  A9 C2        	LDA	#TK_EQUAL		; get = token
0007BDr 2  20 rr rr     	JSR	LAB_SCCA		; scan for CHR$(A), else do syntax error then warm start
0007C0r 2  A5 5F        	LDA	Dtypef		; get data type flag, $FF=string, $00=numeric
0007C2r 2  48           	PHA				; push data type flag
0007C3r 2  20 rr rr     	JSR	LAB_EVEX		; evaluate expression
0007C6r 2  68           	PLA				; pop data type flag
0007C7r 2  2A           	ROL				; set carry if type = string
0007C8r 2  20 rr rr     	JSR	LAB_CKTM		; type match check, set C for string
0007CBr 2  D0 03        	BNE	LAB_17D5		; branch if string
0007CDr 2               
0007CDr 2  4C rr rr     	JMP	LAB_PFAC		; pack FAC1 into variable (Lvarpl) and return
0007D0r 2               
0007D0r 2               ; string LET
0007D0r 2               
0007D0r 2               LAB_17D5
0007D0r 2  A0 02        	LDY	#$02			; set index to pointer high byte
0007D2r 2  B1 AE        	LDA	(des_pl),Y		; get string pointer high byte
0007D4r 2  C5 82        	CMP	Sstorh		; compare bottom of string space high byte
0007D6r 2  90 17        	BCC	LAB_17F4		; if less assign value and exit (was in program memory)
0007D8r 2               
0007D8r 2  D0 07        	BNE	LAB_17E6		; branch if >
0007DAr 2               					; else was equal so compare low bytes
0007DAr 2  88           	DEY				; decrement index
0007DBr 2  B1 AE        	LDA	(des_pl),Y		; get pointer low byte
0007DDr 2  C5 81        	CMP	Sstorl		; compare bottom of string space low byte
0007DFr 2  90 0E        	BCC	LAB_17F4		; if less assign value and exit (was in program memory)
0007E1r 2               
0007E1r 2               					; pointer was >= to bottom of string space pointer
0007E1r 2               LAB_17E6
0007E1r 2  A4 AF        	LDY	des_ph		; get descriptor pointer high byte
0007E3r 2  C4 7C        	CPY	Svarh			; compare start of vars high byte
0007E5r 2  90 08        	BCC	LAB_17F4		; branch if less (descriptor is on stack)
0007E7r 2               
0007E7r 2  D0 0D        	BNE	LAB_17FB		; branch if greater (descriptor is not on stack)
0007E9r 2               
0007E9r 2               					; else high bytes were equal so ..
0007E9r 2  A5 AE        	LDA	des_pl		; get descriptor pointer low byte
0007EBr 2  C5 7B        	CMP	Svarl			; compare start of vars low byte
0007EDr 2  B0 07        	BCS	LAB_17FB		; branch if >= (descriptor is not on stack)
0007EFr 2               
0007EFr 2               LAB_17F4
0007EFr 2  A5 AE        	LDA	des_pl		; get descriptor pointer low byte
0007F1r 2  A4 AF        	LDY	des_ph		; get descriptor pointer high byte
0007F3r 2  4C rr rr     	JMP	LAB_1811		; clean stack, copy descriptor to variable and return
0007F6r 2               
0007F6r 2               					; make space and copy string
0007F6r 2               LAB_17FB
0007F6r 2  A0 00        	LDY	#$00			; index to length
0007F8r 2  B1 AE        	LDA	(des_pl),Y		; get string length
0007FAr 2  20 rr rr     	JSR	LAB_209C		; copy string
0007FDr 2  A5 9E        	LDA	des_2l		; get descriptor pointer low byte
0007FFr 2  A4 9F        	LDY	des_2h		; get descriptor pointer high byte
000801r 2  85 B8        	STA	ssptr_l		; save descriptor pointer low byte
000803r 2  84 B9        	STY	ssptr_h		; save descriptor pointer high byte
000805r 2  20 rr rr     	JSR	LAB_228A		; copy string from descriptor (sdescr) to (Sutill)
000808r 2  A9 AC        	LDA	#<FAC1_e		; set descriptor pointer low byte
00080Ar 2  A0 00        	LDY	#>FAC1_e		; get descriptor pointer high byte
00080Cr 2               
00080Cr 2               					; clean stack and assign value to string variable
00080Cr 2               LAB_1811
00080Cr 2  85 9E        	STA	des_2l		; save descriptor_2 pointer low byte
00080Er 2  84 9F        	STY	des_2h		; save descriptor_2 pointer high byte
000810r 2  20 rr rr     	JSR	LAB_22EB		; clean descriptor stack, YA = pointer
000813r 2  A0 00        	LDY	#$00			; index to length
000815r 2  B1 9E        	LDA	(des_2l),Y		; get string length
000817r 2  91 97        	STA	(Lvarpl),Y		; copy to let string variable
000819r 2  C8           	INY				; index to string pointer low byte
00081Ar 2  B1 9E        	LDA	(des_2l),Y		; get string pointer low byte
00081Cr 2  91 97        	STA	(Lvarpl),Y		; copy to let string variable
00081Er 2  C8           	INY				; index to string pointer high byte
00081Fr 2  B1 9E        	LDA	(des_2l),Y		; get string pointer high byte
000821r 2  91 97        	STA	(Lvarpl),Y		; copy to let string variable
000823r 2  60           	RTS
000824r 2               
000824r 2               ; perform GET
000824r 2               
000824r 2               LAB_GET
000824r 2  20 rr rr     	JSR	LAB_GVAR		; get var address
000827r 2  85 97        	STA	Lvarpl		; save var address low byte
000829r 2  84 98        	STY	Lvarph		; save var address high byte
00082Br 2  20 rr rr     	JSR	INGET			; get input byte
00082Er 2  A6 5F        	LDX	Dtypef		; get data type flag, $FF=string, $00=numeric
000830r 2  30 07        	BMI	LAB_GETS		; go get string character
000832r 2               
000832r 2               					; was numeric get
000832r 2  A8           	TAY				; copy character to Y
000833r 2  20 rr rr     	JSR	LAB_1FD0		; convert Y to byte in FAC1
000836r 2  4C rr rr     	JMP	LAB_PFAC		; pack FAC1 into variable (Lvarpl) and return
000839r 2               
000839r 2               LAB_GETS
000839r 2  48           	PHA				; save character
00083Ar 2  A9 01        	LDA	#$01			; string is single byte
00083Cr 2  B0 01        	BCS	LAB_IsByte		; branch if byte received
00083Er 2               
00083Er 2  68           	PLA				; string is null
00083Fr 2               LAB_IsByte
00083Fr 2  20 rr rr     	JSR	LAB_MSSP		; make string space A bytes long A=$AC=length,
000842r 2               					; X=$AD=Sutill=ptr low byte, Y=$AE=Sutilh=ptr high byte
000842r 2  F0 05        	BEQ	LAB_NoSt		; skip store if null string
000844r 2               
000844r 2  68           	PLA				; get character back
000845r 2  A0 00        	LDY	#$00			; clear index
000847r 2  91 AD        	STA	(str_pl),Y		; save byte in string (byte IS string!)
000849r 2               LAB_NoSt
000849r 2  20 rr rr     	JSR	LAB_RTST		; check for space on descriptor stack then put address
00084Cr 2               					; and length on descriptor stack and update stack pointers
00084Cr 2               
00084Cr 2  4C rr rr     	JMP	LAB_17D5		; do string LET and return
00084Fr 2               
00084Fr 2               ; perform PRINT
00084Fr 2               
00084Fr 2               LAB_1829
00084Fr 2  20 rr rr     	JSR	LAB_18C6		; print string from Sutill/Sutilh
000852r 2               LAB_182C
000852r 2  20 C2 00     	JSR	LAB_GBYT		; scan memory
000855r 2               
000855r 2               ; PRINT
000855r 2               
000855r 2               LAB_PRINT
000855r 2  F0 3B        	BEQ	LAB_CRLF		; if nothing following just print CR/LF
000857r 2               
000857r 2               LAB_1831
000857r 2  C9 AC        	CMP	#TK_TAB		; compare with TAB( token
000859r 2  F0 56        	BEQ	LAB_18A2		; go do TAB/SPC
00085Br 2               
00085Br 2  C9 B0        	CMP	#TK_SPC		; compare with SPC( token
00085Dr 2  F0 52        	BEQ	LAB_18A2		; go do TAB/SPC
00085Fr 2               
00085Fr 2  C9 2C        	CMP	#','			; compare with ","
000861r 2  F0 38        	BEQ	LAB_188B		; go do move to next TAB mark
000863r 2               
000863r 2  C9 3B        	CMP	#';'			; compare with ";"
000865r 2  F0 66        	BEQ	LAB_18BD		; if ";" continue with PRINT processing
000867r 2               
000867r 2  20 rr rr     	JSR	LAB_EVEX		; evaluate expression
00086Ar 2  24 5F        	BIT	Dtypef		; test data type flag, $FF=string, $00=numeric
00086Cr 2  30 E1        	BMI	LAB_1829		; branch if string
00086Er 2               
00086Er 2  20 rr rr     	JSR	LAB_296E		; convert FAC1 to string
000871r 2  20 rr rr     	JSR	LAB_20AE		; print " terminated string to Sutill/Sutilh
000874r 2  A0 00        	LDY	#$00			; clear index
000876r 2               
000876r 2               ; don't check fit if terminal width byte is zero
000876r 2               
000876r 2  A5 0F        	LDA	TWidth		; get terminal width byte
000878r 2  F0 0A        	BEQ	LAB_185E		; skip check if zero
00087Ar 2               
00087Ar 2  38           	SEC				; set carry for subtract
00087Br 2  E5 0E        	SBC	TPos			; subtract terminal position
00087Dr 2  F1 AE        	SBC	(des_pl),Y		; subtract string length
00087Fr 2  B0 03        	BCS	LAB_185E		; branch if less than terminal width
000881r 2               
000881r 2  20 rr rr     	JSR	LAB_CRLF		; else print CR/LF
000884r 2               LAB_185E
000884r 2  20 rr rr     	JSR	LAB_18C6		; print string from Sutill/Sutilh
000887r 2  F0 C9        	BEQ	LAB_182C		; always go continue processing line
000889r 2               
000889r 2               ; CR/LF return to BASIC from BASIC input handler
000889r 2               
000889r 2               LAB_1866
000889r 2  A9 00        	LDA	#$00			; clear byte
00088Br 2  9D 0D 02     	STA	Ibuffs,X		; null terminate input
00088Er 2  A2 0D        	LDX	#<Ibuffs		; set X to buffer start-1 low byte
000890r 2  A0 02        	LDY	#>Ibuffs		; set Y to buffer start-1 high byte
000892r 2               
000892r 2               ; print CR/LF
000892r 2               
000892r 2               LAB_CRLF
000892r 2  A9 0D        	LDA	#$0D			; load [CR]
000894r 2  20 rr rr     	JSR	LAB_PRNA		; go print the character
000897r 2  A9 0A        	LDA	#$0A			; load [LF]
000899r 2  D0 52        	BNE	LAB_PRNA		; go print the character and return, branch always
00089Br 2               
00089Br 2               LAB_188B
00089Br 2  A5 0E        	LDA	TPos			; get terminal position
00089Dr 2  C5 10        	CMP	Iclim			; compare with input column limit
00089Fr 2  90 05        	BCC	LAB_1897		; branch if less
0008A1r 2               
0008A1r 2  20 rr rr     	JSR	LAB_CRLF		; else print CR/LF (next line)
0008A4r 2  D0 27        	BNE	LAB_18BD		; continue with PRINT processing (branch always)
0008A6r 2               
0008A6r 2               LAB_1897
0008A6r 2  38           	SEC				; set carry for subtract
0008A7r 2               LAB_1898
0008A7r 2  E5 64        	SBC	TabSiz		; subtract TAB size
0008A9r 2  B0 FC        	BCS	LAB_1898		; loop if result was +ve
0008ABr 2               
0008ABr 2  49 FF        	EOR	#$FF			; complement it
0008ADr 2  69 01        	ADC	#$01			; +1 (twos complement)
0008AFr 2  D0 12        	BNE	LAB_18B6		; always print A spaces (result is never $00)
0008B1r 2               
0008B1r 2               					; do TAB/SPC
0008B1r 2               LAB_18A2
0008B1r 2  48           	PHA				; save token
0008B2r 2  20 rr rr     	JSR	LAB_SGBY		; scan and get byte parameter
0008B5r 2  C9 29        	CMP	#$29			; is next character )
0008B7r 2  D0 7B        	BNE	LAB_1910		; if not do syntax error then warm start
0008B9r 2               
0008B9r 2  68           	PLA				; get token back
0008BAr 2  C9 AC        	CMP	#TK_TAB		; was it TAB ?
0008BCr 2  D0 06        	BNE	LAB_18B7		; if not go do SPC
0008BEr 2               
0008BEr 2               					; calculate TAB offset
0008BEr 2  8A           	TXA				; copy integer value to A
0008BFr 2  E5 0E        	SBC	TPos			; subtract terminal position
0008C1r 2  90 0A        	BCC	LAB_18BD		; branch if result was < 0 (can't TAB backwards)
0008C3r 2               
0008C3r 2               					; print A spaces
0008C3r 2               LAB_18B6
0008C3r 2  AA           	TAX				; copy result to X
0008C4r 2               LAB_18B7
0008C4r 2  8A           	TXA				; set flags on size for SPC
0008C5r 2  F0 06        	BEQ	LAB_18BD		; branch if result was = $0, already here
0008C7r 2               
0008C7r 2               					; print X spaces
0008C7r 2               LAB_18BA
0008C7r 2  20 rr rr     	JSR	LAB_18E0		; print " "
0008CAr 2  CA           	DEX				; decrement count
0008CBr 2  D0 FA        	BNE	LAB_18BA		; loop if not all done
0008CDr 2               
0008CDr 2               					; continue with PRINT processing
0008CDr 2               LAB_18BD
0008CDr 2  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
0008D0r 2  D0 85        	BNE	LAB_1831		; if more to print go do it
0008D2r 2               
0008D2r 2  60           	RTS
0008D3r 2               
0008D3r 2               ; print null terminated string from memory
0008D3r 2               
0008D3r 2               LAB_18C3
0008D3r 2  20 rr rr     	JSR	LAB_20AE		; print " terminated string to Sutill/Sutilh
0008D6r 2               
0008D6r 2               ; print string from Sutill/Sutilh
0008D6r 2               
0008D6r 2               LAB_18C6
0008D6r 2  20 rr rr     	JSR	LAB_22B6		; pop string off descriptor stack, or from top of string
0008D9r 2               					; space returns with A = length, X=$71=pointer low byte,
0008D9r 2               					; Y=$72=pointer high byte
0008D9r 2  A0 00        	LDY	#$00			; reset index
0008DBr 2  AA           	TAX				; copy length to X
0008DCr 2  F0 49        	BEQ	LAB_188C		; exit (RTS) if null string
0008DEr 2               
0008DEr 2               LAB_18CD
0008DEr 2               
0008DEr 2  B1 71        	LDA	(ut1_pl),Y		; get next byte
0008E0r 2  20 rr rr     	JSR	LAB_PRNA		; go print the character
0008E3r 2  C8           	INY				; increment index
0008E4r 2  CA           	DEX				; decrement count
0008E5r 2  D0 F7        	BNE	LAB_18CD		; loop if not done yet
0008E7r 2               
0008E7r 2  60           	RTS
0008E8r 2               
0008E8r 2               					; Print single format character
0008E8r 2               ; print " "
0008E8r 2               
0008E8r 2               LAB_18E0
0008E8r 2  A9 20        	LDA	#$20			; load " "
0008EAr 2  2C           	.byte	$2C			; change next line to BIT LAB_3FA9
0008EBr 2               
0008EBr 2               ; print "?" character
0008EBr 2               
0008EBr 2               LAB_18E3
0008EBr 2  A9 3F        	LDA	#$3F			; load "?" character
0008EDr 2               
0008EDr 2               ; print character in A
0008EDr 2               ; now includes the null handler
0008EDr 2               ; also includes infinite line length code
0008EDr 2               ; note! some routines expect this one to exit with Zb=0
0008EDr 2               
0008EDr 2               LAB_PRNA
0008EDr 2  C9 20        	CMP	#' '			; compare with " "
0008EFr 2  90 19        	BCC	LAB_18F9		; branch if less (non printing)
0008F1r 2               
0008F1r 2               					; else printable character
0008F1r 2  48           	PHA				; save the character
0008F2r 2               
0008F2r 2               ; don't check fit if terminal width byte is zero
0008F2r 2               
0008F2r 2  A5 0F        	LDA	TWidth		; get terminal width
0008F4r 2  D0 0A        	BNE	LAB_18F0		; branch if not zero (not infinite length)
0008F6r 2               
0008F6r 2               ; is "infinite line" so check TAB position
0008F6r 2               
0008F6r 2  A5 0E        	LDA	TPos			; get position
0008F8r 2  E5 64        	SBC	TabSiz		; subtract TAB size, carry set by CMP #$20 above
0008FAr 2  D0 0B        	BNE	LAB_18F7		; skip reset if different
0008FCr 2               
0008FCr 2  85 0E        	STA	TPos			; else reset position
0008FEr 2  F0 07        	BEQ	LAB_18F7		; go print character
000900r 2               
000900r 2               LAB_18F0
000900r 2  C5 0E        	CMP	TPos			; compare with terminal character position
000902r 2  D0 03        	BNE	LAB_18F7		; branch if not at end of line
000904r 2               
000904r 2  20 rr rr     	JSR	LAB_CRLF		; else print CR/LF
000907r 2               LAB_18F7
000907r 2  E6 0E        	INC	TPos			; increment terminal position
000909r 2  68           	PLA				; get character back
00090Ar 2               LAB_18F9
00090Ar 2  20 rr rr     	JSR	V_OUTP		; output byte via output vector
00090Dr 2  C9 0D        	CMP	#$0D			; compare with [CR]
00090Fr 2  D0 14        	BNE	LAB_188A		; branch if not [CR]
000911r 2               
000911r 2               					; else print nullct nulls after the [CR]
000911r 2  86 78        	STX	TempB			; save buffer index
000913r 2  A6 0D        	LDX	Nullct		; get null count
000915r 2  F0 0A        	BEQ	LAB_1886		; branch if no nulls
000917r 2               
000917r 2  A9 00        	LDA	#$00			; load [NULL]
000919r 2               LAB_1880
000919r 2  20 rr rr     	JSR	LAB_PRNA		; go print the character
00091Cr 2  CA           	DEX				; decrement count
00091Dr 2  D0 FA        	BNE	LAB_1880		; loop if not all done
00091Fr 2               
00091Fr 2  A9 0D        	LDA	#$0D			; restore the character (and set the flags)
000921r 2               LAB_1886
000921r 2  86 0E        	STX	TPos			; clear terminal position (X always = zero when we get here)
000923r 2  A6 78        	LDX	TempB			; restore buffer index
000925r 2               LAB_188A
000925r 2  29 FF        	AND	#$FF			; set the flags
000927r 2               LAB_188C
000927r 2  60           	RTS
000928r 2               
000928r 2               ; handle bad input data
000928r 2               
000928r 2               LAB_1904
000928r 2  A5 62        	LDA	Imode			; get input mode flag, $00=INPUT, $00=READ
00092Ar 2  10 0B        	BPL	LAB_1913		; branch if INPUT (go do redo)
00092Cr 2               
00092Cr 2  A5 8D        	LDA	Dlinel		; get current DATA line low byte
00092Er 2  A4 8E        	LDY	Dlineh		; get current DATA line high byte
000930r 2  85 87        	STA	Clinel		; save current line low byte
000932r 2  84 88        	STY	Clineh		; save current line high byte
000934r 2               LAB_1910
000934r 2  4C rr rr     	JMP	LAB_SNER		; do syntax error then warm start
000937r 2               
000937r 2               					; mode was INPUT
000937r 2               LAB_1913
000937r 2  A9 rr        	LDA	#<LAB_REDO		; point to redo message (low addr)
000939r 2  A0 rr        	LDY	#>LAB_REDO		; point to redo message (high addr)
00093Br 2  20 rr rr     	JSR	LAB_18C3		; print null terminated string from memory
00093Er 2  A5 8B        	LDA	Cpntrl		; get continue pointer low byte
000940r 2  A4 8C        	LDY	Cpntrh		; get continue pointer high byte
000942r 2  85 C3        	STA	Bpntrl		; save BASIC execute pointer low byte
000944r 2  84 C4        	STY	Bpntrh		; save BASIC execute pointer high byte
000946r 2  60           	RTS
000947r 2               
000947r 2               ; perform INPUT
000947r 2               
000947r 2               LAB_INPUT
000947r 2  C9 22        	CMP	#$22			; compare next byte with open quote
000949r 2  D0 0B        	BNE	LAB_1934		; branch if no prompt string
00094Br 2               
00094Br 2  20 rr rr     	JSR	LAB_1BC1		; print "..." string
00094Er 2  A9 3B        	LDA	#$3B			; load A with ";"
000950r 2  20 rr rr     	JSR	LAB_SCCA		; scan for CHR$(A), else do syntax error then warm start
000953r 2  20 rr rr     	JSR	LAB_18C6		; print string from Sutill/Sutilh
000956r 2               
000956r 2               					; done with prompt, now get data
000956r 2               LAB_1934
000956r 2  20 rr rr     	JSR	LAB_CKRN		; check not Direct, back here if ok
000959r 2  20 rr rr     	JSR	LAB_INLN		; print "? " and get BASIC input
00095Cr 2  A9 00        	LDA	#$00			; set mode = INPUT
00095Er 2  CD 0D 02     	CMP	Ibuffs		; test first byte in buffer
000961r 2  D0 0A        	BNE	LAB_1953		; branch if not null input
000963r 2               
000963r 2  18           	CLC				; was null input so clear carry to exit program
000964r 2  4C rr rr     	JMP	LAB_1647		; go do BREAK exit
000967r 2               
000967r 2               ; perform READ
000967r 2               
000967r 2               LAB_READ
000967r 2  A6 8F        	LDX	Dptrl			; get DATA pointer low byte
000969r 2  A4 90        	LDY	Dptrh			; get DATA pointer high byte
00096Br 2  A9 80        	LDA	#$80			; set mode = READ
00096Dr 2               
00096Dr 2               LAB_1953
00096Dr 2  85 62        	STA	Imode			; set input mode flag, $00=INPUT, $80=READ
00096Fr 2  86 91        	STX	Rdptrl		; save READ pointer low byte
000971r 2  84 92        	STY	Rdptrh		; save READ pointer high byte
000973r 2               
000973r 2               					; READ or INPUT next variable from list
000973r 2               LAB_195B
000973r 2  20 rr rr     	JSR	LAB_GVAR		; get (var) address
000976r 2  85 97        	STA	Lvarpl		; save address low byte
000978r 2  84 98        	STY	Lvarph		; save address high byte
00097Ar 2  A5 C3        	LDA	Bpntrl		; get BASIC execute pointer low byte
00097Cr 2  A4 C4        	LDY	Bpntrh		; get BASIC execute pointer high byte
00097Er 2  85 11        	STA	Itempl		; save as temporary integer low byte
000980r 2  84 12        	STY	Itemph		; save as temporary integer high byte
000982r 2  A6 91        	LDX	Rdptrl		; get READ pointer low byte
000984r 2  A4 92        	LDY	Rdptrh		; get READ pointer high byte
000986r 2  86 C3        	STX	Bpntrl		; set BASIC execute pointer low byte
000988r 2  84 C4        	STY	Bpntrh		; set BASIC execute pointer high byte
00098Ar 2  20 C2 00     	JSR	LAB_GBYT		; scan memory
00098Dr 2  D0 11        	BNE	LAB_1988		; branch if not null
00098Fr 2               
00098Fr 2               					; pointer was to null entry
00098Fr 2  24 62        	BIT	Imode			; test input mode flag, $00=INPUT, $80=READ
000991r 2  30 65        	BMI	LAB_19DD		; branch if READ
000993r 2               
000993r 2               					; mode was INPUT
000993r 2  20 rr rr     	JSR	LAB_18E3		; print "?" character (double ? for extended input)
000996r 2  20 rr rr     	JSR	LAB_INLN		; print "? " and get BASIC input
000999r 2  86 C3        	STX	Bpntrl		; set BASIC execute pointer low byte
00099Br 2  84 C4        	STY	Bpntrh		; set BASIC execute pointer high byte
00099Dr 2               LAB_1985
00099Dr 2  20 C2 00     	JSR	LAB_GBYT		; scan memory
0009A0r 2               LAB_1988
0009A0r 2  24 5F        	BIT	Dtypef		; test data type flag, $FF=string, $00=numeric
0009A2r 2  10 24        	BPL	LAB_19B0		; branch if numeric
0009A4r 2               
0009A4r 2               					; else get string
0009A4r 2  85 5B        	STA	Srchc			; save search character
0009A6r 2  C9 22        	CMP	#$22			; was it " ?
0009A8r 2  F0 07        	BEQ	LAB_1999		; branch if so
0009AAr 2               
0009AAr 2  A9 3A        	LDA	#':'			; else search character is ":"
0009ACr 2  85 5B        	STA	Srchc			; set new search character
0009AEr 2  A9 2C        	LDA	#','			; other search character is ","
0009B0r 2  18           	CLC				; clear carry for add
0009B1r 2               LAB_1999
0009B1r 2  85 5C        	STA	Asrch			; set second search character
0009B3r 2  A5 C3        	LDA	Bpntrl		; get BASIC execute pointer low byte
0009B5r 2  A4 C4        	LDY	Bpntrh		; get BASIC execute pointer high byte
0009B7r 2               
0009B7r 2  69 00        	ADC	#$00			; c is =1 if we came via the BEQ LAB_1999, else =0
0009B9r 2  90 01        	BCC	LAB_19A4		; branch if no execute pointer low byte rollover
0009BBr 2               
0009BBr 2  C8           	INY				; else increment high byte
0009BCr 2               LAB_19A4
0009BCr 2  20 rr rr     	JSR	LAB_20B4		; print Srchc or Asrch terminated string to Sutill/Sutilh
0009BFr 2  20 rr rr     	JSR	LAB_23F3		; restore BASIC execute pointer from temp (Btmpl/Btmph)
0009C2r 2  20 rr rr     	JSR	LAB_17D5		; go do string LET
0009C5r 2  4C rr rr     	JMP	LAB_19B6		; go check string terminator
0009C8r 2               
0009C8r 2               					; get numeric INPUT
0009C8r 2               LAB_19B0
0009C8r 2  20 rr rr     	JSR	LAB_2887		; get FAC1 from string
0009CBr 2  20 rr rr     	JSR	LAB_PFAC		; pack FAC1 into (Lvarpl)
0009CEr 2               LAB_19B6
0009CEr 2  20 C2 00     	JSR	LAB_GBYT		; scan memory
0009D1r 2  F0 0A        	BEQ	LAB_19C5		; branch if null (last entry)
0009D3r 2               
0009D3r 2  C9 2C        	CMP	#','			; else compare with ","
0009D5r 2  F0 03        	BEQ	LAB_19C2		; branch if ","
0009D7r 2               
0009D7r 2  4C rr rr     	JMP	LAB_1904		; else go handle bad input data
0009DAr 2               
0009DAr 2               					; got good input data
0009DAr 2               LAB_19C2
0009DAr 2  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
0009DDr 2               LAB_19C5
0009DDr 2  A5 C3        	LDA	Bpntrl		; get BASIC execute pointer low byte (temp READ/INPUT ptr)
0009DFr 2  A4 C4        	LDY	Bpntrh		; get BASIC execute pointer high byte (temp READ/INPUT ptr)
0009E1r 2  85 91        	STA	Rdptrl		; save for now
0009E3r 2  84 92        	STY	Rdptrh		; save for now
0009E5r 2  A5 11        	LDA	Itempl		; get temporary integer low byte (temp BASIC execute ptr)
0009E7r 2  A4 12        	LDY	Itemph		; get temporary integer high byte (temp BASIC execute ptr)
0009E9r 2  85 C3        	STA	Bpntrl		; set BASIC execute pointer low byte
0009EBr 2  84 C4        	STY	Bpntrh		; set BASIC execute pointer high byte
0009EDr 2  20 C2 00     	JSR	LAB_GBYT		; scan memory
0009F0r 2  F0 2C        	BEQ	LAB_1A03		; if null go do extra ignored message
0009F2r 2               
0009F2r 2  20 rr rr     	JSR	LAB_1C01		; else scan for "," , else do syntax error then warm start
0009F5r 2  4C rr rr     	JMP	LAB_195B		; go INPUT next variable from list
0009F8r 2               
0009F8r 2               					; find next DATA statement or do "Out of DATA" error
0009F8r 2               LAB_19DD
0009F8r 2  20 rr rr     	JSR	LAB_SNBS		; scan for next BASIC statement ([:] or [EOL])
0009FBr 2  C8           	INY				; increment index
0009FCr 2  AA           	TAX				; copy character ([:] or [EOL])
0009FDr 2  D0 12        	BNE	LAB_19F6		; branch if [:]
0009FFr 2               
0009FFr 2  A2 06        	LDX	#$06			; set for "Out of DATA" error
000A01r 2  C8           	INY				; increment index, now points to next line pointer high byte
000A02r 2  B1 C3        	LDA	(Bpntrl),Y		; get next line pointer high byte
000A04r 2  F0 73        	BEQ	LAB_1A54		; branch if end (eventually does error X)
000A06r 2               
000A06r 2  C8           	INY				; increment index
000A07r 2  B1 C3        	LDA	(Bpntrl),Y		; get next line # low byte
000A09r 2  85 8D        	STA	Dlinel		; save current DATA line low byte
000A0Br 2  C8           	INY				; increment index
000A0Cr 2  B1 C3        	LDA	(Bpntrl),Y		; get next line # high byte
000A0Er 2  C8           	INY				; increment index
000A0Fr 2  85 8E        	STA	Dlineh		; save current DATA line high byte
000A11r 2               LAB_19F6
000A11r 2  B1 C3        	LDA	(Bpntrl),Y		; get byte
000A13r 2  C8           	INY				; increment index
000A14r 2  AA           	TAX				; copy to X
000A15r 2  20 rr rr     	JSR	LAB_170F		; set BASIC execute pointer
000A18r 2  E0 83        	CPX	#TK_DATA		; compare with "DATA" token
000A1Ar 2  F0 81        	BEQ	LAB_1985		; was "DATA" so go do next READ
000A1Cr 2               
000A1Cr 2  D0 DA        	BNE	LAB_19DD		; go find next statement if not "DATA"
000A1Er 2               
000A1Er 2               ; end of INPUT/READ routine
000A1Er 2               
000A1Er 2               LAB_1A03
000A1Er 2  A5 91        	LDA	Rdptrl		; get temp READ pointer low byte
000A20r 2  A4 92        	LDY	Rdptrh		; get temp READ pointer high byte
000A22r 2  A6 62        	LDX	Imode			; get input mode flag, $00=INPUT, $80=READ
000A24r 2  10 03        	BPL	LAB_1A0E		; branch if INPUT
000A26r 2               
000A26r 2  4C rr rr     	JMP	LAB_1624		; save AY as DATA pointer and return
000A29r 2               
000A29r 2               					; we were getting INPUT
000A29r 2               LAB_1A0E
000A29r 2  A0 00        	LDY	#$00			; clear index
000A2Br 2  B1 91        	LDA	(Rdptrl),Y		; get next byte
000A2Dr 2  D0 01        	BNE	LAB_1A1B		; error if not end of INPUT
000A2Fr 2               
000A2Fr 2  60           	RTS
000A30r 2               
000A30r 2               					; user typed too much
000A30r 2               LAB_1A1B
000A30r 2  A9 rr        	LDA	#<LAB_IMSG		; point to extra ignored message (low addr)
000A32r 2  A0 rr        	LDY	#>LAB_IMSG		; point to extra ignored message (high addr)
000A34r 2  4C rr rr     	JMP	LAB_18C3		; print null terminated string from memory and return
000A37r 2               
000A37r 2               ; search the stack for FOR activity
000A37r 2               ; exit with z=1 if FOR else exit with z=0
000A37r 2               
000A37r 2               LAB_11A1
000A37r 2  BA           	TSX				; copy stack pointer
000A38r 2  E8           	INX				; +1 pass return address
000A39r 2  E8           	INX				; +2 pass return address
000A3Ar 2  E8           	INX				; +3 pass calling routine return address
000A3Br 2  E8           	INX				; +4 pass calling routine return address
000A3Cr 2               LAB_11A6
000A3Cr 2  BD 01 01     	LDA	LAB_STAK+1,X	; get token byte from stack
000A3Fr 2  C9 81        	CMP	#TK_FOR		; is it FOR token
000A41r 2  D0 21        	BNE	LAB_11CE		; exit if not FOR token
000A43r 2               
000A43r 2               					; was FOR token
000A43r 2  A5 98        	LDA	Frnxth		; get var pointer for FOR/NEXT high byte
000A45r 2  D0 0A        	BNE	LAB_11BB		; branch if not null
000A47r 2               
000A47r 2  BD 02 01     	LDA	LAB_STAK+2,X	; get FOR variable pointer low byte
000A4Ar 2  85 97        	STA	Frnxtl		; save var pointer for FOR/NEXT low byte
000A4Cr 2  BD 03 01     	LDA	LAB_STAK+3,X	; get FOR variable pointer high byte
000A4Fr 2  85 98        	STA	Frnxth		; save var pointer for FOR/NEXT high byte
000A51r 2               LAB_11BB
000A51r 2  DD 03 01     	CMP	LAB_STAK+3,X	; compare var pointer with stacked var pointer (high byte)
000A54r 2  D0 07        	BNE	LAB_11C7		; branch if no match
000A56r 2               
000A56r 2  A5 97        	LDA	Frnxtl		; get var pointer for FOR/NEXT low byte
000A58r 2  DD 02 01     	CMP	LAB_STAK+2,X	; compare var pointer with stacked var pointer (low byte)
000A5Br 2  F0 07        	BEQ	LAB_11CE		; exit if match found
000A5Dr 2               
000A5Dr 2               LAB_11C7
000A5Dr 2  8A           	TXA				; copy index
000A5Er 2  18           	CLC				; clear carry for add
000A5Fr 2  69 10        	ADC	#$10			; add FOR stack use size
000A61r 2  AA           	TAX				; copy back to index
000A62r 2  D0 D8        	BNE	LAB_11A6		; loop if not at start of stack
000A64r 2               
000A64r 2               LAB_11CE
000A64r 2  60           	RTS
000A65r 2               
000A65r 2               ; perform NEXT
000A65r 2               
000A65r 2               LAB_NEXT
000A65r 2  D0 04        	BNE	LAB_1A46		; branch if NEXT var
000A67r 2               
000A67r 2  A0 00        	LDY	#$00			; else clear Y
000A69r 2  F0 03        	BEQ	LAB_1A49		; branch always (no variable to search for)
000A6Br 2               
000A6Br 2               ; NEXT var
000A6Br 2               
000A6Br 2               LAB_1A46
000A6Br 2  20 rr rr     	JSR	LAB_GVAR		; get variable address
000A6Er 2               LAB_1A49
000A6Er 2  85 97        	STA	Frnxtl		; store variable pointer low byte
000A70r 2  84 98        	STY	Frnxth		; store variable pointer high byte
000A72r 2               					; (both cleared if no variable defined)
000A72r 2  20 rr rr     	JSR	LAB_11A1		; search the stack for FOR activity
000A75r 2  F0 04        	BEQ	LAB_1A56		; branch if found
000A77r 2               
000A77r 2  A2 00        	LDX	#$00			; else set error $00 ("NEXT without FOR" error)
000A79r 2               LAB_1A54
000A79r 2  F0 63        	BEQ	LAB_1ABE		; do error #X, then warm start
000A7Br 2               
000A7Br 2               LAB_1A56
000A7Br 2  9A           	TXS				; set stack pointer, X set by search, dumps return addresses
000A7Cr 2               
000A7Cr 2  8A           	TXA				; copy stack pointer
000A7Dr 2  38           	SEC				; set carry for subtract
000A7Er 2  E9 F7        	SBC	#$F7			; point to TO var
000A80r 2  85 73        	STA	ut2_pl		; save pointer to TO var for compare
000A82r 2  69 FB        	ADC	#$FB			; point to STEP var
000A84r 2               
000A84r 2  A0 01        	LDY	#>LAB_STAK		; point to stack page high byte
000A86r 2  20 rr rr     	JSR	LAB_UFAC		; unpack memory (STEP value) into FAC1
000A89r 2  BA           	TSX				; get stack pointer back
000A8Ar 2  BD 08 01     	LDA	LAB_STAK+8,X	; get step sign
000A8Dr 2  85 B0        	STA	FAC1_s		; save FAC1 sign (b7)
000A8Fr 2  A5 97        	LDA	Frnxtl		; get FOR variable pointer low byte
000A91r 2  A4 98        	LDY	Frnxth		; get FOR variable pointer high byte
000A93r 2  20 rr rr     	JSR	LAB_246C		; add (FOR variable) to FAC1
000A96r 2  20 rr rr     	JSR	LAB_PFAC		; pack FAC1 into (FOR variable)
000A99r 2  A0 01        	LDY	#>LAB_STAK		; point to stack page high byte
000A9Br 2  20 rr rr     	JSR	LAB_27FA		; compare FAC1 with (Y,ut2_pl) (TO value)
000A9Er 2  BA           	TSX				; get stack pointer back
000A9Fr 2  DD 08 01     	CMP	LAB_STAK+8,X	; compare step sign
000AA2r 2  F0 17        	BEQ	LAB_1A9B		; branch if = (loop complete)
000AA4r 2               
000AA4r 2               					; loop back and do it all again
000AA4r 2  BD 0D 01     	LDA	LAB_STAK+$0D,X	; get FOR line low byte
000AA7r 2  85 87        	STA	Clinel		; save current line low byte
000AA9r 2  BD 0E 01     	LDA	LAB_STAK+$0E,X	; get FOR line high byte
000AACr 2  85 88        	STA	Clineh		; save current line high byte
000AAEr 2  BD 10 01     	LDA	LAB_STAK+$10,X	; get BASIC execute pointer low byte
000AB1r 2  85 C3        	STA	Bpntrl		; save BASIC execute pointer low byte
000AB3r 2  BD 0F 01     	LDA	LAB_STAK+$0F,X	; get BASIC execute pointer high byte
000AB6r 2  85 C4        	STA	Bpntrh		; save BASIC execute pointer high byte
000AB8r 2               LAB_1A98
000AB8r 2  4C rr rr     	JMP	LAB_15C2		; go do interpreter inner loop
000ABBr 2               
000ABBr 2               					; loop complete so carry on
000ABBr 2               LAB_1A9B
000ABBr 2  8A           	TXA				; stack copy to A
000ABCr 2  69 0F        	ADC	#$0F			; add $10 ($0F+carry) to dump FOR structure
000ABEr 2  AA           	TAX				; copy back to index
000ABFr 2  9A           	TXS				; copy to stack pointer
000AC0r 2  20 C2 00     	JSR	LAB_GBYT		; scan memory
000AC3r 2  C9 2C        	CMP	#','			; compare with ","
000AC5r 2  D0 F1        	BNE	LAB_1A98		; branch if not "," (go do interpreter inner loop)
000AC7r 2               
000AC7r 2               					; was "," so another NEXT variable to do
000AC7r 2  20 BC 00     	JSR	LAB_IGBY		; else increment and scan memory
000ACAr 2  20 rr rr     	JSR	LAB_1A46		; do NEXT (var)
000ACDr 2               
000ACDr 2               ; evaluate expression and check is numeric, else do type mismatch
000ACDr 2               
000ACDr 2               LAB_EVNM
000ACDr 2  20 rr rr     	JSR	LAB_EVEX		; evaluate expression
000AD0r 2               
000AD0r 2               ; check if source is numeric, else do type mismatch
000AD0r 2               
000AD0r 2               LAB_CTNM
000AD0r 2  18           	CLC				; destination is numeric
000AD1r 2  24           	.byte	$24			; makes next line BIT $38
000AD2r 2               
000AD2r 2               ; check if source is string, else do type mismatch
000AD2r 2               
000AD2r 2               LAB_CTST
000AD2r 2  38           	SEC				; required type is string
000AD3r 2               
000AD3r 2               ; type match check, set C for string, clear C for numeric
000AD3r 2               
000AD3r 2               LAB_CKTM
000AD3r 2  24 5F        	BIT	Dtypef		; test data type flag, $FF=string, $00=numeric
000AD5r 2  30 03        	BMI	LAB_1ABA		; branch if data type is string
000AD7r 2               
000AD7r 2               					; else data type was numeric
000AD7r 2  B0 03        	BCS	LAB_1ABC		; if required type is string do type mismatch error
000AD9r 2               LAB_1AB9
000AD9r 2  60           	RTS
000ADAr 2               
000ADAr 2               					; data type was string, now check required type
000ADAr 2               LAB_1ABA
000ADAr 2  B0 FD        	BCS	LAB_1AB9		; exit if required type is string
000ADCr 2               
000ADCr 2               					; else do type mismatch error
000ADCr 2               LAB_1ABC
000ADCr 2  A2 18        	LDX	#$18			; error code $18 ("Type mismatch" error)
000ADEr 2               LAB_1ABE
000ADEr 2  4C rr rr     	JMP	LAB_XERR		; do error #X, then warm start
000AE1r 2               
000AE1r 2               ; evaluate expression
000AE1r 2               
000AE1r 2               LAB_EVEX
000AE1r 2  A6 C3        	LDX	Bpntrl		; get BASIC execute pointer low byte
000AE3r 2  D0 02        	BNE	LAB_1AC7		; skip next if not zero
000AE5r 2               
000AE5r 2  C6 C4        	DEC	Bpntrh		; else decrement BASIC execute pointer high byte
000AE7r 2               LAB_1AC7
000AE7r 2  C6 C3        	DEC	Bpntrl		; decrement BASIC execute pointer low byte
000AE9r 2               
000AE9r 2               LAB_EVEZ
000AE9r 2  A9 00        	LDA	#$00			; set null precedence (flag done)
000AEBr 2               LAB_1ACC
000AEBr 2  48           	PHA				; push precedence byte
000AECr 2  A9 02        	LDA	#$02			; 2 bytes
000AEEr 2  20 rr rr     	JSR	LAB_1212		; check room on stack for A bytes
000AF1r 2  20 rr rr     	JSR	LAB_GVAL		; get value from line
000AF4r 2  A9 00        	LDA	#$00			; clear A
000AF6r 2  85 9B        	STA	comp_f		; clear compare function flag
000AF8r 2               LAB_1ADB
000AF8r 2  20 C2 00     	JSR	LAB_GBYT		; scan memory
000AFBr 2               LAB_1ADE
000AFBr 2  38           	SEC				; set carry for subtract
000AFCr 2  E9 C1        	SBC	#TK_GT		; subtract token for > (lowest comparison function)
000AFEr 2  90 17        	BCC	LAB_1AFA		; branch if < TK_GT
000B00r 2               
000B00r 2  C9 03        	CMP	#$03			; compare with ">" to "<" tokens
000B02r 2  B0 13        	BCS	LAB_1AFA		; branch if >= TK_SGN (highest evaluation function +1)
000B04r 2               
000B04r 2               					; was token for > = or < (A = 0, 1 or 2)
000B04r 2  C9 01        	CMP	#$01			; compare with token for =
000B06r 2  2A           	ROL				; *2, b0 = carry (=1 if token was = or <)
000B07r 2               					; (A = 0, 3 or 5)
000B07r 2  49 01        	EOR	#$01			; toggle b0
000B09r 2               					; (A = 1, 2 or 4. 1 if >, 2 if =, 4 if <)
000B09r 2  45 9B        	EOR	comp_f		; EOR with compare function flag bits
000B0Br 2  C5 9B        	CMP	comp_f		; compare with compare function flag
000B0Dr 2  90 67        	BCC	LAB_1B53		; if <(comp_f) do syntax error then warm start
000B0Fr 2               					; was more than one <, = or >)
000B0Fr 2               
000B0Fr 2  85 9B        	STA	comp_f		; save new compare function flag
000B11r 2  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
000B14r 2  4C rr rr     	JMP	LAB_1ADE		; go do next character
000B17r 2               
000B17r 2               					; token is < ">" or > "<" tokens
000B17r 2               LAB_1AFA
000B17r 2  A6 9B        	LDX	comp_f		; get compare function flag
000B19r 2  D0 2C        	BNE	LAB_1B2A		; branch if compare function
000B1Br 2               
000B1Br 2  B0 79        	BCS	LAB_1B78		; go do functions
000B1Dr 2               
000B1Dr 2               					; else was <  TK_GT so is operator or lower
000B1Dr 2  69 0A        	ADC	#TK_GT-TK_PLUS	; add # of operators (+, -, *, /, ^, AND, OR or EOR)
000B1Fr 2  90 75        	BCC	LAB_1B78		; branch if < + operator
000B21r 2               
000B21r 2               					; carry was set so token was +, -, *, /, ^, AND, OR or EOR
000B21r 2  D0 07        	BNE	LAB_1B0B		; branch if not + token
000B23r 2               
000B23r 2  24 5F        	BIT	Dtypef		; test data type flag, $FF=string, $00=numeric
000B25r 2  10 03        	BPL	LAB_1B0B		; branch if not string
000B27r 2               
000B27r 2               					; will only be $00 if type is string and token was +
000B27r 2  4C rr rr     	JMP	LAB_224D		; add strings, string 1 is in descriptor des_pl, string 2
000B2Ar 2               					; is in line, and return
000B2Ar 2               
000B2Ar 2               LAB_1B0B
000B2Ar 2  85 71        	STA	ut1_pl		; save it
000B2Cr 2  0A           	ASL				; *2
000B2Dr 2  65 71        	ADC	ut1_pl		; *3
000B2Fr 2  A8           	TAY				; copy to index
000B30r 2               LAB_1B13
000B30r 2  68           	PLA				; pull previous precedence
000B31r 2  D9 rr rr     	CMP	LAB_OPPT,Y		; compare with precedence byte
000B34r 2  B0 65        	BCS	LAB_1B7D		; branch if A >=
000B36r 2               
000B36r 2  20 rr rr     	JSR	LAB_CTNM		; check if source is numeric, else do type mismatch
000B39r 2               LAB_1B1C
000B39r 2  48           	PHA				; save precedence
000B3Ar 2               LAB_1B1D
000B3Ar 2  20 rr rr     	JSR	LAB_1B43		; get vector, execute function then continue evaluation
000B3Dr 2  68           	PLA				; restore precedence
000B3Er 2  A4 99        	LDY	prstk			; get precedence stacked flag
000B40r 2  10 19        	BPL	LAB_1B3C		; branch if stacked values
000B42r 2               
000B42r 2  AA           	TAX				; copy precedence (set flags)
000B43r 2  F0 76        	BEQ	LAB_1B9D		; exit if done
000B45r 2               
000B45r 2  D0 5D        	BNE	LAB_1B86		; else pop FAC2 and return, branch always
000B47r 2               
000B47r 2               LAB_1B2A
000B47r 2  26 5F        	ROL	Dtypef		; shift data type flag into Cb
000B49r 2  8A           	TXA				; copy compare function flag
000B4Ar 2  85 5F        	STA	Dtypef		; clear data type flag, X is 0xxx xxxx
000B4Cr 2  2A           	ROL				; shift data type into compare function byte b0
000B4Dr 2  A6 C3        	LDX	Bpntrl		; get BASIC execute pointer low byte
000B4Fr 2  D0 02        	BNE	LAB_1B34		; branch if no underflow
000B51r 2               
000B51r 2  C6 C4        	DEC	Bpntrh		; else decrement BASIC execute pointer high byte
000B53r 2               LAB_1B34
000B53r 2  C6 C3        	DEC	Bpntrl		; decrement BASIC execute pointer low byte
000B55r 2               TK_LT_PLUS	= TK_LT-TK_PLUS
000B55r 2  A0 24        	LDY	#TK_LT_PLUS*3	; set offset to last operator entry
000B57r 2  85 9B        	STA	comp_f		; save new compare function flag
000B59r 2  D0 D5        	BNE	LAB_1B13		; branch always
000B5Br 2               
000B5Br 2               LAB_1B3C
000B5Br 2  D9 rr rr     	CMP	LAB_OPPT,Y		;.compare with stacked function precedence
000B5Er 2  B0 44        	BCS	LAB_1B86		; branch if A >=, pop FAC2 and return
000B60r 2               
000B60r 2  90 D7        	BCC	LAB_1B1C		; branch always
000B62r 2               
000B62r 2               ;.get vector, execute function then continue evaluation
000B62r 2               
000B62r 2               LAB_1B43
000B62r 2  B9 rr rr     	LDA	LAB_OPPT+2,Y	; get function vector high byte
000B65r 2  48           	PHA				; onto stack
000B66r 2  B9 rr rr     	LDA	LAB_OPPT+1,Y	; get function vector low byte
000B69r 2  48           	PHA				; onto stack
000B6Ar 2               					; now push sign, round FAC1 and put on stack
000B6Ar 2  20 rr rr     	JSR	LAB_1B5B		; function will return here, then the next RTS will call
000B6Dr 2               					; the function
000B6Dr 2  A5 9B        	LDA	comp_f		; get compare function flag
000B6Fr 2  48           	PHA				; push compare evaluation byte
000B70r 2  B9 rr rr     	LDA	LAB_OPPT,Y		; get precedence byte
000B73r 2  4C rr rr     	JMP	LAB_1ACC		; continue evaluating expression
000B76r 2               
000B76r 2               LAB_1B53
000B76r 2  4C rr rr     	JMP	LAB_SNER		; do syntax error then warm start
000B79r 2               
000B79r 2               ; push sign, round FAC1 and put on stack
000B79r 2               
000B79r 2               LAB_1B5B
000B79r 2  68           	PLA				; get return addr low byte
000B7Ar 2  85 71        	STA	ut1_pl		; save it
000B7Cr 2  E6 71        	INC	ut1_pl		; increment it (was ret-1 pushed? yes!)
000B7Er 2               					; note! no check is made on the high byte! if the calling
000B7Er 2               					; routine assembles to a page edge then this all goes
000B7Er 2               					; horribly wrong !!!
000B7Er 2  68           	PLA				; get return addr high byte
000B7Fr 2  85 72        	STA	ut1_ph		; save it
000B81r 2  A5 B0        	LDA	FAC1_s		; get FAC1 sign (b7)
000B83r 2  48           	PHA				; push sign
000B84r 2               
000B84r 2               ; round FAC1 and put on stack
000B84r 2               
000B84r 2               LAB_1B66
000B84r 2  20 rr rr     	JSR	LAB_27BA		; round FAC1
000B87r 2  A5 AF        	LDA	FAC1_3		; get FAC1 mantissa3
000B89r 2  48           	PHA				; push on stack
000B8Ar 2  A5 AE        	LDA	FAC1_2		; get FAC1 mantissa2
000B8Cr 2  48           	PHA				; push on stack
000B8Dr 2  A5 AD        	LDA	FAC1_1		; get FAC1 mantissa1
000B8Fr 2  48           	PHA				; push on stack
000B90r 2  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
000B92r 2  48           	PHA				; push on stack
000B93r 2  6C 71 00     	JMP	(ut1_pl)		; return, sort of
000B96r 2               
000B96r 2               ; do functions
000B96r 2               
000B96r 2               LAB_1B78
000B96r 2  A0 FF        	LDY	#$FF			; flag function
000B98r 2  68           	PLA				; pull precedence byte
000B99r 2               LAB_1B7B
000B99r 2  F0 20        	BEQ	LAB_1B9D		; exit if done
000B9Br 2               
000B9Br 2               LAB_1B7D
000B9Br 2  C9 64        	CMP	#$64			; compare previous precedence with $64
000B9Dr 2  F0 03        	BEQ	LAB_1B84		; branch if was $64 (< function)
000B9Fr 2               
000B9Fr 2  20 rr rr     	JSR	LAB_CTNM		; check if source is numeric, else do type mismatch
000BA2r 2               LAB_1B84
000BA2r 2  84 99        	STY	prstk			; save precedence stacked flag
000BA4r 2               
000BA4r 2               					; pop FAC2 and return
000BA4r 2               LAB_1B86
000BA4r 2  68           	PLA				; pop byte
000BA5r 2  4A           	LSR				; shift out comparison evaluation lowest bit
000BA6r 2  85 63        	STA	Cflag			; save comparison evaluation flag
000BA8r 2  68           	PLA				; pop exponent
000BA9r 2  85 B3        	STA	FAC2_e		; save FAC2 exponent
000BABr 2  68           	PLA				; pop mantissa1
000BACr 2  85 B4        	STA	FAC2_1		; save FAC2 mantissa1
000BAEr 2  68           	PLA				; pop mantissa2
000BAFr 2  85 B5        	STA	FAC2_2		; save FAC2 mantissa2
000BB1r 2  68           	PLA				; pop mantissa3
000BB2r 2  85 B6        	STA	FAC2_3		; save FAC2 mantissa3
000BB4r 2  68           	PLA				; pop sign
000BB5r 2  85 B7        	STA	FAC2_s		; save FAC2 sign (b7)
000BB7r 2  45 B0        	EOR	FAC1_s		; EOR FAC1 sign (b7)
000BB9r 2  85 B8        	STA	FAC_sc		; save sign compare (FAC1 EOR FAC2)
000BBBr 2               LAB_1B9D
000BBBr 2  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
000BBDr 2  60           	RTS
000BBEr 2               
000BBEr 2               ; print "..." string to string util area
000BBEr 2               
000BBEr 2               LAB_1BC1
000BBEr 2  A5 C3        	LDA	Bpntrl		; get BASIC execute pointer low byte
000BC0r 2  A4 C4        	LDY	Bpntrh		; get BASIC execute pointer high byte
000BC2r 2  69 00        	ADC	#$00			; add carry to low byte
000BC4r 2  90 01        	BCC	LAB_1BCA		; branch if no overflow
000BC6r 2               
000BC6r 2  C8           	INY				; increment high byte
000BC7r 2               LAB_1BCA
000BC7r 2  20 rr rr     	JSR	LAB_20AE		; print " terminated string to Sutill/Sutilh
000BCAr 2  4C rr rr     	JMP	LAB_23F3		; restore BASIC execute pointer from temp and return
000BCDr 2               
000BCDr 2               ; get value from line
000BCDr 2               
000BCDr 2               LAB_GVAL
000BCDr 2  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
000BD0r 2  B0 03        	BCS	LAB_1BAC		; branch if not numeric character
000BD2r 2               
000BD2r 2               					; else numeric string found (e.g. 123)
000BD2r 2               LAB_1BA9
000BD2r 2  4C rr rr     	JMP	LAB_2887		; get FAC1 from string and return
000BD5r 2               
000BD5r 2               ; get value from line .. continued
000BD5r 2               
000BD5r 2               					; wasn't a number so ..
000BD5r 2               LAB_1BAC
000BD5r 2  AA           	TAX				; set the flags
000BD6r 2  30 2F        	BMI	LAB_1BD0		; if -ve go test token values
000BD8r 2               
000BD8r 2               					; else it is either a string, number, variable or (<expr>)
000BD8r 2  C9 24        	CMP	#'$'			; compare with "$"
000BDAr 2  F0 F6        	BEQ	LAB_1BA9		; branch if "$", hex number
000BDCr 2               
000BDCr 2  C9 25        	CMP	#'%'			; else compare with "%"
000BDEr 2  F0 F2        	BEQ	LAB_1BA9		; branch if "%", binary number
000BE0r 2               
000BE0r 2  C9 2E        	CMP	#'.'			; compare with "."
000BE2r 2  F0 EE        	BEQ	LAB_1BA9		; if so get FAC1 from string and return (e.g. was .123)
000BE4r 2               
000BE4r 2               					; it wasn't any sort of number so ..
000BE4r 2  C9 22        	CMP	#$22			; compare with "
000BE6r 2  F0 D6        	BEQ	LAB_1BC1		; branch if open quote
000BE8r 2               
000BE8r 2               					; wasn't any sort of number so ..
000BE8r 2               
000BE8r 2               ; evaluate expression within parentheses
000BE8r 2               
000BE8r 2  C9 28        	CMP	#'('			; compare with "("
000BEAr 2  D0 4F        	BNE	LAB_1C18		; if not "(" get (var), return value in FAC1 and $ flag
000BECr 2               
000BECr 2               LAB_1BF7
000BECr 2  20 rr rr     	JSR	LAB_EVEZ		; evaluate expression, no decrement
000BEFr 2               
000BEFr 2               ; all the "scan for" routines return the character after the sought character
000BEFr 2               
000BEFr 2               ; scan for ")" , else do syntax error then warm start
000BEFr 2               
000BEFr 2               LAB_1BFB
000BEFr 2  A9 29        	LDA	#$29			; load A with ")"
000BF1r 2               
000BF1r 2               ; scan for CHR$(A) , else do syntax error then warm start
000BF1r 2               
000BF1r 2               LAB_SCCA
000BF1r 2  A0 00        	LDY	#$00			; clear index
000BF3r 2  D1 C3        	CMP	(Bpntrl),Y		; check next byte is = A
000BF5r 2  D0 0B        	BNE	LAB_SNER		; if not do syntax error then warm start
000BF7r 2               
000BF7r 2  4C BC 00     	JMP	LAB_IGBY		; increment and scan memory then return
000BFAr 2               
000BFAr 2               ; scan for "(" , else do syntax error then warm start
000BFAr 2               
000BFAr 2               LAB_1BFE
000BFAr 2  A9 28        	LDA	#$28			; load A with "("
000BFCr 2  D0 F3        	BNE	LAB_SCCA		; scan for CHR$(A), else do syntax error then warm start
000BFEr 2               					; (branch always)
000BFEr 2               
000BFEr 2               ; scan for "," , else do syntax error then warm start
000BFEr 2               
000BFEr 2               LAB_1C01
000BFEr 2  A9 2C        	LDA	#$2C			; load A with ","
000C00r 2  D0 EF        	BNE	LAB_SCCA		; scan for CHR$(A), else do syntax error then warm start
000C02r 2               					; (branch always)
000C02r 2               
000C02r 2               ; syntax error then warm start
000C02r 2               
000C02r 2               LAB_SNER
000C02r 2  A2 02        	LDX	#$02			; error code $02 ("Syntax" error)
000C04r 2  4C rr rr     	JMP	LAB_XERR		; do error #X, then warm start
000C07r 2               
000C07r 2               ; get value from line .. continued
000C07r 2               ; do tokens
000C07r 2               
000C07r 2               LAB_1BD0
000C07r 2  C9 B8        	CMP	#TK_MINUS		; compare with token for -
000C09r 2  F0 29        	BEQ	LAB_1C11		; branch if - token (do set-up for functions)
000C0Br 2               
000C0Br 2               					; wasn't -n so ..
000C0Br 2  C9 B7        	CMP	#TK_PLUS		; compare with token for +
000C0Dr 2  F0 BE        	BEQ	LAB_GVAL		; branch if + token (+n = n so ignore leading +)
000C0Fr 2               
000C0Fr 2  C9 B2        	CMP	#TK_NOT		; compare with token for NOT
000C11r 2  D0 13        	BNE	LAB_1BE7		; branch if not token for NOT
000C13r 2               
000C13r 2               					; was NOT token
000C13r 2               TK_EQUAL_PLUS	= TK_EQUAL-TK_PLUS
000C13r 2  A0 21        	LDY	#TK_EQUAL_PLUS*3	; offset to NOT function
000C15r 2  D0 1F        	BNE	LAB_1C13		; do set-up for function then execute (branch always)
000C17r 2               
000C17r 2               ; do = compare
000C17r 2               
000C17r 2               LAB_EQUAL
000C17r 2  20 rr rr     	JSR	LAB_EVIR		; evaluate integer expression (no sign check)
000C1Ar 2  A5 AF        	LDA	FAC1_3		; get FAC1 mantissa3
000C1Cr 2  49 FF        	EOR	#$FF			; invert it
000C1Er 2  A8           	TAY				; copy it
000C1Fr 2  A5 AE        	LDA	FAC1_2		; get FAC1 mantissa2
000C21r 2  49 FF        	EOR	#$FF			; invert it
000C23r 2  4C rr rr     	JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
000C26r 2               
000C26r 2               ; get value from line .. continued
000C26r 2               
000C26r 2               					; wasn't +, -, or NOT so ..
000C26r 2               LAB_1BE7
000C26r 2  C9 AF        	CMP	#TK_FN		; compare with token for FN
000C28r 2  D0 03        	BNE	LAB_1BEE		; branch if not token for FN
000C2Ar 2               
000C2Ar 2  4C rr rr     	JMP	LAB_201E		; go evaluate FNx
000C2Dr 2               
000C2Dr 2               ; get value from line .. continued
000C2Dr 2               
000C2Dr 2               					; wasn't +, -, NOT or FN so ..
000C2Dr 2               LAB_1BEE
000C2Dr 2  E9 C4        	SBC	#TK_SGN		; subtract with token for SGN
000C2Fr 2  B0 19        	BCS	LAB_1C27		; if a function token go do it
000C31r 2               
000C31r 2  4C rr rr     	JMP	LAB_SNER		; else do syntax error
000C34r 2               
000C34r 2               ; set-up for functions
000C34r 2               
000C34r 2               LAB_1C11
000C34r 2               TK_GT_PLUS	= TK_GT-TK_PLUS
000C34r 2  A0 1E        	LDY	#TK_GT_PLUS*3	; set offset from base to > operator
000C36r 2               LAB_1C13
000C36r 2  68           	PLA				; dump return address low byte
000C37r 2  68           	PLA				; dump return address high byte
000C38r 2  4C rr rr     	JMP	LAB_1B1D		; execute function then continue evaluation
000C3Br 2               
000C3Br 2               ; variable name set-up
000C3Br 2               ; get (var), return value in FAC_1 and $ flag
000C3Br 2               
000C3Br 2               LAB_1C18
000C3Br 2  20 rr rr     	JSR	LAB_GVAR		; get (var) address
000C3Er 2  85 AE        	STA	FAC1_2		; save address low byte in FAC1 mantissa2
000C40r 2  84 AF        	STY	FAC1_3		; save address high byte in FAC1 mantissa3
000C42r 2  A6 5F        	LDX	Dtypef		; get data type flag, $FF=string, $00=numeric
000C44r 2  30 03        	BMI	LAB_1C25		; if string then return (does RTS)
000C46r 2               
000C46r 2               LAB_1C24
000C46r 2  4C rr rr     	JMP	LAB_UFAC		; unpack memory (AY) into FAC1
000C49r 2               
000C49r 2               LAB_1C25
000C49r 2  60           	RTS
000C4Ar 2               
000C4Ar 2               ; get value from line .. continued
000C4Ar 2               ; only functions left so ..
000C4Ar 2               
000C4Ar 2               ; set up function references
000C4Ar 2               
000C4Ar 2               ; new for V2.0+ this replaces a lot of IF .. THEN .. ELSEIF .. THEN .. that was needed
000C4Ar 2               ; to process function calls. now the function vector is computed and pushed on the stack
000C4Ar 2               ; and the preprocess offset is read. if the preprocess offset is non zero then the vector
000C4Ar 2               ; is calculated and the routine called, if not this routine just does RTS. whichever
000C4Ar 2               ; happens the RTS at the end of this routine, or the end of the preprocess routine, calls
000C4Ar 2               ; the function code
000C4Ar 2               
000C4Ar 2               ; this also removes some less than elegant code that was used to bypass type checking
000C4Ar 2               ; for functions that returned strings
000C4Ar 2               
000C4Ar 2               LAB_1C27
000C4Ar 2  0A           	ASL				; *2 (2 bytes per function address)
000C4Br 2  A8           	TAY				; copy to index
000C4Cr 2               
000C4Cr 2  B9 rr rr     	LDA	LAB_FTBM,Y		; get function jump vector high byte
000C4Fr 2  48           	PHA				; push functions jump vector high byte
000C50r 2  B9 rr rr     	LDA	LAB_FTBL,Y		; get function jump vector low byte
000C53r 2  48           	PHA				; push functions jump vector low byte
000C54r 2               
000C54r 2  B9 rr rr     	LDA	LAB_FTPM,Y		; get function pre process vector high byte
000C57r 2  F0 05        	BEQ	LAB_1C56		; skip pre process if null vector
000C59r 2               
000C59r 2  48           	PHA				; push functions pre process vector high byte
000C5Ar 2  B9 rr rr     	LDA	LAB_FTPL,Y		; get function pre process vector low byte
000C5Dr 2  48           	PHA				; push functions pre process vector low byte
000C5Er 2               
000C5Er 2               LAB_1C56
000C5Er 2  60           	RTS				; do function, or pre process, call
000C5Fr 2               
000C5Fr 2               ; process string expression in parenthesis
000C5Fr 2               
000C5Fr 2               LAB_PPFS
000C5Fr 2  20 rr rr     	JSR	LAB_1BF7		; process expression in parenthesis
000C62r 2  4C rr rr     	JMP	LAB_CTST		; check if source is string then do function,
000C65r 2               					; else do type mismatch
000C65r 2               
000C65r 2               ; process numeric expression in parenthesis
000C65r 2               
000C65r 2               LAB_PPFN
000C65r 2  20 rr rr     	JSR	LAB_1BF7		; process expression in parenthesis
000C68r 2  4C rr rr     	JMP	LAB_CTNM		; check if source is numeric then do function,
000C6Br 2               					; else do type mismatch
000C6Br 2               
000C6Br 2               ; set numeric data type and increment BASIC execute pointer
000C6Br 2               
000C6Br 2               LAB_PPBI
000C6Br 2  46 5F        	LSR	Dtypef		; clear data type flag, $FF=string, $00=numeric
000C6Dr 2  4C BC 00     	JMP	LAB_IGBY		; increment and scan memory then do function
000C70r 2               
000C70r 2               ; process string for LEFT$, RIGHT$ or MID$
000C70r 2               
000C70r 2               LAB_LRMS
000C70r 2  20 rr rr     	JSR	LAB_EVEZ		; evaluate (should be string) expression
000C73r 2  20 rr rr     	JSR	LAB_1C01		; scan for ",", else do syntax error then warm start
000C76r 2  20 rr rr     	JSR	LAB_CTST		; check if source is string, else do type mismatch
000C79r 2               
000C79r 2  68           	PLA				; get function jump vector low byte
000C7Ar 2  AA           	TAX				; save functions jump vector low byte
000C7Br 2  68           	PLA				; get function jump vector high byte
000C7Cr 2  A8           	TAY				; save functions jump vector high byte
000C7Dr 2  A5 AF        	LDA	des_ph		; get descriptor pointer high byte
000C7Fr 2  48           	PHA				; push string pointer high byte
000C80r 2  A5 AE        	LDA	des_pl		; get descriptor pointer low byte
000C82r 2  48           	PHA				; push string pointer low byte
000C83r 2  98           	TYA				; get function jump vector high byte back
000C84r 2  48           	PHA				; save functions jump vector high byte
000C85r 2  8A           	TXA				; get function jump vector low byte back
000C86r 2  48           	PHA				; save functions jump vector low byte
000C87r 2  20 rr rr     	JSR	LAB_GTBY		; get byte parameter
000C8Ar 2  8A           	TXA				; copy byte parameter to A
000C8Br 2  60           	RTS				; go do function
000C8Cr 2               
000C8Cr 2               ; process numeric expression(s) for BIN$ or HEX$
000C8Cr 2               
000C8Cr 2               LAB_BHSS
000C8Cr 2  20 rr rr     	JSR	LAB_EVEZ		; process expression
000C8Fr 2  20 rr rr     	JSR	LAB_CTNM		; check if source is numeric, else do type mismatch
000C92r 2  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
000C94r 2  C9 98        	CMP	#$98			; compare with exponent = 2^24
000C96r 2  B0 20        	BCS	LAB_BHER		; branch if n>=2^24 (is too big)
000C98r 2               
000C98r 2  20 rr rr     	JSR	LAB_2831		; convert FAC1 floating-to-fixed
000C9Br 2  A2 02        	LDX	#$02			; 3 bytes to do
000C9Dr 2               LAB_CFAC
000C9Dr 2  B5 AD        	LDA	FAC1_1,X		; get byte from FAC1
000C9Fr 2  95 11        	STA	nums_1,X		; save byte to temp
000CA1r 2  CA           	DEX				; decrement index
000CA2r 2  10 F9        	BPL	LAB_CFAC		; copy FAC1 mantissa to temp
000CA4r 2               
000CA4r 2  20 C2 00     	JSR	LAB_GBYT		; get next BASIC byte
000CA7r 2  A2 00        	LDX	#$00			; set default to no leading "0"s
000CA9r 2  C9 29        	CMP	#')'			; compare with close bracket
000CABr 2  F0 0A        	BEQ	LAB_1C54		; if ")" go do rest of function
000CADr 2               
000CADr 2  20 rr rr     	JSR	LAB_SCGB		; scan for "," and get byte
000CB0r 2  20 C2 00     	JSR	LAB_GBYT		; get last byte back
000CB3r 2  C9 29        	CMP	#')'			; is next character )
000CB5r 2  D0 01        	BNE	LAB_BHER		; if not ")" go do error
000CB7r 2               
000CB7r 2               LAB_1C54
000CB7r 2  60           	RTS				; else do function
000CB8r 2               
000CB8r 2               LAB_BHER
000CB8r 2  4C rr rr     	JMP	LAB_FCER		; do function call error then warm start
000CBBr 2               
000CBBr 2               ; perform EOR
000CBBr 2               
000CBBr 2               ; added operator format is the same as AND or OR, precedence is the same as OR
000CBBr 2               
000CBBr 2               ; this bit worked first time but it took a while to sort out the operator table
000CBBr 2               ; pointers and offsets afterwards!
000CBBr 2               
000CBBr 2               LAB_EOR
000CBBr 2  20 rr rr     	JSR	GetFirst		; get first integer expression (no sign check)
000CBEr 2  45 5B        	EOR	XOAw_l		; EOR with expression 1 low byte
000CC0r 2  A8           	TAY				; save in Y
000CC1r 2  A5 AE        	LDA	FAC1_2		; get FAC1 mantissa2
000CC3r 2  45 5C        	EOR	XOAw_h		; EOR with expression 1 high byte
000CC5r 2  4C rr rr     	JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
000CC8r 2               
000CC8r 2               ; perform OR
000CC8r 2               
000CC8r 2               LAB_OR
000CC8r 2  20 rr rr     	JSR	GetFirst		; get first integer expression (no sign check)
000CCBr 2  05 5B        	ORA	XOAw_l		; OR with expression 1 low byte
000CCDr 2  A8           	TAY				; save in Y
000CCEr 2  A5 AE        	LDA	FAC1_2		; get FAC1 mantissa2
000CD0r 2  05 5C        	ORA	XOAw_h		; OR with expression 1 high byte
000CD2r 2  4C rr rr     	JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
000CD5r 2               
000CD5r 2               ; perform AND
000CD5r 2               
000CD5r 2               LAB_AND
000CD5r 2  20 rr rr     	JSR	GetFirst		; get first integer expression (no sign check)
000CD8r 2  25 5B        	AND	XOAw_l		; AND with expression 1 low byte
000CDAr 2  A8           	TAY				; save in Y
000CDBr 2  A5 AE        	LDA	FAC1_2		; get FAC1 mantissa2
000CDDr 2  25 5C        	AND	XOAw_h		; AND with expression 1 high byte
000CDFr 2  4C rr rr     	JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
000CE2r 2               
000CE2r 2               ; get first value for OR, AND or EOR
000CE2r 2               
000CE2r 2               GetFirst
000CE2r 2  20 rr rr     	JSR	LAB_EVIR		; evaluate integer expression (no sign check)
000CE5r 2  A5 AE        	LDA	FAC1_2		; get FAC1 mantissa2
000CE7r 2  85 5C        	STA	XOAw_h		; save it
000CE9r 2  A5 AF        	LDA	FAC1_3		; get FAC1 mantissa3
000CEBr 2  85 5B        	STA	XOAw_l		; save it
000CEDr 2  20 rr rr     	JSR	LAB_279B		; copy FAC2 to FAC1 (get 2nd value in expression)
000CF0r 2  20 rr rr     	JSR	LAB_EVIR		; evaluate integer expression (no sign check)
000CF3r 2  A5 AF        	LDA	FAC1_3		; get FAC1 mantissa3
000CF5r 2               LAB_1C95
000CF5r 2  60           	RTS
000CF6r 2               
000CF6r 2               ; perform comparisons
000CF6r 2               
000CF6r 2               ; do < compare
000CF6r 2               
000CF6r 2               LAB_LTHAN
000CF6r 2  20 rr rr     	JSR	LAB_CKTM		; type match check, set C for string
000CF9r 2  B0 13        	BCS	LAB_1CAE		; branch if string
000CFBr 2               
000CFBr 2               					; do numeric < compare
000CFBr 2  A5 B7        	LDA	FAC2_s		; get FAC2 sign (b7)
000CFDr 2  09 7F        	ORA	#$7F			; set all non sign bits
000CFFr 2  25 B4        	AND	FAC2_1		; and FAC2 mantissa1 (AND in sign bit)
000D01r 2  85 B4        	STA	FAC2_1		; save FAC2 mantissa1
000D03r 2  A9 B3        	LDA	#<FAC2_e		; set pointer low byte to FAC2
000D05r 2  A0 00        	LDY	#>FAC2_e		; set pointer high byte to FAC2
000D07r 2  20 rr rr     	JSR	LAB_27F8		; compare FAC1 with FAC2 (AY)
000D0Ar 2  AA           	TAX				; copy result
000D0Br 2  4C rr rr     	JMP	LAB_1CE1		; go evaluate result
000D0Er 2               
000D0Er 2               					; do string < compare
000D0Er 2               LAB_1CAE
000D0Er 2  46 5F        	LSR	Dtypef		; clear data type flag, $FF=string, $00=numeric
000D10r 2  C6 9B        	DEC	comp_f		; clear < bit in compare function flag
000D12r 2  20 rr rr     	JSR	LAB_22B6		; pop string off descriptor stack, or from top of string
000D15r 2               					; space returns with A = length, X=pointer low byte,
000D15r 2               					; Y=pointer high byte
000D15r 2  85 AC        	STA	str_ln		; save length
000D17r 2  86 AD        	STX	str_pl		; save string pointer low byte
000D19r 2  84 AE        	STY	str_ph		; save string pointer high byte
000D1Br 2  A5 B5        	LDA	FAC2_2		; get descriptor pointer low byte
000D1Dr 2  A4 B6        	LDY	FAC2_3		; get descriptor pointer high byte
000D1Fr 2  20 rr rr     	JSR	LAB_22BA		; pop (YA) descriptor off stack or from top of string space
000D22r 2               					; returns with A = length, X=pointer low byte,
000D22r 2               					; Y=pointer high byte
000D22r 2  86 B5        	STX	FAC2_2		; save string pointer low byte
000D24r 2  84 B6        	STY	FAC2_3		; save string pointer high byte
000D26r 2  AA           	TAX				; copy length
000D27r 2  38           	SEC				; set carry for subtract
000D28r 2  E5 AC        	SBC	str_ln		; subtract string 1 length
000D2Ar 2  F0 08        	BEQ	LAB_1CD6		; branch if str 1 length = string 2 length
000D2Cr 2               
000D2Cr 2  A9 01        	LDA	#$01			; set str 1 length > string 2 length
000D2Er 2  90 04        	BCC	LAB_1CD6		; branch if so
000D30r 2               
000D30r 2  A6 AC        	LDX	str_ln		; get string 1 length
000D32r 2  A9 FF        	LDA	#$FF			; set str 1 length < string 2 length
000D34r 2               LAB_1CD6
000D34r 2  85 B0        	STA	FAC1_s		; save length compare
000D36r 2  A0 FF        	LDY	#$FF			; set index
000D38r 2  E8           	INX				; adjust for loop
000D39r 2               LAB_1CDB
000D39r 2  C8           	INY				; increment index
000D3Ar 2  CA           	DEX				; decrement count
000D3Br 2  D0 07        	BNE	LAB_1CE6		; branch if still bytes to do
000D3Dr 2               
000D3Dr 2  A6 B0        	LDX	FAC1_s		; get length compare back
000D3Fr 2               LAB_1CE1
000D3Fr 2  30 0F        	BMI	LAB_1CF2		; branch if str 1 < str 2
000D41r 2               
000D41r 2  18           	CLC				; flag str 1 <= str 2
000D42r 2  90 0C        	BCC	LAB_1CF2		; go evaluate result
000D44r 2               
000D44r 2               LAB_1CE6
000D44r 2  B1 B5        	LDA	(FAC2_2),Y		; get string 2 byte
000D46r 2  D1 AD        	CMP	(FAC1_1),Y		; compare with string 1 byte
000D48r 2  F0 EF        	BEQ	LAB_1CDB		; loop if bytes =
000D4Ar 2               
000D4Ar 2  A2 FF        	LDX	#$FF			; set str 1 < string 2
000D4Cr 2  B0 02        	BCS	LAB_1CF2		; branch if so
000D4Er 2               
000D4Er 2  A2 01        	LDX	#$01			;  set str 1 > string 2
000D50r 2               LAB_1CF2
000D50r 2  E8           	INX				; x = 0, 1 or 2
000D51r 2  8A           	TXA				; copy to A
000D52r 2  2A           	ROL				; *2 (1, 2 or 4)
000D53r 2  25 63        	AND	Cflag			; AND with comparison evaluation flag
000D55r 2  F0 02        	BEQ	LAB_1CFB		; branch if 0 (compare is false)
000D57r 2               
000D57r 2  A9 FF        	LDA	#$FF			; else set result true
000D59r 2               LAB_1CFB
000D59r 2  4C rr rr     	JMP	LAB_27DB		; save A as integer byte and return
000D5Cr 2               
000D5Cr 2               LAB_1CFE
000D5Cr 2  20 rr rr     	JSR	LAB_1C01		; scan for ",", else do syntax error then warm start
000D5Fr 2               
000D5Fr 2               ; perform DIM
000D5Fr 2               
000D5Fr 2               LAB_DIM
000D5Fr 2  AA           	TAX				; copy "DIM" flag to X
000D60r 2  20 rr rr     	JSR	LAB_1D10		; search for variable
000D63r 2  20 C2 00     	JSR	LAB_GBYT		; scan memory
000D66r 2  D0 F4        	BNE	LAB_1CFE		; scan for "," and loop if not null
000D68r 2               
000D68r 2  60           	RTS
000D69r 2               
000D69r 2               ; perform << (left shift)
000D69r 2               
000D69r 2               LAB_LSHIFT
000D69r 2  20 rr rr     	JSR	GetPair		; get integer expression and byte (no sign check)
000D6Cr 2  A5 AE        	LDA	FAC1_2		; get expression high byte
000D6Er 2  A6 78        	LDX	TempB			; get shift count
000D70r 2  F0 22        	BEQ	NoShift		; branch if zero
000D72r 2               
000D72r 2  E0 10        	CPX	#$10			; compare bit count with 16d
000D74r 2  B0 23        	BCS	TooBig		; branch if >=
000D76r 2               
000D76r 2               Ls_loop
000D76r 2  06 AF        	ASL	FAC1_3		; shift low byte
000D78r 2  2A           	ROL				; shift high byte
000D79r 2  CA           	DEX				; decrement bit count
000D7Ar 2  D0 FA        	BNE	Ls_loop		; loop if shift not complete
000D7Cr 2               
000D7Cr 2  A4 AF        	LDY	FAC1_3		; get expression low byte
000D7Er 2  4C rr rr     	JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
000D81r 2               
000D81r 2               ; perform >> (right shift)
000D81r 2               
000D81r 2               LAB_RSHIFT
000D81r 2  20 rr rr     	JSR	GetPair		; get integer expression and byte (no sign check)
000D84r 2  A5 AE        	LDA	FAC1_2		; get expression high byte
000D86r 2  A6 78        	LDX	TempB			; get shift count
000D88r 2  F0 0A        	BEQ	NoShift		; branch if zero
000D8Ar 2               
000D8Ar 2  E0 10        	CPX	#$10			; compare bit count with 16d
000D8Cr 2  B0 0B        	BCS	TooBig		; branch if >=
000D8Er 2               
000D8Er 2               Rs_loop
000D8Er 2  4A           	LSR				; shift high byte
000D8Fr 2  66 AF        	ROR	FAC1_3		; shift low byte
000D91r 2  CA           	DEX				; decrement bit count
000D92r 2  D0 FA        	BNE	Rs_loop		; loop if shift not complete
000D94r 2               
000D94r 2               NoShift
000D94r 2  A4 AF        	LDY	FAC1_3		; get expression low byte
000D96r 2  4C rr rr     	JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
000D99r 2               
000D99r 2               TooBig
000D99r 2  A9 00        	LDA	#$00			; clear high byte
000D9Br 2  A8           	TAY				; copy to low byte
000D9Cr 2  4C rr rr     	JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
000D9Fr 2               
000D9Fr 2               GetPair
000D9Fr 2  20 rr rr     	JSR	LAB_EVBY		; evaluate byte expression, result in X
000DA2r 2  86 78        	STX	TempB			; save it
000DA4r 2  20 rr rr     	JSR	LAB_279B		; copy FAC2 to FAC1 (get 2nd value in expression)
000DA7r 2  4C rr rr     	JMP	LAB_EVIR		; evaluate integer expression (no sign check)
000DAAr 2               
000DAAr 2               ; search for variable
000DAAr 2               
000DAAr 2               ; return pointer to variable in Cvaral/Cvarah
000DAAr 2               
000DAAr 2               LAB_GVAR
000DAAr 2  A2 00        	LDX	#$00			; set DIM flag = $00
000DACr 2  20 C2 00     	JSR	LAB_GBYT		; scan memory (1st character)
000DAFr 2               LAB_1D10
000DAFr 2  86 5E        	STX	Defdim		; save DIM flag
000DB1r 2               LAB_1D12
000DB1r 2  85 93        	STA	Varnm1		; save 1st character
000DB3r 2  29 7F        	AND	#$7F			; clear FN flag bit
000DB5r 2  20 rr rr     	JSR	LAB_CASC		; check byte, return C=0 if<"A" or >"Z"
000DB8r 2  B0 03        	BCS	LAB_1D1F		; branch if ok
000DBAr 2               
000DBAr 2  4C rr rr     	JMP	LAB_SNER		; else syntax error then warm start
000DBDr 2               
000DBDr 2               					; was variable name so ..
000DBDr 2               LAB_1D1F
000DBDr 2  A2 00        	LDX	#$00			; clear 2nd character temp
000DBFr 2  86 5F        	STX	Dtypef		; clear data type flag, $FF=string, $00=numeric
000DC1r 2  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory (2nd character)
000DC4r 2  90 05        	BCC	LAB_1D2D		; branch if character = "0"-"9" (ok)
000DC6r 2               
000DC6r 2               					; 2nd character wasn't "0" to "9" so ..
000DC6r 2  20 rr rr     	JSR	LAB_CASC		; check byte, return C=0 if<"A" or >"Z"
000DC9r 2  90 0B        	BCC	LAB_1D38		; branch if <"A" or >"Z" (go check if string)
000DCBr 2               
000DCBr 2               LAB_1D2D
000DCBr 2  AA           	TAX				; copy 2nd character
000DCCr 2               
000DCCr 2               					; ignore further (valid) characters in the variable name
000DCCr 2               LAB_1D2E
000DCCr 2  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory (3rd character)
000DCFr 2  90 FB        	BCC	LAB_1D2E		; loop if character = "0"-"9" (ignore)
000DD1r 2               
000DD1r 2  20 rr rr     	JSR	LAB_CASC		; check byte, return C=0 if<"A" or >"Z"
000DD4r 2  B0 F6        	BCS	LAB_1D2E		; loop if character = "A"-"Z" (ignore)
000DD6r 2               
000DD6r 2               					; check if string variable
000DD6r 2               LAB_1D38
000DD6r 2  C9 24        	CMP	#'$'			; compare with "$"
000DD8r 2  D0 0B        	BNE	LAB_1D47		; branch if not string
000DDAr 2               
000DDAr 2               ; to introduce a new variable type (% suffix for integers say) then this branch
000DDAr 2               ; will need to go to that check and then that branch, if it fails, go to LAB_1D47
000DDAr 2               
000DDAr 2               					; type is string
000DDAr 2  A9 FF        	LDA	#$FF			; set data type = string
000DDCr 2  85 5F        	STA	Dtypef		; set data type flag, $FF=string, $00=numeric
000DDEr 2  8A           	TXA				; get 2nd character back
000DDFr 2  09 80        	ORA	#$80			; set top bit (indicate string var)
000DE1r 2  AA           	TAX				; copy back to 2nd character temp
000DE2r 2  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
000DE5r 2               
000DE5r 2               ; after we have determined the variable type we need to come back here to determine
000DE5r 2               ; if it's an array of type. this would plug in a%(b[,c[,d]])) integer arrays nicely
000DE5r 2               
000DE5r 2               
000DE5r 2               LAB_1D47				; gets here with character after var name in A
000DE5r 2  86 94        	STX	Varnm2		; save 2nd character
000DE7r 2  05 61        	ORA	Sufnxf		; or with subscript/FNX flag (or FN name)
000DE9r 2  C9 28        	CMP	#'('			; compare with "("
000DEBr 2  D0 03        	BNE	LAB_1D53		; branch if not "("
000DEDr 2               
000DEDr 2  4C rr rr     	JMP	LAB_1E17		; go find, or make, array
000DF0r 2               
000DF0r 2               ; either find or create var
000DF0r 2               ; var name (1st two characters only!) is in Varnm1,Varnm2
000DF0r 2               
000DF0r 2               					; variable name wasn't var(... so look for plain var
000DF0r 2               LAB_1D53
000DF0r 2  A9 00        	LDA	#$00			; clear A
000DF2r 2  85 61        	STA	Sufnxf		; clear subscript/FNX flag
000DF4r 2  A5 7B        	LDA	Svarl			; get start of vars low byte
000DF6r 2  A6 7C        	LDX	Svarh			; get start of vars high byte
000DF8r 2  A0 00        	LDY	#$00			; clear index
000DFAr 2               LAB_1D5D
000DFAr 2  86 AB        	STX	Vrschh		; save search address high byte
000DFCr 2               LAB_1D5F
000DFCr 2  85 AA        	STA	Vrschl		; save search address low byte
000DFEr 2  E4 7E        	CPX	Sarryh		; compare high address with var space end
000E00r 2  D0 04        	BNE	LAB_1D69		; skip next compare if <>
000E02r 2               
000E02r 2               					; high addresses were = so compare low addresses
000E02r 2  C5 7D        	CMP	Sarryl		; compare low address with var space end
000E04r 2  F0 2C        	BEQ	LAB_1D8B		; if not found go make new var
000E06r 2               
000E06r 2               LAB_1D69
000E06r 2  A5 93        	LDA	Varnm1		; get 1st character of var to find
000E08r 2  D1 AA        	CMP	(Vrschl),Y		; compare with variable name 1st character
000E0Ar 2  D0 08        	BNE	LAB_1D77		; branch if no match
000E0Cr 2               
000E0Cr 2               					; 1st characters match so compare 2nd characters
000E0Cr 2  A5 94        	LDA	Varnm2		; get 2nd character of var to find
000E0Er 2  C8           	INY				; index to point to variable name 2nd character
000E0Fr 2  D1 AA        	CMP	(Vrschl),Y		; compare with variable name 2nd character
000E11r 2  F0 69        	BEQ	LAB_1DD7		; branch if match (found var)
000E13r 2               
000E13r 2  88           	DEY				; else decrement index (now = $00)
000E14r 2               LAB_1D77
000E14r 2  18           	CLC				; clear carry for add
000E15r 2  A5 AA        	LDA	Vrschl		; get search address low byte
000E17r 2  69 06        	ADC	#$06			; +6 (offset to next var name)
000E19r 2  90 E1        	BCC	LAB_1D5F		; loop if no overflow to high byte
000E1Br 2               
000E1Br 2  E8           	INX				; else increment high byte
000E1Cr 2  D0 DC        	BNE	LAB_1D5D		; loop always (RAM doesn't extend to $FFFF !)
000E1Er 2               
000E1Er 2               ; check byte, return C=0 if<"A" or >"Z" or "a" to "z"
000E1Er 2               
000E1Er 2               LAB_CASC
000E1Er 2  C9 61        	CMP	#'a'			; compare with "a"
000E20r 2  B0 0A        	BCS	LAB_1D83		; go check <"z"+1
000E22r 2               
000E22r 2               ; check byte, return C=0 if<"A" or >"Z"
000E22r 2               
000E22r 2               LAB_1D82
000E22r 2  C9 41        	CMP	#'A'			; compare with "A"
000E24r 2  90 05        	BCC	LAB_1D8A		; exit if less
000E26r 2               
000E26r 2               					; carry is set
000E26r 2  E9 5B        	SBC	#$5B			; subtract "Z"+1
000E28r 2  38           	SEC				; set carry
000E29r 2  E9 A5        	SBC	#$A5			; subtract $A5 (restore byte)
000E2Br 2               					; carry clear if byte>$5A
000E2Br 2               LAB_1D8A
000E2Br 2  60           	RTS
000E2Cr 2               
000E2Cr 2               LAB_1D83
000E2Cr 2  E9 7B        	SBC	#$7B			; subtract "z"+1
000E2Er 2  38           	SEC				; set carry
000E2Fr 2  E9 85        	SBC	#$85			; subtract $85 (restore byte)
000E31r 2               					; carry clear if byte>$7A
000E31r 2  60           	RTS
000E32r 2               
000E32r 2               					; reached end of variable mem without match
000E32r 2               					; .. so create new variable
000E32r 2               LAB_1D8B
000E32r 2  68           	PLA				; pop return address low byte
000E33r 2  48           	PHA				; push return address low byte
000E34r 2               LAB_1C18p2	= LAB_1C18+2
000E34r 2  C9 rr        	CMP	#<LAB_1C18p2	; compare with expected calling routine return low byte
000E36r 2  D0 05        	BNE	LAB_1D98		; if not get (var) go create new var
000E38r 2               
000E38r 2               ; This will only drop through if the call was from LAB_1C18 and is only called
000E38r 2               ; from there if it is searching for a variable from the RHS of a LET a=b statement
000E38r 2               ; it prevents the creation of variables not assigned a value.
000E38r 2               
000E38r 2               ; value returned by this is either numeric zero (exponent byte is $00) or null string
000E38r 2               ; (descriptor length byte is $00). in fact a pointer to any $00 byte would have done.
000E38r 2               
000E38r 2               ; doing this saves 6 bytes of variable memory and 168 machine cycles of time
000E38r 2               
000E38r 2               ; this is where you would put the undefined variable error call e.g.
000E38r 2               
000E38r 2               ;					; variable doesn't exist so flag error
000E38r 2               ;	LDX	#$24			; error code $24 ("undefined variable" error)
000E38r 2               ;	JMP	LAB_XERR		; do error #X then warm start
000E38r 2               
000E38r 2               ; the above code has been tested and works a treat! (it replaces the three code lines
000E38r 2               ; below)
000E38r 2               
000E38r 2               					; else return dummy null value
000E38r 2  A9 rr        	LDA	#<LAB_1D96		; low byte point to $00,$00
000E3Ar 2               					; (uses part of misc constants table)
000E3Ar 2  A0 rr        	LDY	#>LAB_1D96		; high byte point to $00,$00
000E3Cr 2  60           	RTS
000E3Dr 2               
000E3Dr 2               					; create new numeric variable
000E3Dr 2               LAB_1D98
000E3Dr 2  A5 7D        	LDA	Sarryl		; get var mem end low byte
000E3Fr 2  A4 7E        	LDY	Sarryh		; get var mem end high byte
000E41r 2  85 AA        	STA	Ostrtl		; save old block start low byte
000E43r 2  84 AB        	STY	Ostrth		; save old block start high byte
000E45r 2  A5 7F        	LDA	Earryl		; get array mem end low byte
000E47r 2  A4 80        	LDY	Earryh		; get array mem end high byte
000E49r 2  85 A6        	STA	Obendl		; save old block end low byte
000E4Br 2  84 A7        	STY	Obendh		; save old block end high byte
000E4Dr 2  18           	CLC				; clear carry for add
000E4Er 2  69 06        	ADC	#$06			; +6 (space for one var)
000E50r 2  90 01        	BCC	LAB_1DAE		; branch if no overflow to high byte
000E52r 2               
000E52r 2  C8           	INY				; else increment high byte
000E53r 2               LAB_1DAE
000E53r 2  85 A4        	STA	Nbendl		; set new block end low byte
000E55r 2  84 A5        	STY	Nbendh		; set new block end high byte
000E57r 2  20 rr rr     	JSR	LAB_11CF		; open up space in memory
000E5Ar 2  A5 A4        	LDA	Nbendl		; get new start low byte
000E5Cr 2  A4 A5        	LDY	Nbendh		; get new start high byte (-$100)
000E5Er 2  C8           	INY				; correct high byte
000E5Fr 2  85 7D        	STA	Sarryl		; save new var mem end low byte
000E61r 2  84 7E        	STY	Sarryh		; save new var mem end high byte
000E63r 2  A0 00        	LDY	#$00			; clear index
000E65r 2  A5 93        	LDA	Varnm1		; get var name 1st character
000E67r 2  91 AA        	STA	(Vrschl),Y		; save var name 1st character
000E69r 2  C8           	INY				; increment index
000E6Ar 2  A5 94        	LDA	Varnm2		; get var name 2nd character
000E6Cr 2  91 AA        	STA	(Vrschl),Y		; save var name 2nd character
000E6Er 2  A9 00        	LDA	#$00			; clear A
000E70r 2  C8           	INY				; increment index
000E71r 2  91 AA        	STA	(Vrschl),Y		; initialise var byte
000E73r 2  C8           	INY				; increment index
000E74r 2  91 AA        	STA	(Vrschl),Y		; initialise var byte
000E76r 2  C8           	INY				; increment index
000E77r 2  91 AA        	STA	(Vrschl),Y		; initialise var byte
000E79r 2  C8           	INY				; increment index
000E7Ar 2  91 AA        	STA	(Vrschl),Y		; initialise var byte
000E7Cr 2               
000E7Cr 2               					; found a match for var ((Vrschl) = ptr)
000E7Cr 2               LAB_1DD7
000E7Cr 2  A5 AA        	LDA	Vrschl		; get var address low byte
000E7Er 2  18           	CLC				; clear carry for add
000E7Fr 2  69 02        	ADC	#$02			; +2 (offset past var name bytes)
000E81r 2  A4 AB        	LDY	Vrschh		; get var address high byte
000E83r 2  90 01        	BCC	LAB_1DE1		; branch if no overflow from add
000E85r 2               
000E85r 2  C8           	INY				; else increment high byte
000E86r 2               LAB_1DE1
000E86r 2  85 95        	STA	Cvaral		; save current var address low byte
000E88r 2  84 96        	STY	Cvarah		; save current var address high byte
000E8Ar 2  60           	RTS
000E8Br 2               
000E8Br 2               ; set-up array pointer (Adatal/h) to first element in array
000E8Br 2               ; set Adatal,Adatah to Astrtl,Astrth+2*Dimcnt+#$05
000E8Br 2               
000E8Br 2               LAB_1DE6
000E8Br 2  A5 5D        	LDA	Dimcnt		; get # of dimensions (1, 2 or 3)
000E8Dr 2  0A           	ASL				; *2 (also clears the carry !)
000E8Er 2  69 05        	ADC	#$05			; +5 (result is 7, 9 or 11 here)
000E90r 2  65 AA        	ADC	Astrtl		; add array start pointer low byte
000E92r 2  A4 AB        	LDY	Astrth		; get array pointer high byte
000E94r 2  90 01        	BCC	LAB_1DF2		; branch if no overflow
000E96r 2               
000E96r 2  C8           	INY				; else increment high byte
000E97r 2               LAB_1DF2
000E97r 2  85 A4        	STA	Adatal		; save array data pointer low byte
000E99r 2  84 A5        	STY	Adatah		; save array data pointer high byte
000E9Br 2  60           	RTS
000E9Cr 2               
000E9Cr 2               ; evaluate integer expression
000E9Cr 2               
000E9Cr 2               LAB_EVIN
000E9Cr 2  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
000E9Fr 2  20 rr rr     	JSR	LAB_EVNM		; evaluate expression and check is numeric,
000EA2r 2               					; else do type mismatch
000EA2r 2               
000EA2r 2               ; evaluate integer expression (no check)
000EA2r 2               
000EA2r 2               LAB_EVPI
000EA2r 2  A5 B0        	LDA	FAC1_s		; get FAC1 sign (b7)
000EA4r 2  30 0D        	BMI	LAB_1E12		; do function call error if -ve
000EA6r 2               
000EA6r 2               ; evaluate integer expression (no sign check)
000EA6r 2               
000EA6r 2               LAB_EVIR
000EA6r 2  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
000EA8r 2  C9 90        	CMP	#$90			; compare with exponent = 2^16 (n>2^15)
000EAAr 2  90 09        	BCC	LAB_1E14		; branch if n<2^16 (is ok)
000EACr 2               
000EACr 2  A9 rr        	LDA	#<LAB_1DF7		; set pointer low byte to -32768
000EAEr 2  A0 rr        	LDY	#>LAB_1DF7		; set pointer high byte to -32768
000EB0r 2  20 rr rr     	JSR	LAB_27F8		; compare FAC1 with (AY)
000EB3r 2               LAB_1E12
000EB3r 2  D0 74        	BNE	LAB_FCER		; if <> do function call error then warm start
000EB5r 2               
000EB5r 2               LAB_1E14
000EB5r 2  4C rr rr     	JMP	LAB_2831		; convert FAC1 floating-to-fixed and return
000EB8r 2               
000EB8r 2               ; find or make array
000EB8r 2               
000EB8r 2               LAB_1E17
000EB8r 2  A5 5E        	LDA	Defdim		; get DIM flag
000EBAr 2  48           	PHA				; push it
000EBBr 2  A5 5F        	LDA	Dtypef		; get data type flag, $FF=string, $00=numeric
000EBDr 2  48           	PHA				; push it
000EBEr 2  A0 00        	LDY	#$00			; clear dimensions count
000EC0r 2               
000EC0r 2               ; now get the array dimension(s) and stack it (them) before the data type and DIM flag
000EC0r 2               
000EC0r 2               LAB_1E1F
000EC0r 2  98           	TYA				; copy dimensions count
000EC1r 2  48           	PHA				; save it
000EC2r 2  A5 94        	LDA	Varnm2		; get array name 2nd byte
000EC4r 2  48           	PHA				; save it
000EC5r 2  A5 93        	LDA	Varnm1		; get array name 1st byte
000EC7r 2  48           	PHA				; save it
000EC8r 2  20 rr rr     	JSR	LAB_EVIN		; evaluate integer expression
000ECBr 2  68           	PLA				; pull array name 1st byte
000ECCr 2  85 93        	STA	Varnm1		; restore array name 1st byte
000ECEr 2  68           	PLA				; pull array name 2nd byte
000ECFr 2  85 94        	STA	Varnm2		; restore array name 2nd byte
000ED1r 2  68           	PLA				; pull dimensions count
000ED2r 2  A8           	TAY				; restore it
000ED3r 2  BA           	TSX				; copy stack pointer
000ED4r 2  BD 02 01     	LDA	LAB_STAK+2,X	; get DIM flag
000ED7r 2  48           	PHA				; push it
000ED8r 2  BD 01 01     	LDA	LAB_STAK+1,X	; get data type flag
000EDBr 2  48           	PHA				; push it
000EDCr 2  A5 AE        	LDA	FAC1_2		; get this dimension size high byte
000EDEr 2  9D 02 01     	STA	LAB_STAK+2,X	; stack before flag bytes
000EE1r 2  A5 AF        	LDA	FAC1_3		; get this dimension size low byte
000EE3r 2  9D 01 01     	STA	LAB_STAK+1,X	; stack before flag bytes
000EE6r 2  C8           	INY				; increment dimensions count
000EE7r 2  20 C2 00     	JSR	LAB_GBYT		; scan memory
000EEAr 2  C9 2C        	CMP	#','			; compare with ","
000EECr 2  F0 D2        	BEQ	LAB_1E1F		; if found go do next dimension
000EEEr 2               
000EEEr 2  84 5D        	STY	Dimcnt		; store dimensions count
000EF0r 2  20 rr rr     	JSR	LAB_1BFB		; scan for ")" , else do syntax error then warm start
000EF3r 2  68           	PLA				; pull data type flag
000EF4r 2  85 5F        	STA	Dtypef		; restore data type flag, $FF=string, $00=numeric
000EF6r 2  68           	PLA				; pull DIM flag
000EF7r 2  85 5E        	STA	Defdim		; restore DIM flag
000EF9r 2  A6 7D        	LDX	Sarryl		; get array mem start low byte
000EFBr 2  A5 7E        	LDA	Sarryh		; get array mem start high byte
000EFDr 2               
000EFDr 2               ; now check to see if we are at the end of array memory (we would be if there were
000EFDr 2               ; no arrays).
000EFDr 2               
000EFDr 2               LAB_1E5C
000EFDr 2  86 AA        	STX	Astrtl		; save as array start pointer low byte
000EFFr 2  85 AB        	STA	Astrth		; save as array start pointer high byte
000F01r 2  C5 80        	CMP	Earryh		; compare with array mem end high byte
000F03r 2  D0 04        	BNE	LAB_1E68		; branch if not reached array mem end
000F05r 2               
000F05r 2  E4 7F        	CPX	Earryl		; else compare with array mem end low byte
000F07r 2  F0 39        	BEQ	LAB_1EA1		; go build array if not found
000F09r 2               
000F09r 2               					; search for array
000F09r 2               LAB_1E68
000F09r 2  A0 00        	LDY	#$00			; clear index
000F0Br 2  B1 AA        	LDA	(Astrtl),Y		; get array name first byte
000F0Dr 2  C8           	INY				; increment index to second name byte
000F0Er 2  C5 93        	CMP	Varnm1		; compare with this array name first byte
000F10r 2  D0 06        	BNE	LAB_1E77		; branch if no match
000F12r 2               
000F12r 2  A5 94        	LDA	Varnm2		; else get this array name second byte
000F14r 2  D1 AA        	CMP	(Astrtl),Y		; compare with array name second byte
000F16r 2  F0 16        	BEQ	LAB_1E8D		; array found so branch
000F18r 2               
000F18r 2               					; no match
000F18r 2               LAB_1E77
000F18r 2  C8           	INY				; increment index
000F19r 2  B1 AA        	LDA	(Astrtl),Y		; get array size low byte
000F1Br 2  18           	CLC				; clear carry for add
000F1Cr 2  65 AA        	ADC	Astrtl		; add array start pointer low byte
000F1Er 2  AA           	TAX				; copy low byte to X
000F1Fr 2  C8           	INY				; increment index
000F20r 2  B1 AA        	LDA	(Astrtl),Y		; get array size high byte
000F22r 2  65 AB        	ADC	Astrth		; add array mem pointer high byte
000F24r 2  90 D7        	BCC	LAB_1E5C		; if no overflow go check next array
000F26r 2               
000F26r 2               ; do array bounds error
000F26r 2               
000F26r 2               LAB_1E85
000F26r 2  A2 10        	LDX	#$10			; error code $10 ("Array bounds" error)
000F28r 2  2C           	.byte	$2C			; makes next bit BIT LAB_08A2
000F29r 2               
000F29r 2               ; do function call error
000F29r 2               
000F29r 2               LAB_FCER
000F29r 2  A2 08        	LDX	#$08			; error code $08 ("Function call" error)
000F2Br 2               LAB_1E8A
000F2Br 2  4C rr rr     	JMP	LAB_XERR		; do error #X, then warm start
000F2Er 2               
000F2Er 2               					; found array, are we trying to dimension it?
000F2Er 2               LAB_1E8D
000F2Er 2  A2 12        	LDX	#$12			; set error $12 ("Double dimension" error)
000F30r 2  A5 5E        	LDA	Defdim		; get DIM flag
000F32r 2  D0 F7        	BNE	LAB_1E8A		; if we are trying to dimension it do error #X, then warm
000F34r 2               					; start
000F34r 2               
000F34r 2               ; found the array and we"re not dimensioning it so we must find an element in it
000F34r 2               
000F34r 2  20 rr rr     	JSR	LAB_1DE6		; set-up array pointer (Adatal/h) to first element in array
000F37r 2               					; (Astrtl,Astrth points to start of array)
000F37r 2  A5 5D        	LDA	Dimcnt		; get dimensions count
000F39r 2  A0 04        	LDY	#$04			; set index to array's # of dimensions
000F3Br 2  D1 AA        	CMP	(Astrtl),Y		; compare with no of dimensions
000F3Dr 2  D0 E7        	BNE	LAB_1E85		; if wrong do array bounds error, could do "Wrong
000F3Fr 2               					; dimensions" error here .. if we want a different
000F3Fr 2               					; error message
000F3Fr 2               
000F3Fr 2  4C rr rr     	JMP	LAB_1F28		; found array so go get element
000F42r 2               					; (could jump to LAB_1F28 as all LAB_1F24 does is take
000F42r 2               					; Dimcnt and save it at (Astrtl),Y which is already the
000F42r 2               					; same or we would have taken the BNE)
000F42r 2               
000F42r 2               					; array not found, so build it
000F42r 2               LAB_1EA1
000F42r 2  20 rr rr     	JSR	LAB_1DE6		; set-up array pointer (Adatal/h) to first element in array
000F45r 2               					; (Astrtl,Astrth points to start of array)
000F45r 2  20 rr rr     	JSR	LAB_121F		; check available memory, "Out of memory" error if no room
000F48r 2               					; addr to check is in AY (low/high)
000F48r 2  A0 00        	LDY	#$00			; clear Y (don't need to clear A)
000F4Ar 2  84 BB        	STY	Aspth			; clear array data size high byte
000F4Cr 2  A5 93        	LDA	Varnm1		; get variable name 1st byte
000F4Er 2  91 AA        	STA	(Astrtl),Y		; save array name 1st byte
000F50r 2  C8           	INY				; increment index
000F51r 2  A5 94        	LDA	Varnm2		; get variable name 2nd byte
000F53r 2  91 AA        	STA	(Astrtl),Y		; save array name 2nd byte
000F55r 2  A5 5D        	LDA	Dimcnt		; get dimensions count
000F57r 2  A0 04        	LDY	#$04			; index to dimension count
000F59r 2  84 BA        	STY	Asptl			; set array data size low byte (four bytes per element)
000F5Br 2  91 AA        	STA	(Astrtl),Y		; set array's dimensions count
000F5Dr 2               
000F5Dr 2               					; now calculate the size of the data space for the array
000F5Dr 2  18           	CLC				; clear carry for add (clear on subsequent loops)
000F5Er 2               LAB_1EC0
000F5Er 2  A2 0B        	LDX	#$0B			; set default dimension value low byte
000F60r 2  A9 00        	LDA	#$00			; set default dimension value high byte
000F62r 2  24 5E        	BIT	Defdim		; test default DIM flag
000F64r 2  50 07        	BVC	LAB_1ED0		; branch if b6 of Defdim is clear
000F66r 2               
000F66r 2  68           	PLA				; else pull dimension value low byte
000F67r 2  69 01        	ADC	#$01			; +1 (allow for zeroeth element)
000F69r 2  AA           	TAX				; copy low byte to X
000F6Ar 2  68           	PLA				; pull dimension value high byte
000F6Br 2  69 00        	ADC	#$00			; add carry from low byte
000F6Dr 2               
000F6Dr 2               LAB_1ED0
000F6Dr 2  C8           	INY				; index to dimension value high byte
000F6Er 2  91 AA        	STA	(Astrtl),Y		; save dimension value high byte
000F70r 2  C8           	INY				; index to dimension value high byte
000F71r 2  8A           	TXA				; get dimension value low byte
000F72r 2  91 AA        	STA	(Astrtl),Y		; save dimension value low byte
000F74r 2  20 rr rr     	JSR	LAB_1F7C		; does XY = (Astrtl),Y * (Asptl)
000F77r 2  86 BA        	STX	Asptl			; save array data size low byte
000F79r 2  85 BB        	STA	Aspth			; save array data size high byte
000F7Br 2  A4 71        	LDY	ut1_pl		; restore index (saved by subroutine)
000F7Dr 2  C6 5D        	DEC	Dimcnt		; decrement dimensions count
000F7Fr 2  D0 DD        	BNE	LAB_1EC0		; loop while not = 0
000F81r 2               
000F81r 2  65 A5        	ADC	Adatah		; add size high byte to first element high byte
000F83r 2               					; (carry is always clear here)
000F83r 2  B0 5D        	BCS	LAB_1F45		; if overflow go do "Out of memory" error
000F85r 2               
000F85r 2  85 A5        	STA	Adatah		; save end of array high byte
000F87r 2  A8           	TAY				; copy end high byte to Y
000F88r 2  8A           	TXA				; get array size low byte
000F89r 2  65 A4        	ADC	Adatal		; add array start low byte
000F8Br 2  90 03        	BCC	LAB_1EF3		; branch if no carry
000F8Dr 2               
000F8Dr 2  C8           	INY				; else increment end of array high byte
000F8Er 2  F0 52        	BEQ	LAB_1F45		; if overflow go do "Out of memory" error
000F90r 2               
000F90r 2               					; set-up mostly complete, now zero the array
000F90r 2               LAB_1EF3
000F90r 2  20 rr rr     	JSR	LAB_121F		; check available memory, "Out of memory" error if no room
000F93r 2               					; addr to check is in AY (low/high)
000F93r 2  85 7F        	STA	Earryl		; save array mem end low byte
000F95r 2  84 80        	STY	Earryh		; save array mem end high byte
000F97r 2  A9 00        	LDA	#$00			; clear byte for array clear
000F99r 2  E6 BB        	INC	Aspth			; increment array size high byte (now block count)
000F9Br 2  A4 BA        	LDY	Asptl			; get array size low byte (now index to block)
000F9Dr 2  F0 05        	BEQ	LAB_1F07		; branch if low byte = $00
000F9Fr 2               
000F9Fr 2               LAB_1F02
000F9Fr 2  88           	DEY				; decrement index (do 0 to n-1)
000FA0r 2  91 A4        	STA	(Adatal),Y		; zero byte
000FA2r 2  D0 FB        	BNE	LAB_1F02		; loop until this block done
000FA4r 2               
000FA4r 2               LAB_1F07
000FA4r 2  C6 A5        	DEC	Adatah		; decrement array pointer high byte
000FA6r 2  C6 BB        	DEC	Aspth			; decrement block count high byte
000FA8r 2  D0 F5        	BNE	LAB_1F02		; loop until all blocks done
000FAAr 2               
000FAAr 2  E6 A5        	INC	Adatah		; correct for last loop
000FACr 2  38           	SEC				; set carry for subtract
000FADr 2  A0 02        	LDY	#$02			; index to array size low byte
000FAFr 2  A5 7F        	LDA	Earryl		; get array mem end low byte
000FB1r 2  E5 AA        	SBC	Astrtl		; subtract array start low byte
000FB3r 2  91 AA        	STA	(Astrtl),Y		; save array size low byte
000FB5r 2  C8           	INY				; index to array size high byte
000FB6r 2  A5 80        	LDA	Earryh		; get array mem end high byte
000FB8r 2  E5 AB        	SBC	Astrth		; subtract array start high byte
000FBAr 2  91 AA        	STA	(Astrtl),Y		; save array size high byte
000FBCr 2  A5 5E        	LDA	Defdim		; get default DIM flag
000FBEr 2  D0 53        	BNE	LAB_1F7B		; exit (RET) if this was a DIM command
000FC0r 2               
000FC0r 2               					; else, find element
000FC0r 2  C8           	INY				; index to # of dimensions
000FC1r 2               
000FC1r 2               LAB_1F24
000FC1r 2  B1 AA        	LDA	(Astrtl),Y		; get array's dimension count
000FC3r 2  85 5D        	STA	Dimcnt		; save it
000FC5r 2               
000FC5r 2               ; we have found, or built, the array. now we need to find the element
000FC5r 2               
000FC5r 2               LAB_1F28
000FC5r 2  A9 00        	LDA	#$00			; clear byte
000FC7r 2  85 BA        	STA	Asptl			; clear array data pointer low byte
000FC9r 2               LAB_1F2C
000FC9r 2  85 BB        	STA	Aspth			; save array data pointer high byte
000FCBr 2  C8           	INY				; increment index (point to array bound high byte)
000FCCr 2  68           	PLA				; pull array index low byte
000FCDr 2  AA           	TAX				; copy to X
000FCEr 2  85 AE        	STA	FAC1_2		; save index low byte to FAC1 mantissa2
000FD0r 2  68           	PLA				; pull array index high byte
000FD1r 2  85 AF        	STA	FAC1_3		; save index high byte to FAC1 mantissa3
000FD3r 2  D1 AA        	CMP	(Astrtl),Y		; compare with array bound high byte
000FD5r 2  90 0E        	BCC	LAB_1F48		; branch if within bounds
000FD7r 2               
000FD7r 2  D0 06        	BNE	LAB_1F42		; if outside bounds do array bounds error
000FD9r 2               
000FD9r 2               					; else high byte was = so test low bytes
000FD9r 2  C8           	INY				; index to array bound low byte
000FDAr 2  8A           	TXA				; get array index low byte
000FDBr 2  D1 AA        	CMP	(Astrtl),Y		; compare with array bound low byte
000FDDr 2  90 07        	BCC	LAB_1F49		; branch if within bounds
000FDFr 2               
000FDFr 2               LAB_1F42
000FDFr 2  4C rr rr     	JMP	LAB_1E85		; else do array bounds error
000FE2r 2               
000FE2r 2               LAB_1F45
000FE2r 2  4C rr rr     	JMP	LAB_OMER		; do "Out of memory" error then warm start
000FE5r 2               
000FE5r 2               LAB_1F48
000FE5r 2  C8           	INY				; index to array bound low byte
000FE6r 2               LAB_1F49
000FE6r 2  A5 BB        	LDA	Aspth			; get array data pointer high byte
000FE8r 2  05 BA        	ORA	Asptl			; OR with array data pointer low byte
000FEAr 2  F0 0A        	BEQ	LAB_1F5A		; branch if array data pointer = null (skip multiply)
000FECr 2               
000FECr 2  20 rr rr     	JSR	LAB_1F7C		; does XY = (Astrtl),Y * (Asptl)
000FEFr 2  8A           	TXA				; get result low byte
000FF0r 2  65 AE        	ADC	FAC1_2		; add index low byte from FAC1 mantissa2
000FF2r 2  AA           	TAX				; save result low byte
000FF3r 2  98           	TYA				; get result high byte
000FF4r 2  A4 71        	LDY	ut1_pl		; restore index
000FF6r 2               LAB_1F5A
000FF6r 2  65 AF        	ADC	FAC1_3		; add index high byte from FAC1 mantissa3
000FF8r 2  86 BA        	STX	Asptl			; save array data pointer low byte
000FFAr 2  C6 5D        	DEC	Dimcnt		; decrement dimensions count
000FFCr 2  D0 CB        	BNE	LAB_1F2C		; loop if dimensions still to do
000FFEr 2               
000FFEr 2  06 BA        	ASL	Asptl			; array data pointer low byte * 2
001000r 2  2A           	ROL				; array data pointer high byte * 2
001001r 2  06 BA        	ASL	Asptl			; array data pointer low byte * 4
001003r 2  2A           	ROL				; array data pointer high byte * 4
001004r 2  A8           	TAY				; copy high byte
001005r 2  A5 BA        	LDA	Asptl			; get low byte
001007r 2  65 A4        	ADC	Adatal		; add array data start pointer low byte
001009r 2  85 95        	STA	Cvaral		; save as current var address low byte
00100Br 2  98           	TYA				; get high byte back
00100Cr 2  65 A5        	ADC	Adatah		; add array data start pointer high byte
00100Er 2  85 96        	STA	Cvarah		; save as current var address high byte
001010r 2  A8           	TAY				; copy high byte to Y
001011r 2  A5 95        	LDA	Cvaral		; get current var address low byte
001013r 2               LAB_1F7B
001013r 2  60           	RTS
001014r 2               
001014r 2               ; does XY = (Astrtl),Y * (Asptl)
001014r 2               
001014r 2               LAB_1F7C
001014r 2  84 71        	STY	ut1_pl		; save index
001016r 2  B1 AA        	LDA	(Astrtl),Y		; get dimension size low byte
001018r 2  85 76        	STA	dims_l		; save dimension size low byte
00101Ar 2  88           	DEY				; decrement index
00101Br 2  B1 AA        	LDA	(Astrtl),Y		; get dimension size high byte
00101Dr 2  85 77        	STA	dims_h		; save dimension size high byte
00101Fr 2               
00101Fr 2  A9 10        	LDA	#$10			; count = $10 (16 bit multiply)
001021r 2  85 A8        	STA	numbit		; save bit count
001023r 2  A2 00        	LDX	#$00			; clear result low byte
001025r 2  A0 00        	LDY	#$00			; clear result high byte
001027r 2               LAB_1F8F
001027r 2  8A           	TXA				; get result low byte
001028r 2  0A           	ASL				; *2
001029r 2  AA           	TAX				; save result low byte
00102Ar 2  98           	TYA				; get result high byte
00102Br 2  2A           	ROL				; *2
00102Cr 2  A8           	TAY				; save result high byte
00102Dr 2  B0 B3        	BCS	LAB_1F45		; if overflow go do "Out of memory" error
00102Fr 2               
00102Fr 2  06 BA        	ASL	Asptl			; shift multiplier low byte
001031r 2  26 BB        	ROL	Aspth			; shift multiplier high byte
001033r 2  90 0B        	BCC	LAB_1FA8		; skip add if no carry
001035r 2               
001035r 2  18           	CLC				; else clear carry for add
001036r 2  8A           	TXA				; get result low byte
001037r 2  65 76        	ADC	dims_l		; add dimension size low byte
001039r 2  AA           	TAX				; save result low byte
00103Ar 2  98           	TYA				; get result high byte
00103Br 2  65 77        	ADC	dims_h		; add dimension size high byte
00103Dr 2  A8           	TAY				; save result high byte
00103Er 2  B0 A2        	BCS	LAB_1F45		; if overflow go do "Out of memory" error
001040r 2               
001040r 2               LAB_1FA8
001040r 2  C6 A8        	DEC	numbit		; decrement bit count
001042r 2  D0 E3        	BNE	LAB_1F8F		; loop until all done
001044r 2               
001044r 2  60           	RTS
001045r 2               
001045r 2               ; perform FRE()
001045r 2               
001045r 2               LAB_FRE
001045r 2  A5 5F        	LDA	Dtypef		; get data type flag, $FF=string, $00=numeric
001047r 2  10 03        	BPL	LAB_1FB4		; branch if numeric
001049r 2               
001049r 2  20 rr rr     	JSR	LAB_22B6		; pop string off descriptor stack, or from top of string
00104Cr 2               					; space returns with A = length, X=$71=pointer low byte,
00104Cr 2               					; Y=$72=pointer high byte
00104Cr 2               
00104Cr 2               					; FRE(n) was numeric so do this
00104Cr 2               LAB_1FB4
00104Cr 2  20 rr rr     	JSR	LAB_GARB		; go do garbage collection
00104Fr 2  38           	SEC				; set carry for subtract
001050r 2  A5 81        	LDA	Sstorl		; get bottom of string space low byte
001052r 2  E5 7F        	SBC	Earryl		; subtract array mem end low byte
001054r 2  A8           	TAY				; copy result to Y
001055r 2  A5 82        	LDA	Sstorh		; get bottom of string space high byte
001057r 2  E5 80        	SBC	Earryh		; subtract array mem end high byte
001059r 2               
001059r 2               ; save and convert integer AY to FAC1
001059r 2               
001059r 2               LAB_AYFC
001059r 2  46 5F        	LSR	Dtypef		; clear data type flag, $FF=string, $00=numeric
00105Br 2  85 AD        	STA	FAC1_1		; save FAC1 mantissa1
00105Dr 2  84 AE        	STY	FAC1_2		; save FAC1 mantissa2
00105Fr 2  A2 90        	LDX	#$90			; set exponent=2^16 (integer)
001061r 2  4C rr rr     	JMP	LAB_27E3		; set exp=X, clear FAC1_3, normalise and return
001064r 2               
001064r 2               ; perform POS()
001064r 2               
001064r 2               LAB_POS
001064r 2  A4 0E        	LDY	TPos			; get terminal position
001066r 2               
001066r 2               ; convert Y to byte in FAC1
001066r 2               
001066r 2               LAB_1FD0
001066r 2  A9 00        	LDA	#$00			; clear high byte
001068r 2  F0 EF        	BEQ	LAB_AYFC		; always save and convert integer AY to FAC1 and return
00106Ar 2               
00106Ar 2               ; check not Direct (used by DEF and INPUT)
00106Ar 2               
00106Ar 2               LAB_CKRN
00106Ar 2  A6 88        	LDX	Clineh		; get current line high byte
00106Cr 2  E8           	INX				; increment it
00106Dr 2  D0 A4        	BNE	LAB_1F7B		; return if can continue not direct mode
00106Fr 2               
00106Fr 2               					; else do illegal direct error
00106Fr 2               LAB_1FD9
00106Fr 2  A2 16        	LDX	#$16			; error code $16 ("Illegal direct" error)
001071r 2               LAB_1FDB
001071r 2  4C rr rr     	JMP	LAB_XERR		; go do error #X, then warm start
001074r 2               
001074r 2               ; perform DEF
001074r 2               
001074r 2               LAB_DEF
001074r 2  20 rr rr     	JSR	LAB_200B		; check FNx syntax
001077r 2  85 9C        	STA	func_l		; save function pointer low byte
001079r 2  84 9D        	STY	func_h		; save function pointer high byte
00107Br 2  20 rr rr     	JSR	LAB_CKRN		; check not Direct (back here if ok)
00107Er 2  20 rr rr     	JSR	LAB_1BFE		; scan for "(" , else do syntax error then warm start
001081r 2  A9 80        	LDA	#$80			; set flag for FNx
001083r 2  85 61        	STA	Sufnxf		; save subscript/FNx flag
001085r 2  20 rr rr     	JSR	LAB_GVAR		; get (var) address
001088r 2  20 rr rr     	JSR	LAB_CTNM		; check if source is numeric, else do type mismatch
00108Br 2  20 rr rr     	JSR	LAB_1BFB		; scan for ")" , else do syntax error then warm start
00108Er 2  A9 C2        	LDA	#TK_EQUAL		; get = token
001090r 2  20 rr rr     	JSR	LAB_SCCA		; scan for CHR$(A), else do syntax error then warm start
001093r 2  A5 96        	LDA	Cvarah		; get current var address high byte
001095r 2  48           	PHA				; push it
001096r 2  A5 95        	LDA	Cvaral		; get current var address low byte
001098r 2  48           	PHA				; push it
001099r 2  A5 C4        	LDA	Bpntrh		; get BASIC execute pointer high byte
00109Br 2  48           	PHA				; push it
00109Cr 2  A5 C3        	LDA	Bpntrl		; get BASIC execute pointer low byte
00109Er 2  48           	PHA				; push it
00109Fr 2  20 rr rr     	JSR	LAB_DATA		; go perform DATA
0010A2r 2  4C rr rr     	JMP	LAB_207A		; put execute pointer and variable pointer into function
0010A5r 2               					; and return
0010A5r 2               
0010A5r 2               ; check FNx syntax
0010A5r 2               
0010A5r 2               LAB_200B
0010A5r 2  A9 AF        	LDA	#TK_FN		; get FN" token
0010A7r 2  20 rr rr     	JSR	LAB_SCCA		; scan for CHR$(A) , else do syntax error then warm start
0010AAr 2               					; return character after A
0010AAr 2  09 80        	ORA	#$80			; set FN flag bit
0010ACr 2  85 61        	STA	Sufnxf		; save FN flag so array variable test fails
0010AEr 2  20 rr rr     	JSR	LAB_1D12		; search for FN variable
0010B1r 2  4C rr rr     	JMP	LAB_CTNM		; check if source is numeric and return, else do type
0010B4r 2               					; mismatch
0010B4r 2               
0010B4r 2               					; Evaluate FNx
0010B4r 2               LAB_201E
0010B4r 2  20 rr rr     	JSR	LAB_200B		; check FNx syntax
0010B7r 2  48           	PHA				; push function pointer low byte
0010B8r 2  98           	TYA				; copy function pointer high byte
0010B9r 2  48           	PHA				; push function pointer high byte
0010BAr 2  20 rr rr     	JSR	LAB_1BFE		; scan for "(", else do syntax error then warm start
0010BDr 2  20 rr rr     	JSR	LAB_EVEX		; evaluate expression
0010C0r 2  20 rr rr     	JSR	LAB_1BFB		; scan for ")", else do syntax error then warm start
0010C3r 2  20 rr rr     	JSR	LAB_CTNM		; check if source is numeric, else do type mismatch
0010C6r 2  68           	PLA				; pop function pointer high byte
0010C7r 2  85 9D        	STA	func_h		; restore it
0010C9r 2  68           	PLA				; pop function pointer low byte
0010CAr 2  85 9C        	STA	func_l		; restore it
0010CCr 2  A2 20        	LDX	#$20			; error code $20 ("Undefined function" error)
0010CEr 2  A0 03        	LDY	#$03			; index to variable pointer high byte
0010D0r 2  B1 9C        	LDA	(func_l),Y		; get variable pointer high byte
0010D2r 2  F0 9D        	BEQ	LAB_1FDB		; if zero go do undefined function error
0010D4r 2               
0010D4r 2  85 96        	STA	Cvarah		; save variable address high byte
0010D6r 2  88           	DEY				; index to variable address low byte
0010D7r 2  B1 9C        	LDA	(func_l),Y		; get variable address low byte
0010D9r 2  85 95        	STA	Cvaral		; save variable address low byte
0010DBr 2  AA           	TAX				; copy address low byte
0010DCr 2               
0010DCr 2               					; now stack the function variable value before use
0010DCr 2  C8           	INY				; index to mantissa_3
0010DDr 2               LAB_2043
0010DDr 2  B1 95        	LDA	(Cvaral),Y		; get byte from variable
0010DFr 2  48           	PHA				; stack it
0010E0r 2  88           	DEY				; decrement index
0010E1r 2  10 FA        	BPL	LAB_2043		; loop until variable stacked
0010E3r 2               
0010E3r 2  A4 96        	LDY	Cvarah		; get variable address high byte
0010E5r 2  20 rr rr     	JSR	LAB_2778		; pack FAC1 (function expression value) into (XY)
0010E8r 2               					; (function variable), return Y=0, always
0010E8r 2  A5 C4        	LDA	Bpntrh		; get BASIC execute pointer high byte
0010EAr 2  48           	PHA				; push it
0010EBr 2  A5 C3        	LDA	Bpntrl		; get BASIC execute pointer low byte
0010EDr 2  48           	PHA				; push it
0010EEr 2  B1 9C        	LDA	(func_l),Y		; get function execute pointer low byte
0010F0r 2  85 C3        	STA	Bpntrl		; save as BASIC execute pointer low byte
0010F2r 2  C8           	INY				; index to high byte
0010F3r 2  B1 9C        	LDA	(func_l),Y		; get function execute pointer high byte
0010F5r 2  85 C4        	STA	Bpntrh		; save as BASIC execute pointer high byte
0010F7r 2  A5 96        	LDA	Cvarah		; get variable address high byte
0010F9r 2  48           	PHA				; push it
0010FAr 2  A5 95        	LDA	Cvaral		; get variable address low byte
0010FCr 2  48           	PHA				; push it
0010FDr 2  20 rr rr     	JSR	LAB_EVNM		; evaluate expression and check is numeric,
001100r 2               					; else do type mismatch
001100r 2  68           	PLA				; pull variable address low byte
001101r 2  85 9C        	STA	func_l		; save variable address low byte
001103r 2  68           	PLA				; pull variable address high byte
001104r 2  85 9D        	STA	func_h		; save variable address high byte
001106r 2  20 C2 00     	JSR	LAB_GBYT		; scan memory
001109r 2  F0 03        	BEQ	LAB_2074		; branch if null (should be [EOL] marker)
00110Br 2               
00110Br 2  4C rr rr     	JMP	LAB_SNER		; else syntax error then warm start
00110Er 2               
00110Er 2               ; restore Bpntrl,Bpntrh and function variable from stack
00110Er 2               
00110Er 2               LAB_2074
00110Er 2  68           	PLA				; pull BASIC execute pointer low byte
00110Fr 2  85 C3        	STA	Bpntrl		; restore BASIC execute pointer low byte
001111r 2  68           	PLA				; pull BASIC execute pointer high byte
001112r 2  85 C4        	STA	Bpntrh		; restore BASIC execute pointer high byte
001114r 2               
001114r 2               ; put execute pointer and variable pointer into function
001114r 2               
001114r 2               LAB_207A
001114r 2  A0 00        	LDY	#$00			; clear index
001116r 2  68           	PLA				; pull BASIC execute pointer low byte
001117r 2  91 9C        	STA	(func_l),Y		; save to function
001119r 2  C8           	INY				; increment index
00111Ar 2  68           	PLA				; pull BASIC execute pointer high byte
00111Br 2  91 9C        	STA	(func_l),Y		; save to function
00111Dr 2  C8           	INY				; increment index
00111Er 2  68           	PLA				; pull current var address low byte
00111Fr 2  91 9C        	STA	(func_l),Y		; save to function
001121r 2  C8           	INY				; increment index
001122r 2  68           	PLA				; pull current var address high byte
001123r 2  91 9C        	STA	(func_l),Y		; save to function
001125r 2  60           	RTS
001126r 2               
001126r 2               ; perform STR$()
001126r 2               
001126r 2               LAB_STRS
001126r 2  20 rr rr     	JSR	LAB_CTNM		; check if source is numeric, else do type mismatch
001129r 2  20 rr rr     	JSR	LAB_296E		; convert FAC1 to string
00112Cr 2  A9 F0        	LDA	#<Decssp1		; set result string low pointer
00112Er 2  A0 00        	LDY	#>Decssp1		; set result string high pointer
001130r 2  F0 12        	BEQ	LAB_20AE		; print null terminated string to Sutill/Sutilh
001132r 2               
001132r 2               ; Do string vector
001132r 2               ; copy des_pl/h to des_2l/h and make string space A bytes long
001132r 2               
001132r 2               LAB_209C
001132r 2  A6 AE        	LDX	des_pl		; get descriptor pointer low byte
001134r 2  A4 AF        	LDY	des_ph		; get descriptor pointer high byte
001136r 2  86 9E        	STX	des_2l		; save descriptor pointer low byte
001138r 2  84 9F        	STY	des_2h		; save descriptor pointer high byte
00113Ar 2               
00113Ar 2               ; make string space A bytes long
00113Ar 2               ; A=length, X=Sutill=ptr low byte, Y=Sutilh=ptr high byte
00113Ar 2               
00113Ar 2               LAB_MSSP
00113Ar 2  20 rr rr     	JSR	LAB_2115		; make space in string memory for string A long
00113Dr 2               					; return X=Sutill=ptr low byte, Y=Sutilh=ptr high byte
00113Dr 2  86 AD        	STX	str_pl		; save string pointer low byte
00113Fr 2  84 AE        	STY	str_ph		; save string pointer high byte
001141r 2  85 AC        	STA	str_ln		; save length
001143r 2  60           	RTS
001144r 2               
001144r 2               ; Scan, set up string
001144r 2               ; print " terminated string to Sutill/Sutilh
001144r 2               
001144r 2               LAB_20AE
001144r 2  A2 22        	LDX	#$22			; set terminator to "
001146r 2  86 5B        	STX	Srchc			; set search character (terminator 1)
001148r 2  86 5C        	STX	Asrch			; set terminator 2
00114Ar 2               
00114Ar 2               ; print [Srchc] or [Asrch] terminated string to Sutill/Sutilh
00114Ar 2               ; source is AY
00114Ar 2               
00114Ar 2               LAB_20B4
00114Ar 2  85 B8        	STA	ssptr_l		; store string start low byte
00114Cr 2  84 B9        	STY	ssptr_h		; store string start high byte
00114Er 2  85 AD        	STA	str_pl		; save string pointer low byte
001150r 2  84 AE        	STY	str_ph		; save string pointer high byte
001152r 2  A0 FF        	LDY	#$FF			; set length to -1
001154r 2               LAB_20BE
001154r 2  C8           	INY				; increment length
001155r 2  B1 B8        	LDA	(ssptr_l),Y		; get byte from string
001157r 2  F0 0C        	BEQ	LAB_20CF		; exit loop if null byte [EOS]
001159r 2               
001159r 2  C5 5B        	CMP	Srchc			; compare with search character (terminator 1)
00115Br 2  F0 04        	BEQ	LAB_20CB		; branch if terminator
00115Dr 2               
00115Dr 2  C5 5C        	CMP	Asrch			; compare with terminator 2
00115Fr 2  D0 F3        	BNE	LAB_20BE		; loop if not terminator 2
001161r 2               
001161r 2               LAB_20CB
001161r 2  C9 22        	CMP	#$22			; compare with "
001163r 2  F0 01        	BEQ	LAB_20D0		; branch if " (carry set if = !)
001165r 2               
001165r 2               LAB_20CF
001165r 2  18           	CLC				; clear carry for add (only if [EOL] terminated string)
001166r 2               LAB_20D0
001166r 2  84 AC        	STY	str_ln		; save length in FAC1 exponent
001168r 2  98           	TYA				; copy length to A
001169r 2  65 B8        	ADC	ssptr_l		; add string start low byte
00116Br 2  85 BA        	STA	Sendl			; save string end low byte
00116Dr 2  A6 B9        	LDX	ssptr_h		; get string start high byte
00116Fr 2  90 01        	BCC	LAB_20DC		; branch if no low byte overflow
001171r 2               
001171r 2  E8           	INX				; else increment high byte
001172r 2               LAB_20DC
001172r 2  86 BB        	STX	Sendh			; save string end high byte
001174r 2  A5 B9        	LDA	ssptr_h		; get string start high byte
001176r 2  C9 04        	CMP	#>Ram_base		; compare with start of program memory
001178r 2  B0 0B        	BCS	LAB_RTST		; branch if not in utility area
00117Ar 2               
00117Ar 2               					; string in utility area, move to string memory
00117Ar 2  98           	TYA				; copy length to A
00117Br 2  20 rr rr     	JSR	LAB_209C		; copy des_pl/h to des_2l/h and make string space A bytes
00117Er 2               					; long
00117Er 2  A6 B8        	LDX	ssptr_l		; get string start low byte
001180r 2  A4 B9        	LDY	ssptr_h		; get string start high byte
001182r 2  20 rr rr     	JSR	LAB_2298		; store string A bytes long from XY to (Sutill)
001185r 2               
001185r 2               ; check for space on descriptor stack then ..
001185r 2               ; put string address and length on descriptor stack and update stack pointers
001185r 2               
001185r 2               LAB_RTST
001185r 2  A6 65        	LDX	next_s		; get string stack pointer
001187r 2  E0 71        	CPX	#des_sk+$09		; compare with max+1
001189r 2  D0 05        	BNE	LAB_20F8		; branch if space on string stack
00118Br 2               
00118Br 2               					; else do string too complex error
00118Br 2  A2 1C        	LDX	#$1C			; error code $1C ("String too complex" error)
00118Dr 2               LAB_20F5
00118Dr 2  4C rr rr     	JMP	LAB_XERR		; do error #X, then warm start
001190r 2               
001190r 2               ; put string address and length on descriptor stack and update stack pointers
001190r 2               
001190r 2               LAB_20F8
001190r 2  A5 AC        	LDA	str_ln		; get string length
001192r 2  95 00        	STA	PLUS_0,X		; put on string stack
001194r 2  A5 AD        	LDA	str_pl		; get string pointer low byte
001196r 2  95 01        	STA	PLUS_1,X		; put on string stack
001198r 2  A5 AE        	LDA	str_ph		; get string pointer high byte
00119Ar 2  95 02        	STA	PLUS_2,X		; put on string stack
00119Cr 2  A0 00        	LDY	#$00			; clear Y
00119Er 2  86 AE        	STX	des_pl		; save string descriptor pointer low byte
0011A0r 2  84 AF        	STY	des_ph		; save string descriptor pointer high byte (always $00)
0011A2r 2  88           	DEY				; Y = $FF
0011A3r 2  84 5F        	STY	Dtypef		; save data type flag, $FF=string
0011A5r 2  86 66        	STX	last_sl		; save old stack pointer (current top item)
0011A7r 2  E8           	INX				; update stack pointer
0011A8r 2  E8           	INX				; update stack pointer
0011A9r 2  E8           	INX				; update stack pointer
0011AAr 2  86 65        	STX	next_s		; save new top item value
0011ACr 2  60           	RTS
0011ADr 2               
0011ADr 2               ; Build descriptor
0011ADr 2               ; make space in string memory for string A long
0011ADr 2               ; return X=Sutill=ptr low byte, Y=Sutill=ptr high byte
0011ADr 2               
0011ADr 2               LAB_2115
0011ADr 2  46 60        	LSR	Gclctd		; clear garbage collected flag (b7)
0011AFr 2               
0011AFr 2               					; make space for string A long
0011AFr 2               LAB_2117
0011AFr 2  48           	PHA				; save string length
0011B0r 2  49 FF        	EOR	#$FF			; complement it
0011B2r 2  38           	SEC				; set carry for subtract (twos comp add)
0011B3r 2  65 81        	ADC	Sstorl		; add bottom of string space low byte (subtract length)
0011B5r 2  A4 82        	LDY	Sstorh		; get bottom of string space high byte
0011B7r 2  B0 01        	BCS	LAB_2122		; skip decrement if no underflow
0011B9r 2               
0011B9r 2  88           	DEY				; decrement bottom of string space high byte
0011BAr 2               LAB_2122
0011BAr 2  C4 80        	CPY	Earryh		; compare with array mem end high byte
0011BCr 2  90 11        	BCC	LAB_2137		; do out of memory error if less
0011BEr 2               
0011BEr 2  D0 04        	BNE	LAB_212C		; if not = skip next test
0011C0r 2               
0011C0r 2  C5 7F        	CMP	Earryl		; compare with array mem end low byte
0011C2r 2  90 0B        	BCC	LAB_2137		; do out of memory error if less
0011C4r 2               
0011C4r 2               LAB_212C
0011C4r 2  85 81        	STA	Sstorl		; save bottom of string space low byte
0011C6r 2  84 82        	STY	Sstorh		; save bottom of string space high byte
0011C8r 2  85 83        	STA	Sutill		; save string utility ptr low byte
0011CAr 2  84 84        	STY	Sutilh		; save string utility ptr high byte
0011CCr 2  AA           	TAX				; copy low byte to X
0011CDr 2  68           	PLA				; get string length back
0011CEr 2  60           	RTS
0011CFr 2               
0011CFr 2               LAB_2137
0011CFr 2  A2 0C        	LDX	#$0C			; error code $0C ("Out of memory" error)
0011D1r 2  A5 60        	LDA	Gclctd		; get garbage collected flag
0011D3r 2  30 B8        	BMI	LAB_20F5		; if set then do error code X
0011D5r 2               
0011D5r 2  20 rr rr     	JSR	LAB_GARB		; else go do garbage collection
0011D8r 2  A9 80        	LDA	#$80			; flag for garbage collected
0011DAr 2  85 60        	STA	Gclctd		; set garbage collected flag
0011DCr 2  68           	PLA				; pull length
0011DDr 2  D0 D0        	BNE	LAB_2117		; go try again (loop always, length should never be = $00)
0011DFr 2               
0011DFr 2               ; garbage collection routine
0011DFr 2               
0011DFr 2               LAB_GARB
0011DFr 2  A6 85        	LDX	Ememl			; get end of mem low byte
0011E1r 2  A5 86        	LDA	Ememh			; get end of mem high byte
0011E3r 2               
0011E3r 2               ; re-run routine from last ending
0011E3r 2               
0011E3r 2               LAB_214B
0011E3r 2  86 81        	STX	Sstorl		; set string storage low byte
0011E5r 2  85 82        	STA	Sstorh		; set string storage high byte
0011E7r 2  A0 00        	LDY	#$00			; clear index
0011E9r 2  84 9D        	STY	garb_h		; clear working pointer high byte (flag no strings to move)
0011EBr 2  A5 7F        	LDA	Earryl		; get array mem end low byte
0011EDr 2  A6 80        	LDX	Earryh		; get array mem end high byte
0011EFr 2  85 AA        	STA	Histrl		; save as highest string low byte
0011F1r 2  86 AB        	STX	Histrh		; save as highest string high byte
0011F3r 2  A9 68        	LDA	#des_sk		; set descriptor stack pointer
0011F5r 2  85 71        	STA	ut1_pl		; save descriptor stack pointer low byte
0011F7r 2  84 72        	STY	ut1_ph		; save descriptor stack pointer high byte ($00)
0011F9r 2               LAB_2161
0011F9r 2  C5 65        	CMP	next_s		; compare with descriptor stack pointer
0011FBr 2  F0 05        	BEQ	LAB_216A		; branch if =
0011FDr 2               
0011FDr 2  20 rr rr     	JSR	LAB_21D7		; go garbage collect descriptor stack
001200r 2  F0 F7        	BEQ	LAB_2161		; loop always
001202r 2               
001202r 2               					; done stacked strings, now do string vars
001202r 2               LAB_216A
001202r 2  06 A0        	ASL	g_step		; set step size = $06
001204r 2  A5 7B        	LDA	Svarl			; get start of vars low byte
001206r 2  A6 7C        	LDX	Svarh			; get start of vars high byte
001208r 2  85 71        	STA	ut1_pl		; save as pointer low byte
00120Ar 2  86 72        	STX	ut1_ph		; save as pointer high byte
00120Cr 2               LAB_2176
00120Cr 2  E4 7E        	CPX	Sarryh		; compare start of arrays high byte
00120Er 2  D0 04        	BNE	LAB_217E		; branch if no high byte match
001210r 2               
001210r 2  C5 7D        	CMP	Sarryl		; else compare start of arrays low byte
001212r 2  F0 05        	BEQ	LAB_2183		; branch if = var mem end
001214r 2               
001214r 2               LAB_217E
001214r 2  20 rr rr     	JSR	LAB_21D1		; go garbage collect strings
001217r 2  F0 F3        	BEQ	LAB_2176		; loop always
001219r 2               
001219r 2               					; done string vars, now do string arrays
001219r 2               LAB_2183
001219r 2  85 A4        	STA	Nbendl		; save start of arrays low byte as working pointer
00121Br 2  86 A5        	STX	Nbendh		; save start of arrays high byte as working pointer
00121Dr 2  A9 04        	LDA	#$04			; set step size
00121Fr 2  85 A0        	STA	g_step		; save step size
001221r 2               LAB_218B
001221r 2  A5 A4        	LDA	Nbendl		; get pointer low byte
001223r 2  A6 A5        	LDX	Nbendh		; get pointer high byte
001225r 2               LAB_218F
001225r 2  E4 80        	CPX	Earryh		; compare with array mem end high byte
001227r 2  D0 04        	BNE	LAB_219A		; branch if not at end
001229r 2               
001229r 2  C5 7F        	CMP	Earryl		; else compare with array mem end low byte
00122Br 2  F0 75        	BEQ	LAB_2216		; tidy up and exit if at end
00122Dr 2               
00122Dr 2               LAB_219A
00122Dr 2  85 71        	STA	ut1_pl		; save pointer low byte
00122Fr 2  86 72        	STX	ut1_ph		; save pointer high byte
001231r 2  A0 02        	LDY	#$02			; set index
001233r 2  B1 71        	LDA	(ut1_pl),Y		; get array size low byte
001235r 2  65 A4        	ADC	Nbendl		; add start of this array low byte
001237r 2  85 A4        	STA	Nbendl		; save start of next array low byte
001239r 2  C8           	INY				; increment index
00123Ar 2  B1 71        	LDA	(ut1_pl),Y		; get array size high byte
00123Cr 2  65 A5        	ADC	Nbendh		; add start of this array high byte
00123Er 2  85 A5        	STA	Nbendh		; save start of next array high byte
001240r 2  A0 01        	LDY	#$01			; set index
001242r 2  B1 71        	LDA	(ut1_pl),Y		; get name second byte
001244r 2  10 DB        	BPL	LAB_218B		; skip if not string array
001246r 2               
001246r 2               ; was string array so ..
001246r 2               
001246r 2  A0 04        	LDY	#$04			; set index
001248r 2  B1 71        	LDA	(ut1_pl),Y		; get # of dimensions
00124Ar 2  0A           	ASL				; *2
00124Br 2  69 05        	ADC	#$05			; +5 (array header size)
00124Dr 2  20 rr rr     	JSR	LAB_2208		; go set up for first element
001250r 2               LAB_21C4
001250r 2  E4 A5        	CPX	Nbendh		; compare with start of next array high byte
001252r 2  D0 04        	BNE	LAB_21CC		; branch if <> (go do this array)
001254r 2               
001254r 2  C5 A4        	CMP	Nbendl		; else compare element pointer low byte with next array
001256r 2               					; low byte
001256r 2  F0 CD        	BEQ	LAB_218F		; if equal then go do next array
001258r 2               
001258r 2               LAB_21CC
001258r 2  20 rr rr     	JSR	LAB_21D7		; go defrag array strings
00125Br 2  F0 F3        	BEQ	LAB_21C4		; go do next array string (loop always)
00125Dr 2               
00125Dr 2               ; defrag string variables
00125Dr 2               ; enter with XA = variable pointer
00125Dr 2               ; return with XA = next variable pointer
00125Dr 2               
00125Dr 2               LAB_21D1
00125Dr 2  C8           	INY				; increment index (Y was $00)
00125Er 2  B1 71        	LDA	(ut1_pl),Y		; get var name byte 2
001260r 2  10 30        	BPL	LAB_2206		; if not string, step pointer to next var and return
001262r 2               
001262r 2  C8           	INY				; else increment index
001263r 2               LAB_21D7
001263r 2  B1 71        	LDA	(ut1_pl),Y		; get string length
001265r 2  F0 2B        	BEQ	LAB_2206		; if null, step pointer to next string and return
001267r 2               
001267r 2  C8           	INY				; else increment index
001268r 2  B1 71        	LDA	(ut1_pl),Y		; get string pointer low byte
00126Ar 2  AA           	TAX				; copy to X
00126Br 2  C8           	INY				; increment index
00126Cr 2  B1 71        	LDA	(ut1_pl),Y		; get string pointer high byte
00126Er 2  C5 82        	CMP	Sstorh		; compare bottom of string space high byte
001270r 2  90 06        	BCC	LAB_21EC		; branch if less
001272r 2               
001272r 2  D0 1E        	BNE	LAB_2206		; if greater, step pointer to next string and return
001274r 2               
001274r 2               					; high bytes were = so compare low bytes
001274r 2  E4 81        	CPX	Sstorl		; compare bottom of string space low byte
001276r 2  B0 1A        	BCS	LAB_2206		; if >=, step pointer to next string and return
001278r 2               
001278r 2               					; string pointer is < string storage pointer (pos in mem)
001278r 2               LAB_21EC
001278r 2  C5 AB        	CMP	Histrh		; compare to highest string high byte
00127Ar 2  90 17        	BCC	LAB_2207		; if <, step pointer to next string and return
00127Cr 2               
00127Cr 2  D0 04        	BNE	LAB_21F6		; if > update pointers, step to next and return
00127Er 2               
00127Er 2               					; high bytes were = so compare low bytes
00127Er 2  E4 AA        	CPX	Histrl		; compare to highest string low byte
001280r 2  90 11        	BCC	LAB_2207		; if <, step pointer to next string and return
001282r 2               
001282r 2               					; string is in string memory space
001282r 2               LAB_21F6
001282r 2  86 AA        	STX	Histrl		; save as new highest string low byte
001284r 2  85 AB        	STA	Histrh		; save as new highest string high byte
001286r 2  A5 71        	LDA	ut1_pl		; get start of vars(descriptors) low byte
001288r 2  A6 72        	LDX	ut1_ph		; get start of vars(descriptors) high byte
00128Ar 2  85 9C        	STA	garb_l		; save as working pointer low byte
00128Cr 2  86 9D        	STX	garb_h		; save as working pointer high byte
00128Er 2  88           	DEY				; decrement index DIFFERS
00128Fr 2  88           	DEY				; decrement index (should point to descriptor start)
001290r 2  84 A2        	STY	g_indx		; save index pointer
001292r 2               
001292r 2               					; step pointer to next string
001292r 2               LAB_2206
001292r 2  18           	CLC				; clear carry for add
001293r 2               LAB_2207
001293r 2  A5 A0        	LDA	g_step		; get step size
001295r 2               LAB_2208
001295r 2  65 71        	ADC	ut1_pl		; add pointer low byte
001297r 2  85 71        	STA	ut1_pl		; save pointer low byte
001299r 2  90 02        	BCC	LAB_2211		; branch if no overflow
00129Br 2               
00129Br 2  E6 72        	INC	ut1_ph		; else increment high byte
00129Dr 2               LAB_2211
00129Dr 2  A6 72        	LDX	ut1_ph		; get pointer high byte
00129Fr 2  A0 00        	LDY	#$00			; clear Y
0012A1r 2  60           	RTS
0012A2r 2               
0012A2r 2               ; search complete, now either exit or set-up and move string
0012A2r 2               
0012A2r 2               LAB_2216
0012A2r 2  C6 A0        	DEC	g_step		; decrement step size (now $03 for descriptor stack)
0012A4r 2  A6 9D        	LDX	garb_h		; get string to move high byte
0012A6r 2  F0 F5        	BEQ	LAB_2211		; exit if nothing to move
0012A8r 2               
0012A8r 2  A4 A2        	LDY	g_indx		; get index byte back (points to descriptor)
0012AAr 2  18           	CLC				; clear carry for add
0012ABr 2  B1 9C        	LDA	(garb_l),Y		; get string length
0012ADr 2  65 AA        	ADC	Histrl		; add highest string low byte
0012AFr 2  85 A6        	STA	Obendl		; save old block end low pointer
0012B1r 2  A5 AB        	LDA	Histrh		; get highest string high byte
0012B3r 2  69 00        	ADC	#$00			; add any carry
0012B5r 2  85 A7        	STA	Obendh		; save old block end high byte
0012B7r 2  A5 81        	LDA	Sstorl		; get bottom of string space low byte
0012B9r 2  A6 82        	LDX	Sstorh		; get bottom of string space high byte
0012BBr 2  85 A4        	STA	Nbendl		; save new block end low byte
0012BDr 2  86 A5        	STX	Nbendh		; save new block end high byte
0012BFr 2  20 rr rr     	JSR	LAB_11D6		; open up space in memory, don't set array end
0012C2r 2  A4 A2        	LDY	g_indx		; get index byte
0012C4r 2  C8           	INY				; point to descriptor low byte
0012C5r 2  A5 A4        	LDA	Nbendl		; get string pointer low byte
0012C7r 2  91 9C        	STA	(garb_l),Y		; save new string pointer low byte
0012C9r 2  AA           	TAX				; copy string pointer low byte
0012CAr 2  E6 A5        	INC	Nbendh		; correct high byte (move sets high byte -1)
0012CCr 2  A5 A5        	LDA	Nbendh		; get new string pointer high byte
0012CEr 2  C8           	INY				; point to descriptor high byte
0012CFr 2  91 9C        	STA	(garb_l),Y		; save new string pointer high byte
0012D1r 2  4C rr rr     	JMP	LAB_214B		; re-run routine from last ending
0012D4r 2               					; (but don't collect this string)
0012D4r 2               
0012D4r 2               ; concatenate
0012D4r 2               ; add strings, string 1 is in descriptor des_pl, string 2 is in line
0012D4r 2               
0012D4r 2               LAB_224D
0012D4r 2  A5 AF        	LDA	des_ph		; get descriptor pointer high byte
0012D6r 2  48           	PHA				; put on stack
0012D7r 2  A5 AE        	LDA	des_pl		; get descriptor pointer low byte
0012D9r 2  48           	PHA				; put on stack
0012DAr 2  20 rr rr     	JSR	LAB_GVAL		; get value from line
0012DDr 2  20 rr rr     	JSR	LAB_CTST		; check if source is string, else do type mismatch
0012E0r 2  68           	PLA				; get descriptor pointer low byte back
0012E1r 2  85 B8        	STA	ssptr_l		; set pointer low byte
0012E3r 2  68           	PLA				; get descriptor pointer high byte back
0012E4r 2  85 B9        	STA	ssptr_h		; set pointer high byte
0012E6r 2  A0 00        	LDY	#$00			; clear index
0012E8r 2  B1 B8        	LDA	(ssptr_l),Y		; get length_1 from descriptor
0012EAr 2  18           	CLC				; clear carry for add
0012EBr 2  71 AE        	ADC	(des_pl),Y		; add length_2
0012EDr 2  90 05        	BCC	LAB_226D		; branch if no overflow
0012EFr 2               
0012EFr 2  A2 1A        	LDX	#$1A			; else set error code $1A ("String too long" error)
0012F1r 2  4C rr rr     	JMP	LAB_XERR		; do error #X, then warm start
0012F4r 2               
0012F4r 2               LAB_226D
0012F4r 2  20 rr rr     	JSR	LAB_209C		; copy des_pl/h to des_2l/h and make string space A bytes
0012F7r 2               					; long
0012F7r 2  20 rr rr     	JSR	LAB_228A		; copy string from descriptor (sdescr) to (Sutill)
0012FAr 2  A5 9E        	LDA	des_2l		; get descriptor pointer low byte
0012FCr 2  A4 9F        	LDY	des_2h		; get descriptor pointer high byte
0012FEr 2  20 rr rr     	JSR	LAB_22BA		; pop (YA) descriptor off stack or from top of string space
001301r 2               					; returns with A = length, ut1_pl = pointer low byte,
001301r 2               					; ut1_ph = pointer high byte
001301r 2  20 rr rr     	JSR	LAB_229C		; store string A bytes long from (ut1_pl) to (Sutill)
001304r 2  A5 B8        	LDA	ssptr_l		;.set descriptor pointer low byte
001306r 2  A4 B9        	LDY	ssptr_h		;.set descriptor pointer high byte
001308r 2  20 rr rr     	JSR	LAB_22BA		; pop (YA) descriptor off stack or from top of string space
00130Br 2               					; returns with A = length, X=ut1_pl=pointer low byte,
00130Br 2               					; Y=ut1_ph=pointer high byte
00130Br 2  20 rr rr     	JSR	LAB_RTST		; check for space on descriptor stack then put string
00130Er 2               					; address and length on descriptor stack and update stack
00130Er 2               					; pointers
00130Er 2  4C rr rr     	JMP	LAB_1ADB		;.continue evaluation
001311r 2               
001311r 2               ; copy string from descriptor (sdescr) to (Sutill)
001311r 2               
001311r 2               LAB_228A
001311r 2  A0 00        	LDY	#$00			; clear index
001313r 2  B1 B8        	LDA	(sdescr),Y		; get string length
001315r 2  48           	PHA				; save on stack
001316r 2  C8           	INY				; increment index
001317r 2  B1 B8        	LDA	(sdescr),Y		; get source string pointer low byte
001319r 2  AA           	TAX				; copy to X
00131Ar 2  C8           	INY				; increment index
00131Br 2  B1 B8        	LDA	(sdescr),Y		; get source string pointer high byte
00131Dr 2  A8           	TAY				; copy to Y
00131Er 2  68           	PLA				; get length back
00131Fr 2               
00131Fr 2               ; store string A bytes long from YX to (Sutill)
00131Fr 2               
00131Fr 2               LAB_2298
00131Fr 2  86 71        	STX	ut1_pl		; save source string pointer low byte
001321r 2  84 72        	STY	ut1_ph		; save source string pointer high byte
001323r 2               
001323r 2               ; store string A bytes long from (ut1_pl) to (Sutill)
001323r 2               
001323r 2               LAB_229C
001323r 2  AA           	TAX				; copy length to index (don't count with Y)
001324r 2  F0 14        	BEQ	LAB_22B2		; branch if = $0 (null string) no need to add zero length
001326r 2               
001326r 2  A0 00        	LDY	#$00			; zero pointer (copy forward)
001328r 2               LAB_22A0
001328r 2  B1 71        	LDA	(ut1_pl),Y		; get source byte
00132Ar 2  91 83        	STA	(Sutill),Y		; save destination byte
00132Cr 2               
00132Cr 2  C8           	INY				; increment index
00132Dr 2  CA           	DEX				; decrement counter
00132Er 2  D0 F8        	BNE	LAB_22A0		; loop while <> 0
001330r 2               
001330r 2  98           	TYA				; restore length from Y
001331r 2               LAB_22A9
001331r 2  18           	CLC				; clear carry for add
001332r 2  65 83        	ADC	Sutill		; add string utility ptr low byte
001334r 2  85 83        	STA	Sutill		; save string utility ptr low byte
001336r 2  90 02        	BCC	LAB_22B2		; branch if no carry
001338r 2               
001338r 2  E6 84        	INC	Sutilh		; else increment string utility ptr high byte
00133Ar 2               LAB_22B2
00133Ar 2  60           	RTS
00133Br 2               
00133Br 2               ; evaluate string
00133Br 2               
00133Br 2               LAB_EVST
00133Br 2  20 rr rr     	JSR	LAB_CTST		; check if source is string, else do type mismatch
00133Er 2               
00133Er 2               ; pop string off descriptor stack, or from top of string space
00133Er 2               ; returns with A = length, X=pointer low byte, Y=pointer high byte
00133Er 2               
00133Er 2               LAB_22B6
00133Er 2  A5 AE        	LDA	des_pl		; get descriptor pointer low byte
001340r 2  A4 AF        	LDY	des_ph		; get descriptor pointer high byte
001342r 2               
001342r 2               ; pop (YA) descriptor off stack or from top of string space
001342r 2               ; returns with A = length, X=ut1_pl=pointer low byte, Y=ut1_ph=pointer high byte
001342r 2               
001342r 2               LAB_22BA
001342r 2  85 71        	STA	ut1_pl		; save descriptor pointer low byte
001344r 2  84 72        	STY	ut1_ph		; save descriptor pointer high byte
001346r 2  20 rr rr     	JSR	LAB_22EB		; clean descriptor stack, YA = pointer
001349r 2  08           	PHP				; save status flags
00134Ar 2  A0 00        	LDY	#$00			; clear index
00134Cr 2  B1 71        	LDA	(ut1_pl),Y		; get length from string descriptor
00134Er 2  48           	PHA				; put on stack
00134Fr 2  C8           	INY				; increment index
001350r 2  B1 71        	LDA	(ut1_pl),Y		; get string pointer low byte from descriptor
001352r 2  AA           	TAX				; copy to X
001353r 2  C8           	INY				; increment index
001354r 2  B1 71        	LDA	(ut1_pl),Y		; get string pointer high byte from descriptor
001356r 2  A8           	TAY				; copy to Y
001357r 2  68           	PLA				; get string length back
001358r 2  28           	PLP				; restore status
001359r 2  D0 13        	BNE	LAB_22E6		; branch if pointer <> last_sl,last_sh
00135Br 2               
00135Br 2  C4 82        	CPY	Sstorh		; compare bottom of string space high byte
00135Dr 2  D0 0F        	BNE	LAB_22E6		; branch if <>
00135Fr 2               
00135Fr 2  E4 81        	CPX	Sstorl		; else compare bottom of string space low byte
001361r 2  D0 0B        	BNE	LAB_22E6		; branch if <>
001363r 2               
001363r 2  48           	PHA				; save string length
001364r 2  18           	CLC				; clear carry for add
001365r 2  65 81        	ADC	Sstorl		; add bottom of string space low byte
001367r 2  85 81        	STA	Sstorl		; save bottom of string space low byte
001369r 2  90 02        	BCC	LAB_22E5		; skip increment if no overflow
00136Br 2               
00136Br 2  E6 82        	INC	Sstorh		; increment bottom of string space high byte
00136Dr 2               LAB_22E5
00136Dr 2  68           	PLA				; restore string length
00136Er 2               LAB_22E6
00136Er 2  86 71        	STX	ut1_pl		; save string pointer low byte
001370r 2  84 72        	STY	ut1_ph		; save string pointer high byte
001372r 2  60           	RTS
001373r 2               
001373r 2               ; clean descriptor stack, YA = pointer
001373r 2               ; checks if AY is on the descriptor stack, if so does a stack discard
001373r 2               
001373r 2               LAB_22EB
001373r 2  C4 67        	CPY	last_sh		; compare pointer high byte
001375r 2  D0 0C        	BNE	LAB_22FB		; exit if <>
001377r 2               
001377r 2  C5 66        	CMP	last_sl		; compare pointer low byte
001379r 2  D0 08        	BNE	LAB_22FB		; exit if <>
00137Br 2               
00137Br 2  85 65        	STA	next_s		; save descriptor stack pointer
00137Dr 2  E9 03        	SBC	#$03			; -3
00137Fr 2  85 66        	STA	last_sl		; save low byte -3
001381r 2  A0 00        	LDY	#$00			; clear high byte
001383r 2               LAB_22FB
001383r 2  60           	RTS
001384r 2               
001384r 2               ; perform CHR$()
001384r 2               
001384r 2               LAB_CHRS
001384r 2  20 rr rr     	JSR	LAB_EVBY		; evaluate byte expression, result in X
001387r 2  8A           	TXA				; copy to A
001388r 2  48           	PHA				; save character
001389r 2  A9 01        	LDA	#$01			; string is single byte
00138Br 2  20 rr rr     	JSR	LAB_MSSP		; make string space A bytes long A=$AC=length,
00138Er 2               					; X=$AD=Sutill=ptr low byte, Y=$AE=Sutilh=ptr high byte
00138Er 2  68           	PLA				; get character back
00138Fr 2  A0 00        	LDY	#$00			; clear index
001391r 2  91 AD        	STA	(str_pl),Y		; save byte in string (byte IS string!)
001393r 2  4C rr rr     	JMP	LAB_RTST		; check for space on descriptor stack then put string
001396r 2               					; address and length on descriptor stack and update stack
001396r 2               					; pointers
001396r 2               
001396r 2               ; perform LEFT$()
001396r 2               
001396r 2               LAB_LEFT
001396r 2  48           	PHA				; push byte parameter
001397r 2  20 rr rr     	JSR	LAB_236F		; pull string data and byte parameter from stack
00139Ar 2               					; return pointer in des_2l/h, byte in A (and X), Y=0
00139Ar 2  D1 9E        	CMP	(des_2l),Y		; compare byte parameter with string length
00139Cr 2  98           	TYA				; clear A
00139Dr 2  F0 09        	BEQ	LAB_2316		; go do string copy (branch always)
00139Fr 2               
00139Fr 2               ; perform RIGHT$()
00139Fr 2               
00139Fr 2               LAB_RIGHT
00139Fr 2  48           	PHA				; push byte parameter
0013A0r 2  20 rr rr     	JSR	LAB_236F		; pull string data and byte parameter from stack
0013A3r 2               					; return pointer in des_2l/h, byte in A (and X), Y=0
0013A3r 2  18           	CLC				; clear carry for add-1
0013A4r 2  F1 9E        	SBC	(des_2l),Y		; subtract string length
0013A6r 2  49 FF        	EOR	#$FF			; invert it (A=LEN(expression$)-l)
0013A8r 2               
0013A8r 2               LAB_2316
0013A8r 2  90 04        	BCC	LAB_231C		; branch if string length > byte parameter
0013AAr 2               
0013AAr 2  B1 9E        	LDA	(des_2l),Y		; else make parameter = length
0013ACr 2  AA           	TAX				; copy to byte parameter copy
0013ADr 2  98           	TYA				; clear string start offset
0013AEr 2               LAB_231C
0013AEr 2  48           	PHA				; save string start offset
0013AFr 2               LAB_231D
0013AFr 2  8A           	TXA				; copy byte parameter (or string length if <)
0013B0r 2               LAB_231E
0013B0r 2  48           	PHA				; save string length
0013B1r 2  20 rr rr     	JSR	LAB_MSSP		; make string space A bytes long A=$AC=length,
0013B4r 2               					; X=$AD=Sutill=ptr low byte, Y=$AE=Sutilh=ptr high byte
0013B4r 2  A5 9E        	LDA	des_2l		; get descriptor pointer low byte
0013B6r 2  A4 9F        	LDY	des_2h		; get descriptor pointer high byte
0013B8r 2  20 rr rr     	JSR	LAB_22BA		; pop (YA) descriptor off stack or from top of string space
0013BBr 2               					; returns with A = length, X=ut1_pl=pointer low byte,
0013BBr 2               					; Y=ut1_ph=pointer high byte
0013BBr 2  68           	PLA				; get string length back
0013BCr 2  A8           	TAY				; copy length to Y
0013BDr 2  68           	PLA				; get string start offset back
0013BEr 2  18           	CLC				; clear carry for add
0013BFr 2  65 71        	ADC	ut1_pl		; add start offset to string start pointer low byte
0013C1r 2  85 71        	STA	ut1_pl		; save string start pointer low byte
0013C3r 2  90 02        	BCC	LAB_2335		; branch if no overflow
0013C5r 2               
0013C5r 2  E6 72        	INC	ut1_ph		; else increment string start pointer high byte
0013C7r 2               LAB_2335
0013C7r 2  98           	TYA				; copy length to A
0013C8r 2  20 rr rr     	JSR	LAB_229C		; store string A bytes long from (ut1_pl) to (Sutill)
0013CBr 2  4C rr rr     	JMP	LAB_RTST		; check for space on descriptor stack then put string
0013CEr 2               					; address and length on descriptor stack and update stack
0013CEr 2               					; pointers
0013CEr 2               
0013CEr 2               ; perform MID$()
0013CEr 2               
0013CEr 2               LAB_MIDS
0013CEr 2  48           	PHA				; push byte parameter
0013CFr 2  A9 FF        	LDA	#$FF			; set default length = 255
0013D1r 2  85 AF        	STA	mids_l		; save default length
0013D3r 2  20 C2 00     	JSR	LAB_GBYT		; scan memory
0013D6r 2  C9 29        	CMP	#')'			; compare with ")"
0013D8r 2  F0 06        	BEQ	LAB_2358		; branch if = ")" (skip second byte get)
0013DAr 2               
0013DAr 2  20 rr rr     	JSR	LAB_1C01		; scan for "," , else do syntax error then warm start
0013DDr 2  20 rr rr     	JSR	LAB_GTBY		; get byte parameter (use copy in mids_l)
0013E0r 2               LAB_2358
0013E0r 2  20 rr rr     	JSR	LAB_236F		; pull string data and byte parameter from stack
0013E3r 2               					; return pointer in des_2l/h, byte in A (and X), Y=0
0013E3r 2  CA           	DEX				; decrement start index
0013E4r 2  8A           	TXA				; copy to A
0013E5r 2  48           	PHA				; save string start offset
0013E6r 2  18           	CLC				; clear carry for sub-1
0013E7r 2  A2 00        	LDX	#$00			; clear output string length
0013E9r 2  F1 9E        	SBC	(des_2l),Y		; subtract string length
0013EBr 2  B0 C2        	BCS	LAB_231D		; if start>string length go do null string
0013EDr 2               
0013EDr 2  49 FF        	EOR	#$FF			; complement -length
0013EFr 2  C5 AF        	CMP	mids_l		; compare byte parameter
0013F1r 2  90 BD        	BCC	LAB_231E		; if length>remaining string go do RIGHT$
0013F3r 2               
0013F3r 2  A5 AF        	LDA	mids_l		; get length byte
0013F5r 2  B0 B9        	BCS	LAB_231E		; go do string copy (branch always)
0013F7r 2               
0013F7r 2               ; pull string data and byte parameter from stack
0013F7r 2               ; return pointer in des_2l/h, byte in A (and X), Y=0
0013F7r 2               
0013F7r 2               LAB_236F
0013F7r 2  20 rr rr     	JSR	LAB_1BFB		; scan for ")" , else do syntax error then warm start
0013FAr 2  68           	PLA				; pull return address low byte (return address)
0013FBr 2  85 A2        	STA	Fnxjpl		; save functions jump vector low byte
0013FDr 2  68           	PLA				; pull return address high byte (return address)
0013FEr 2  85 A3        	STA	Fnxjph		; save functions jump vector high byte
001400r 2  68           	PLA				; pull byte parameter
001401r 2  AA           	TAX				; copy byte parameter to X
001402r 2  68           	PLA				; pull string pointer low byte
001403r 2  85 9E        	STA	des_2l		; save it
001405r 2  68           	PLA				; pull string pointer high byte
001406r 2  85 9F        	STA	des_2h		; save it
001408r 2  A0 00        	LDY	#$00			; clear index
00140Ar 2  8A           	TXA				; copy byte parameter
00140Br 2  F0 79        	BEQ	LAB_23A8		; if null do function call error then warm start
00140Dr 2               
00140Dr 2  E6 A2        	INC	Fnxjpl		; increment function jump vector low byte
00140Fr 2               					; (JSR pushes return addr-1. this is all very nice
00140Fr 2               					; but will go tits up if either call is on a page
00140Fr 2               					; boundary!)
00140Fr 2  6C A2 00     	JMP	(Fnxjpl)		; in effect, RTS
001412r 2               
001412r 2               ; perform LCASE$()
001412r 2               
001412r 2               LAB_LCASE
001412r 2  20 rr rr     	JSR	LAB_EVST		; evaluate string
001415r 2  85 AC        	STA	str_ln		; set string length
001417r 2  A8           	TAY				; copy length to Y
001418r 2  F0 38        	BEQ	NoString		; branch if null string
00141Ar 2               
00141Ar 2  20 rr rr     	JSR	LAB_MSSP		; make string space A bytes long A=length,
00141Dr 2               					; X=Sutill=ptr low byte, Y=Sutilh=ptr high byte
00141Dr 2  86 AD        	STX	str_pl		; save string pointer low byte
00141Fr 2  84 AE        	STY	str_ph		; save string pointer high byte
001421r 2  A8           	TAY				; get string length back
001422r 2               
001422r 2               LC_loop
001422r 2  88           	DEY				; decrement index
001423r 2  B1 71        	LDA	(ut1_pl),Y		; get byte from string
001425r 2  20 rr rr     	JSR	LAB_1D82		; is character "A" to "Z"
001428r 2  90 02        	BCC	NoUcase		; branch if not upper case alpha
00142Ar 2               
00142Ar 2  09 20        	ORA	#$20			; convert upper to lower case
00142Cr 2               NoUcase
00142Cr 2  91 83        	STA	(Sutill),Y		; save byte back to string
00142Er 2  98           	TYA				; test index
00142Fr 2  D0 F1        	BNE	LC_loop		; loop if not all done
001431r 2               
001431r 2  F0 1F        	BEQ	NoString		; tidy up and exit, branch always
001433r 2               
001433r 2               ; perform UCASE$()
001433r 2               
001433r 2               LAB_UCASE
001433r 2  20 rr rr     	JSR	LAB_EVST		; evaluate string
001436r 2  85 AC        	STA	str_ln		; set string length
001438r 2  A8           	TAY				; copy length to Y
001439r 2  F0 17        	BEQ	NoString		; branch if null string
00143Br 2               
00143Br 2  20 rr rr     	JSR	LAB_MSSP		; make string space A bytes long A=length,
00143Er 2               					; X=Sutill=ptr low byte, Y=Sutilh=ptr high byte
00143Er 2  86 AD        	STX	str_pl		; save string pointer low byte
001440r 2  84 AE        	STY	str_ph		; save string pointer high byte
001442r 2  A8           	TAY				; get string length back
001443r 2               
001443r 2               UC_loop
001443r 2  88           	DEY				; decrement index
001444r 2  B1 71        	LDA	(ut1_pl),Y		; get byte from string
001446r 2  20 rr rr     	JSR	LAB_CASC		; is character "a" to "z" (or "A" to "Z")
001449r 2  90 02        	BCC	NoLcase		; branch if not alpha
00144Br 2               
00144Br 2  29 DF        	AND	#$DF			; convert lower to upper case
00144Dr 2               NoLcase
00144Dr 2  91 83        	STA	(Sutill),Y		; save byte back to string
00144Fr 2  98           	TYA				; test index
001450r 2  D0 F1        	BNE	UC_loop		; loop if not all done
001452r 2               
001452r 2               NoString
001452r 2  4C rr rr     	JMP	LAB_RTST		; check for space on descriptor stack then put string
001455r 2               					; address and length on descriptor stack and update stack
001455r 2               					; pointers
001455r 2               
001455r 2               ; perform SADD()
001455r 2               
001455r 2               LAB_SADD
001455r 2  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
001458r 2  20 rr rr     	JSR	LAB_GVAR		; get var address
00145Br 2               
00145Br 2  20 rr rr     	JSR	LAB_1BFB		; scan for ")", else do syntax error then warm start
00145Er 2  20 rr rr     	JSR	LAB_CTST		; check if source is string, else do type mismatch
001461r 2               
001461r 2  A0 02        	LDY	#$02			; index to string pointer high byte
001463r 2  B1 95        	LDA	(Cvaral),Y		; get string pointer high byte
001465r 2  AA           	TAX				; copy string pointer high byte to X
001466r 2  88           	DEY				; index to string pointer low byte
001467r 2  B1 95        	LDA	(Cvaral),Y		; get string pointer low byte
001469r 2  A8           	TAY				; copy string pointer low byte to Y
00146Ar 2  8A           	TXA				; copy string pointer high byte to A
00146Br 2  4C rr rr     	JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
00146Er 2               
00146Er 2               ; perform LEN()
00146Er 2               
00146Er 2               LAB_LENS
00146Er 2  20 rr rr     	JSR	LAB_ESGL		; evaluate string, get length in A (and Y)
001471r 2  4C rr rr     	JMP	LAB_1FD0		; convert Y to byte in FAC1 and return
001474r 2               
001474r 2               ; evaluate string, get length in Y
001474r 2               
001474r 2               LAB_ESGL
001474r 2  20 rr rr     	JSR	LAB_EVST		; evaluate string
001477r 2  A8           	TAY				; copy length to Y
001478r 2  60           	RTS
001479r 2               
001479r 2               ; perform ASC()
001479r 2               
001479r 2               LAB_ASC
001479r 2  20 rr rr     	JSR	LAB_ESGL		; evaluate string, get length in A (and Y)
00147Cr 2  F0 08        	BEQ	LAB_23A8		; if null do function call error then warm start
00147Er 2               
00147Er 2  A0 00        	LDY	#$00			; set index to first character
001480r 2  B1 71        	LDA	(ut1_pl),Y		; get byte
001482r 2  A8           	TAY				; copy to Y
001483r 2  4C rr rr     	JMP	LAB_1FD0		; convert Y to byte in FAC1 and return
001486r 2               
001486r 2               ; do function call error then warm start
001486r 2               
001486r 2               LAB_23A8
001486r 2  4C rr rr     	JMP	LAB_FCER		; do function call error then warm start
001489r 2               
001489r 2               ; scan and get byte parameter
001489r 2               
001489r 2               LAB_SGBY
001489r 2  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
00148Cr 2               
00148Cr 2               ; get byte parameter
00148Cr 2               
00148Cr 2               LAB_GTBY
00148Cr 2  20 rr rr     	JSR	LAB_EVNM		; evaluate expression and check is numeric,
00148Fr 2               					; else do type mismatch
00148Fr 2               
00148Fr 2               ; evaluate byte expression, result in X
00148Fr 2               
00148Fr 2               LAB_EVBY
00148Fr 2  20 rr rr     	JSR	LAB_EVPI		; evaluate integer expression (no check)
001492r 2               
001492r 2  A4 AE        	LDY	FAC1_2		; get FAC1 mantissa2
001494r 2  D0 F0        	BNE	LAB_23A8		; if top byte <> 0 do function call error then warm start
001496r 2               
001496r 2  A6 AF        	LDX	FAC1_3		; get FAC1 mantissa3
001498r 2  4C C2 00     	JMP	LAB_GBYT		; scan memory and return
00149Br 2               
00149Br 2               ; perform VAL()
00149Br 2               
00149Br 2               LAB_VAL
00149Br 2  20 rr rr     	JSR	LAB_ESGL		; evaluate string, get length in A (and Y)
00149Er 2  D0 03        	BNE	LAB_23C5		; branch if not null string
0014A0r 2               
0014A0r 2               					; string was null so set result = $00
0014A0r 2  4C rr rr     	JMP	LAB_24F1		; clear FAC1 exponent and sign and return
0014A3r 2               
0014A3r 2               LAB_23C5
0014A3r 2  A6 C3        	LDX	Bpntrl		; get BASIC execute pointer low byte
0014A5r 2  A4 C4        	LDY	Bpntrh		; get BASIC execute pointer high byte
0014A7r 2  86 BA        	STX	Btmpl			; save BASIC execute pointer low byte
0014A9r 2  84 BB        	STY	Btmph			; save BASIC execute pointer high byte
0014ABr 2  A6 71        	LDX	ut1_pl		; get string pointer low byte
0014ADr 2  86 C3        	STX	Bpntrl		; save as BASIC execute pointer low byte
0014AFr 2  18           	CLC				; clear carry
0014B0r 2  65 71        	ADC	ut1_pl		; add string length
0014B2r 2  85 73        	STA	ut2_pl		; save string end low byte
0014B4r 2  A5 72        	LDA	ut1_ph		; get string pointer high byte
0014B6r 2  85 C4        	STA	Bpntrh		; save as BASIC execute pointer high byte
0014B8r 2  69 00        	ADC	#$00			; add carry to high byte
0014BAr 2  85 74        	STA	ut2_ph		; save string end high byte
0014BCr 2  A0 00        	LDY	#$00			; set index to $00
0014BEr 2  B1 73        	LDA	(ut2_pl),Y		; get string end +1 byte
0014C0r 2  48           	PHA				; push it
0014C1r 2  98           	TYA				; clear A
0014C2r 2  91 73        	STA	(ut2_pl),Y		; terminate string with $00
0014C4r 2  20 C2 00     	JSR	LAB_GBYT		; scan memory
0014C7r 2  20 rr rr     	JSR	LAB_2887		; get FAC1 from string
0014CAr 2  68           	PLA				; restore string end +1 byte
0014CBr 2  A0 00        	LDY	#$00			; set index to zero
0014CDr 2  91 73        	STA	(ut2_pl),Y		; put string end byte back
0014CFr 2               
0014CFr 2               ; restore BASIC execute pointer from temp (Btmpl/Btmph)
0014CFr 2               
0014CFr 2               LAB_23F3
0014CFr 2  A6 BA        	LDX	Btmpl			; get BASIC execute pointer low byte back
0014D1r 2  A4 BB        	LDY	Btmph			; get BASIC execute pointer high byte back
0014D3r 2  86 C3        	STX	Bpntrl		; save BASIC execute pointer low byte
0014D5r 2  84 C4        	STY	Bpntrh		; save BASIC execute pointer high byte
0014D7r 2  60           	RTS
0014D8r 2               
0014D8r 2               ; get two parameters for POKE or WAIT
0014D8r 2               
0014D8r 2               LAB_GADB
0014D8r 2  20 rr rr     	JSR	LAB_EVNM		; evaluate expression and check is numeric,
0014DBr 2               					; else do type mismatch
0014DBr 2  20 rr rr     	JSR	LAB_F2FX		; save integer part of FAC1 in temporary integer
0014DEr 2               
0014DEr 2               ; scan for "," and get byte, else do Syntax error then warm start
0014DEr 2               
0014DEr 2               LAB_SCGB
0014DEr 2  20 rr rr     	JSR	LAB_1C01		; scan for "," , else do syntax error then warm start
0014E1r 2  A5 12        	LDA	Itemph		; save temporary integer high byte
0014E3r 2  48           	PHA				; on stack
0014E4r 2  A5 11        	LDA	Itempl		; save temporary integer low byte
0014E6r 2  48           	PHA				; on stack
0014E7r 2  20 rr rr     	JSR	LAB_GTBY		; get byte parameter
0014EAr 2  68           	PLA				; pull low byte
0014EBr 2  85 11        	STA	Itempl		; restore temporary integer low byte
0014EDr 2  68           	PLA				; pull high byte
0014EEr 2  85 12        	STA	Itemph		; restore temporary integer high byte
0014F0r 2  60           	RTS
0014F1r 2               
0014F1r 2               ; convert float to fixed routine. accepts any value that fits in 24 bits, +ve or
0014F1r 2               ; -ve and converts it into a right truncated integer in Itempl and Itemph
0014F1r 2               
0014F1r 2               ; save unsigned 16 bit integer part of FAC1 in temporary integer
0014F1r 2               
0014F1r 2               LAB_F2FX
0014F1r 2  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
0014F3r 2  C9 98        	CMP	#$98			; compare with exponent = 2^24
0014F5r 2  B0 8F        	BCS	LAB_23A8		; if >= do function call error then warm start
0014F7r 2               
0014F7r 2               LAB_F2FU
0014F7r 2  20 rr rr     	JSR	LAB_2831		; convert FAC1 floating-to-fixed
0014FAr 2  A5 AE        	LDA	FAC1_2		; get FAC1 mantissa2
0014FCr 2  A4 AF        	LDY	FAC1_3		; get FAC1 mantissa3
0014FEr 2  84 11        	STY	Itempl		; save temporary integer low byte
001500r 2  85 12        	STA	Itemph		; save temporary integer high byte
001502r 2  60           	RTS
001503r 2               
001503r 2               ; perform PEEK()
001503r 2               
001503r 2               LAB_PEEK
001503r 2  20 rr rr     	JSR	LAB_F2FX		; save integer part of FAC1 in temporary integer
001506r 2  A2 00        	LDX	#$00			; clear index
001508r 2  A1 11        	LDA	(Itempl,X)		; get byte via temporary integer (addr)
00150Ar 2  A8           	TAY				; copy byte to Y
00150Br 2  4C rr rr     	JMP	LAB_1FD0		; convert Y to byte in FAC1 and return
00150Er 2               
00150Er 2               ; perform POKE
00150Er 2               
00150Er 2               LAB_POKE
00150Er 2  20 rr rr     	JSR	LAB_GADB		; get two parameters for POKE or WAIT
001511r 2  8A           	TXA				; copy byte argument to A
001512r 2  A2 00        	LDX	#$00			; clear index
001514r 2  81 11        	STA	(Itempl,X)		; save byte via temporary integer (addr)
001516r 2  60           	RTS
001517r 2               
001517r 2               ; perform DEEK()
001517r 2               
001517r 2               LAB_DEEK
001517r 2  20 rr rr     	JSR	LAB_F2FX		; save integer part of FAC1 in temporary integer
00151Ar 2  A2 00        	LDX	#$00			; clear index
00151Cr 2  A1 11        	LDA	(Itempl,X)		; PEEK low byte
00151Er 2  A8           	TAY				; copy to Y
00151Fr 2  E6 11        	INC	Itempl		; increment pointer low byte
001521r 2  D0 02        	BNE	Deekh			; skip high increment if no rollover
001523r 2               
001523r 2  E6 12        	INC	Itemph		; increment pointer high byte
001525r 2               Deekh
001525r 2  A1 11        	LDA	(Itempl,X)		; PEEK high byte
001527r 2  4C rr rr     	JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
00152Ar 2               
00152Ar 2               ; perform DOKE
00152Ar 2               
00152Ar 2               LAB_DOKE
00152Ar 2  20 rr rr     	JSR	LAB_EVNM		; evaluate expression and check is numeric,
00152Dr 2               					; else do type mismatch
00152Dr 2  20 rr rr     	JSR	LAB_F2FX		; convert floating-to-fixed
001530r 2               
001530r 2  84 97        	STY	Frnxtl		; save pointer low byte (float to fixed returns word in AY)
001532r 2  85 98        	STA	Frnxth		; save pointer high byte
001534r 2               
001534r 2  20 rr rr     	JSR	LAB_1C01		; scan for "," , else do syntax error then warm start
001537r 2  20 rr rr     	JSR	LAB_EVNM		; evaluate expression and check is numeric,
00153Ar 2               					; else do type mismatch
00153Ar 2  20 rr rr     	JSR	LAB_F2FX		; convert floating-to-fixed
00153Dr 2               
00153Dr 2  98           	TYA				; copy value low byte (float to fixed returns word in AY)
00153Er 2  A2 00        	LDX	#$00			; clear index
001540r 2  81 97        	STA	(Frnxtl,X)		; POKE low byte
001542r 2  E6 97        	INC	Frnxtl		; increment pointer low byte
001544r 2  D0 02        	BNE	Dokeh			; skip high increment if no rollover
001546r 2               
001546r 2  E6 98        	INC	Frnxth		; increment pointer high byte
001548r 2               Dokeh
001548r 2  A5 12        	LDA	Itemph		; get value high byte
00154Ar 2  81 97        	STA	(Frnxtl,X)		; POKE high byte
00154Cr 2  4C C2 00     	JMP	LAB_GBYT		; scan memory and return
00154Fr 2               
00154Fr 2               ; perform SWAP
00154Fr 2               
00154Fr 2               LAB_SWAP
00154Fr 2  20 rr rr     	JSR	LAB_GVAR		; get var1 address
001552r 2  85 97        	STA	Lvarpl		; save var1 address low byte
001554r 2  84 98        	STY	Lvarph		; save var1 address high byte
001556r 2  A5 5F        	LDA	Dtypef		; get data type flag, $FF=string, $00=numeric
001558r 2  48           	PHA				; save data type flag
001559r 2               
001559r 2  20 rr rr     	JSR	LAB_1C01		; scan for "," , else do syntax error then warm start
00155Cr 2  20 rr rr     	JSR	LAB_GVAR		; get var2 address (pointer in Cvaral/h)
00155Fr 2  68           	PLA				; pull var1 data type flag
001560r 2  45 5F        	EOR	Dtypef		; compare with var2 data type
001562r 2  10 10        	BPL	SwapErr		; exit if not both the same type
001564r 2               
001564r 2  A0 03        	LDY	#$03			; four bytes to swap (either value or descriptor+1)
001566r 2               SwapLp
001566r 2  B1 97        	LDA	(Lvarpl),Y		; get byte from var1
001568r 2  AA           	TAX				; save var1 byte
001569r 2  B1 95        	LDA	(Cvaral),Y		; get byte from var2
00156Br 2  91 97        	STA	(Lvarpl),Y		; save byte to var1
00156Dr 2  8A           	TXA				; restore var1 byte
00156Er 2  91 95        	STA	(Cvaral),Y		; save byte to var2
001570r 2  88           	DEY				; decrement index
001571r 2  10 F3        	BPL	SwapLp		; loop until done
001573r 2               
001573r 2  60           	RTS
001574r 2               
001574r 2               SwapErr
001574r 2  4C rr rr     	JMP	LAB_1ABC		; do "Type mismatch" error then warm start
001577r 2               
001577r 2               ; perform CALL
001577r 2               
001577r 2               LAB_CALL
001577r 2  20 rr rr     	JSR	LAB_EVNM		; evaluate expression and check is numeric,
00157Ar 2               					; else do type mismatch
00157Ar 2  20 rr rr     	JSR	LAB_F2FX		; convert floating-to-fixed
00157Dr 2  A9 rr        	LDA	#>CallExit		; set return address high byte
00157Fr 2  48           	PHA				; put on stack
001580r 2  A9 rr        	LDA	#<CallExit-1	; set return address low byte
001582r 2  48           	PHA				; put on stack
001583r 2  6C 11 00     	JMP	(Itempl)		; do indirect jump to user routine
001586r 2               
001586r 2               ; if the called routine exits correctly then it will return to here. this will then get
001586r 2               ; the next byte for the interpreter and return
001586r 2               
001586r 2               CallExit
001586r 2  4C C2 00     	JMP	LAB_GBYT		; scan memory and return
001589r 2               
001589r 2               ; perform WAIT
001589r 2               
001589r 2               LAB_WAIT
001589r 2  20 rr rr     	JSR	LAB_GADB		; get two parameters for POKE or WAIT
00158Cr 2  86 97        	STX	Frnxtl		; save byte
00158Er 2  A2 00        	LDX	#$00			; clear mask
001590r 2  20 C2 00     	JSR	LAB_GBYT		; scan memory
001593r 2  F0 03        	BEQ	LAB_2441		; skip if no third argument
001595r 2               
001595r 2  20 rr rr     	JSR	LAB_SCGB		; scan for "," and get byte, else SN error then warm start
001598r 2               LAB_2441
001598r 2  86 98        	STX	Frnxth		; save EOR argument
00159Ar 2               LAB_2445
00159Ar 2  B1 11        	LDA	(Itempl),Y		; get byte via temporary integer (addr)
00159Cr 2  45 98        	EOR	Frnxth		; EOR with second argument (mask)
00159Er 2  25 97        	AND	Frnxtl		; AND with first argument (byte)
0015A0r 2  F0 F8        	BEQ	LAB_2445		; loop if result is zero
0015A2r 2               
0015A2r 2               LAB_244D
0015A2r 2  60           	RTS
0015A3r 2               
0015A3r 2               ; perform subtraction, FAC1 from (AY)
0015A3r 2               
0015A3r 2               LAB_2455
0015A3r 2  20 rr rr     	JSR	LAB_264D		; unpack memory (AY) into FAC2
0015A6r 2               
0015A6r 2               ; perform subtraction, FAC1 from FAC2
0015A6r 2               
0015A6r 2               LAB_SUBTRACT
0015A6r 2  A5 B0        	LDA	FAC1_s		; get FAC1 sign (b7)
0015A8r 2  49 FF        	EOR	#$FF			; complement it
0015AAr 2  85 B0        	STA	FAC1_s		; save FAC1 sign (b7)
0015ACr 2  45 B7        	EOR	FAC2_s		; EOR with FAC2 sign (b7)
0015AEr 2  85 B8        	STA	FAC_sc		; save sign compare (FAC1 EOR FAC2)
0015B0r 2  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
0015B2r 2  4C rr rr     	JMP	LAB_ADD		; go add FAC2 to FAC1
0015B5r 2               
0015B5r 2               ; perform addition
0015B5r 2               
0015B5r 2               LAB_2467
0015B5r 2  20 rr rr     	JSR	LAB_257B		; shift FACX A times right (>8 shifts)
0015B8r 2  90 4D        	BCC	LAB_24A8		;.go subtract mantissas
0015BAr 2               
0015BAr 2               ; add 0.5 to FAC1
0015BAr 2               
0015BAr 2               LAB_244E
0015BAr 2  A9 rr        	LDA	#<LAB_2A96		; set 0.5 pointer low byte
0015BCr 2  A0 rr        	LDY	#>LAB_2A96		; set 0.5 pointer high byte
0015BEr 2               
0015BEr 2               ; add (AY) to FAC1
0015BEr 2               
0015BEr 2               LAB_246C
0015BEr 2  20 rr rr     	JSR	LAB_264D		; unpack memory (AY) into FAC2
0015C1r 2               
0015C1r 2               ; add FAC2 to FAC1
0015C1r 2               
0015C1r 2               LAB_ADD
0015C1r 2  D0 10        	BNE	LAB_2474		; branch if FAC1 was not zero
0015C3r 2               
0015C3r 2               ; copy FAC2 to FAC1
0015C3r 2               
0015C3r 2               LAB_279B
0015C3r 2  A5 B7        	LDA	FAC2_s		; get FAC2 sign (b7)
0015C5r 2               
0015C5r 2               ; save FAC1 sign and copy ABS(FAC2) to FAC1
0015C5r 2               
0015C5r 2               LAB_279D
0015C5r 2  85 B0        	STA	FAC1_s		; save FAC1 sign (b7)
0015C7r 2  A2 04        	LDX	#$04			; 4 bytes to copy
0015C9r 2               LAB_27A1
0015C9r 2  B5 B2        	LDA	FAC1_o,X		; get byte from FAC2,X
0015CBr 2  95 AB        	STA	FAC1_e-1,X		; save byte at FAC1,X
0015CDr 2  CA           	DEX				; decrement count
0015CEr 2  D0 F9        	BNE	LAB_27A1		; loop if not all done
0015D0r 2               
0015D0r 2  86 B9        	STX	FAC1_r		; clear FAC1 rounding byte
0015D2r 2  60           	RTS
0015D3r 2               
0015D3r 2               					; FAC1 is non zero
0015D3r 2               LAB_2474
0015D3r 2  A6 B9        	LDX	FAC1_r		; get FAC1 rounding byte
0015D5r 2  86 A3        	STX	FAC2_r		; save as FAC2 rounding byte
0015D7r 2  A2 B3        	LDX	#FAC2_e		; set index to FAC2 exponent addr
0015D9r 2  A5 B3        	LDA	FAC2_e		; get FAC2 exponent
0015DBr 2               LAB_247C
0015DBr 2  A8           	TAY				; copy exponent
0015DCr 2  F0 C4        	BEQ	LAB_244D		; exit if zero
0015DEr 2               
0015DEr 2  38           	SEC				; set carry for subtract
0015DFr 2  E5 AC        	SBC	FAC1_e		; subtract FAC1 exponent
0015E1r 2  F0 24        	BEQ	LAB_24A8		; branch if = (go add mantissa)
0015E3r 2               
0015E3r 2  90 12        	BCC	LAB_2498		; branch if <
0015E5r 2               
0015E5r 2               					; FAC2>FAC1
0015E5r 2  84 AC        	STY	FAC1_e		; save FAC1 exponent
0015E7r 2  A4 B7        	LDY	FAC2_s		; get FAC2 sign (b7)
0015E9r 2  84 B0        	STY	FAC1_s		; save FAC1 sign (b7)
0015EBr 2  49 FF        	EOR	#$FF			; complement A
0015EDr 2  69 00        	ADC	#$00			; +1 (twos complement, carry is set)
0015EFr 2  A0 00        	LDY	#$00			; clear Y
0015F1r 2  84 A3        	STY	FAC2_r		; clear FAC2 rounding byte
0015F3r 2  A2 AC        	LDX	#FAC1_e		; set index to FAC1 exponent addr
0015F5r 2  D0 04        	BNE	LAB_249C		; branch always
0015F7r 2               
0015F7r 2               LAB_2498
0015F7r 2  A0 00        	LDY	#$00			; clear Y
0015F9r 2  84 B9        	STY	FAC1_r		; clear FAC1 rounding byte
0015FBr 2               LAB_249C
0015FBr 2  C9 F9        	CMP	#$F9			; compare exponent diff with $F9
0015FDr 2  30 B6        	BMI	LAB_2467		; branch if range $79-$F8
0015FFr 2               
0015FFr 2  A8           	TAY				; copy exponent difference to Y
001600r 2  A5 B9        	LDA	FAC1_r		; get FAC1 rounding byte
001602r 2  56 01        	LSR	PLUS_1,X		; shift FAC? mantissa1
001604r 2  20 rr rr     	JSR	LAB_2592		; shift FACX Y times right
001607r 2               
001607r 2               					; exponents are equal now do mantissa subtract
001607r 2               LAB_24A8
001607r 2  24 B8        	BIT	FAC_sc		; test sign compare (FAC1 EOR FAC2)
001609r 2  10 4C        	BPL	LAB_24F8		; if = add FAC2 mantissa to FAC1 mantissa and return
00160Br 2               
00160Br 2  A0 AC        	LDY	#FAC1_e		; set index to FAC1 exponent addr
00160Dr 2  E0 B3        	CPX	#FAC2_e		; compare X to FAC2 exponent addr
00160Fr 2  F0 02        	BEQ	LAB_24B4		; branch if =
001611r 2               
001611r 2  A0 B3        	LDY	#FAC2_e		; else set index to FAC2 exponent addr
001613r 2               
001613r 2               					; subtract smaller from bigger (take sign of bigger)
001613r 2               LAB_24B4
001613r 2  38           	SEC				; set carry for subtract
001614r 2  49 FF        	EOR	#$FF			; ones complement A
001616r 2  65 A3        	ADC	FAC2_r		; add FAC2 rounding byte
001618r 2  85 B9        	STA	FAC1_r		; save FAC1 rounding byte
00161Ar 2  B9 03 00     	LDA	PLUS_3,Y		; get FACY mantissa3
00161Dr 2  F5 03        	SBC	PLUS_3,X		; subtract FACX mantissa3
00161Fr 2  85 AF        	STA	FAC1_3		; save FAC1 mantissa3
001621r 2  B9 02 00     	LDA	PLUS_2,Y		; get FACY mantissa2
001624r 2  F5 02        	SBC	PLUS_2,X		; subtract FACX mantissa2
001626r 2  85 AE        	STA	FAC1_2		; save FAC1 mantissa2
001628r 2  B9 01 00     	LDA	PLUS_1,Y		; get FACY mantissa1
00162Br 2  F5 01        	SBC	PLUS_1,X		; subtract FACX mantissa1
00162Dr 2  85 AD        	STA	FAC1_1		; save FAC1 mantissa1
00162Fr 2               
00162Fr 2               ; do ABS and normalise FAC1
00162Fr 2               
00162Fr 2               LAB_24D0
00162Fr 2  B0 03        	BCS	LAB_24D5		; branch if number is +ve
001631r 2               
001631r 2  20 rr rr     	JSR	LAB_2537		; negate FAC1
001634r 2               
001634r 2               ; normalise FAC1
001634r 2               
001634r 2               LAB_24D5
001634r 2  A0 00        	LDY	#$00			; clear Y
001636r 2  98           	TYA				; clear A
001637r 2  18           	CLC				; clear carry for add
001638r 2               LAB_24D9
001638r 2  A6 AD        	LDX	FAC1_1		; get FAC1 mantissa1
00163Ar 2  D0 3E        	BNE	LAB_251B		; if not zero normalise FAC1
00163Cr 2               
00163Cr 2  A6 AE        	LDX	FAC1_2		; get FAC1 mantissa2
00163Er 2  86 AD        	STX	FAC1_1		; save FAC1 mantissa1
001640r 2  A6 AF        	LDX	FAC1_3		; get FAC1 mantissa3
001642r 2  86 AE        	STX	FAC1_2		; save FAC1 mantissa2
001644r 2  A6 B9        	LDX	FAC1_r		; get FAC1 rounding byte
001646r 2  86 AF        	STX	FAC1_3		; save FAC1 mantissa3
001648r 2  84 B9        	STY	FAC1_r		; clear FAC1 rounding byte
00164Ar 2  69 08        	ADC	#$08			; add x to exponent offset
00164Cr 2  C9 18        	CMP	#$18			; compare with $18 (max offset, all bits would be =0)
00164Er 2  D0 E8        	BNE	LAB_24D9		; loop if not max
001650r 2               
001650r 2               ; clear FAC1 exponent and sign
001650r 2               
001650r 2               LAB_24F1
001650r 2  A9 00        	LDA	#$00			; clear A
001652r 2               LAB_24F3
001652r 2  85 AC        	STA	FAC1_e		; set FAC1 exponent
001654r 2               
001654r 2               ; save FAC1 sign
001654r 2               
001654r 2               LAB_24F5
001654r 2  85 B0        	STA	FAC1_s		; save FAC1 sign (b7)
001656r 2  60           	RTS
001657r 2               
001657r 2               ; add FAC2 mantissa to FAC1 mantissa
001657r 2               
001657r 2               LAB_24F8
001657r 2  65 A3        	ADC	FAC2_r		; add FAC2 rounding byte
001659r 2  85 B9        	STA	FAC1_r		; save FAC1 rounding byte
00165Br 2  A5 AF        	LDA	FAC1_3		; get FAC1 mantissa3
00165Dr 2  65 B6        	ADC	FAC2_3		; add FAC2 mantissa3
00165Fr 2  85 AF        	STA	FAC1_3		; save FAC1 mantissa3
001661r 2  A5 AE        	LDA	FAC1_2		; get FAC1 mantissa2
001663r 2  65 B5        	ADC	FAC2_2		; add FAC2 mantissa2
001665r 2  85 AE        	STA	FAC1_2		; save FAC1 mantissa2
001667r 2  A5 AD        	LDA	FAC1_1		; get FAC1 mantissa1
001669r 2  65 B4        	ADC	FAC2_1		; add FAC2 mantissa1
00166Br 2  85 AD        	STA	FAC1_1		; save FAC1 mantissa1
00166Dr 2  B0 1A        	BCS	LAB_252A		; if carry then normalise FAC1 for C=1
00166Fr 2               
00166Fr 2  60           	RTS				; else just exit
001670r 2               
001670r 2               LAB_2511
001670r 2  69 01        	ADC	#$01			; add 1 to exponent offset
001672r 2  06 B9        	ASL	FAC1_r		; shift FAC1 rounding byte
001674r 2  26 AF        	ROL	FAC1_3		; shift FAC1 mantissa3
001676r 2  26 AE        	ROL	FAC1_2		; shift FAC1 mantissa2
001678r 2  26 AD        	ROL	FAC1_1		; shift FAC1 mantissa1
00167Ar 2               
00167Ar 2               ; normalise FAC1
00167Ar 2               
00167Ar 2               LAB_251B
00167Ar 2  10 F4        	BPL	LAB_2511		; loop if not normalised
00167Cr 2               
00167Cr 2  38           	SEC				; set carry for subtract
00167Dr 2  E5 AC        	SBC	FAC1_e		; subtract FAC1 exponent
00167Fr 2  B0 CF        	BCS	LAB_24F1		; branch if underflow (set result = $0)
001681r 2               
001681r 2  49 FF        	EOR	#$FF			; complement exponent
001683r 2  69 01        	ADC	#$01			; +1 (twos complement)
001685r 2  85 AC        	STA	FAC1_e		; save FAC1 exponent
001687r 2               
001687r 2               ; test and normalise FAC1 for C=0/1
001687r 2               
001687r 2               LAB_2528
001687r 2  90 0C        	BCC	LAB_2536		; exit if no overflow
001689r 2               
001689r 2               ; normalise FAC1 for C=1
001689r 2               
001689r 2               LAB_252A
001689r 2  E6 AC        	INC	FAC1_e		; increment FAC1 exponent
00168Br 2  F0 36        	BEQ	LAB_2564		; if zero do overflow error and warm start
00168Dr 2               
00168Dr 2  66 AD        	ROR	FAC1_1		; shift FAC1 mantissa1
00168Fr 2  66 AE        	ROR	FAC1_2		; shift FAC1 mantissa2
001691r 2  66 AF        	ROR	FAC1_3		; shift FAC1 mantissa3
001693r 2  66 B9        	ROR	FAC1_r		; shift FAC1 rounding byte
001695r 2               LAB_2536
001695r 2  60           	RTS
001696r 2               
001696r 2               ; negate FAC1
001696r 2               
001696r 2               LAB_2537
001696r 2  A5 B0        	LDA	FAC1_s		; get FAC1 sign (b7)
001698r 2  49 FF        	EOR	#$FF			; complement it
00169Ar 2  85 B0        	STA	FAC1_s		; save FAC1 sign (b7)
00169Cr 2               
00169Cr 2               ; twos complement FAC1 mantissa
00169Cr 2               
00169Cr 2               LAB_253D
00169Cr 2  A5 AD        	LDA	FAC1_1		; get FAC1 mantissa1
00169Er 2  49 FF        	EOR	#$FF			; complement it
0016A0r 2  85 AD        	STA	FAC1_1		; save FAC1 mantissa1
0016A2r 2  A5 AE        	LDA	FAC1_2		; get FAC1 mantissa2
0016A4r 2  49 FF        	EOR	#$FF			; complement it
0016A6r 2  85 AE        	STA	FAC1_2		; save FAC1 mantissa2
0016A8r 2  A5 AF        	LDA	FAC1_3		; get FAC1 mantissa3
0016AAr 2  49 FF        	EOR	#$FF			; complement it
0016ACr 2  85 AF        	STA	FAC1_3		; save FAC1 mantissa3
0016AEr 2  A5 B9        	LDA	FAC1_r		; get FAC1 rounding byte
0016B0r 2  49 FF        	EOR	#$FF			; complement it
0016B2r 2  85 B9        	STA	FAC1_r		; save FAC1 rounding byte
0016B4r 2  E6 B9        	INC	FAC1_r		; increment FAC1 rounding byte
0016B6r 2  D0 0A        	BNE	LAB_2563		; exit if no overflow
0016B8r 2               
0016B8r 2               ; increment FAC1 mantissa
0016B8r 2               
0016B8r 2               LAB_2559
0016B8r 2  E6 AF        	INC	FAC1_3		; increment FAC1 mantissa3
0016BAr 2  D0 06        	BNE	LAB_2563		; finished if no rollover
0016BCr 2               
0016BCr 2  E6 AE        	INC	FAC1_2		; increment FAC1 mantissa2
0016BEr 2  D0 02        	BNE	LAB_2563		; finished if no rollover
0016C0r 2               
0016C0r 2  E6 AD        	INC	FAC1_1		; increment FAC1 mantissa1
0016C2r 2               LAB_2563
0016C2r 2  60           	RTS
0016C3r 2               
0016C3r 2               ; do overflow error (overflow exit)
0016C3r 2               
0016C3r 2               LAB_2564
0016C3r 2  A2 0A        	LDX	#$0A			; error code $0A ("Overflow" error)
0016C5r 2  4C rr rr     	JMP	LAB_XERR		; do error #X, then warm start
0016C8r 2               
0016C8r 2               ; shift FCAtemp << A+8 times
0016C8r 2               
0016C8r 2               LAB_2569
0016C8r 2  A2 74        	LDX	#FACt_1-1		; set offset to FACtemp
0016CAr 2               LAB_256B
0016CAr 2  B4 03        	LDY	PLUS_3,X		; get FACX mantissa3
0016CCr 2  84 B9        	STY	FAC1_r		; save as FAC1 rounding byte
0016CEr 2  B4 02        	LDY	PLUS_2,X		; get FACX mantissa2
0016D0r 2  94 03        	STY	PLUS_3,X		; save FACX mantissa3
0016D2r 2  B4 01        	LDY	PLUS_1,X		; get FACX mantissa1
0016D4r 2  94 02        	STY	PLUS_2,X		; save FACX mantissa2
0016D6r 2  A4 B2        	LDY	FAC1_o		; get FAC1 overflow byte
0016D8r 2  94 01        	STY	PLUS_1,X		; save FACX mantissa1
0016DAr 2               
0016DAr 2               ; shift FACX -A times right (> 8 shifts)
0016DAr 2               
0016DAr 2               LAB_257B
0016DAr 2  69 08        	ADC	#$08			; add 8 to shift count
0016DCr 2  30 EC        	BMI	LAB_256B		; go do 8 shift if still -ve
0016DEr 2               
0016DEr 2  F0 EA        	BEQ	LAB_256B		; go do 8 shift if zero
0016E0r 2               
0016E0r 2  E9 08        	SBC	#$08			; else subtract 8 again
0016E2r 2  A8           	TAY				; save count to Y
0016E3r 2  A5 B9        	LDA	FAC1_r		; get FAC1 rounding byte
0016E5r 2  B0 12        	BCS	LAB_259A		;.
0016E7r 2               
0016E7r 2               LAB_2588
0016E7r 2  16 01        	ASL	PLUS_1,X		; shift FACX mantissa1
0016E9r 2  90 02        	BCC	LAB_258E		; branch if +ve
0016EBr 2               
0016EBr 2  F6 01        	INC	PLUS_1,X		; this sets b7 eventually
0016EDr 2               LAB_258E
0016EDr 2  76 01        	ROR	PLUS_1,X		; shift FACX mantissa1 (correct for ASL)
0016EFr 2  76 01        	ROR	PLUS_1,X		; shift FACX mantissa1 (put carry in b7)
0016F1r 2               
0016F1r 2               ; shift FACX Y times right
0016F1r 2               
0016F1r 2               LAB_2592
0016F1r 2  76 02        	ROR	PLUS_2,X		; shift FACX mantissa2
0016F3r 2  76 03        	ROR	PLUS_3,X		; shift FACX mantissa3
0016F5r 2  6A           	ROR				; shift FACX rounding byte
0016F6r 2  C8           	INY				; increment exponent diff
0016F7r 2  D0 EE        	BNE	LAB_2588		; branch if range adjust not complete
0016F9r 2               
0016F9r 2               LAB_259A
0016F9r 2  18           	CLC				; just clear it
0016FAr 2  60           	RTS
0016FBr 2               
0016FBr 2               ; perform LOG()
0016FBr 2               
0016FBr 2               LAB_LOG
0016FBr 2  20 rr rr     	JSR	LAB_27CA		; test sign and zero
0016FEr 2  F0 02        	BEQ	LAB_25C4		; if zero do function call error then warm start
001700r 2               
001700r 2  10 03        	BPL	LAB_25C7		; skip error if +ve
001702r 2               
001702r 2               LAB_25C4
001702r 2  4C rr rr     	JMP	LAB_FCER		; do function call error then warm start (-ve)
001705r 2               
001705r 2               LAB_25C7
001705r 2  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
001707r 2  E9 7F        	SBC	#$7F			; normalise it
001709r 2  48           	PHA				; save it
00170Ar 2  A9 80        	LDA	#$80			; set exponent to zero
00170Cr 2  85 AC        	STA	FAC1_e		; save FAC1 exponent
00170Er 2  A9 rr        	LDA	#<LAB_25AD		; set 1/root2 pointer low byte
001710r 2  A0 rr        	LDY	#>LAB_25AD		; set 1/root2 pointer high byte
001712r 2  20 rr rr     	JSR	LAB_246C		; add (AY) to FAC1 (1/root2)
001715r 2  A9 rr        	LDA	#<LAB_25B1		; set root2 pointer low byte
001717r 2  A0 rr        	LDY	#>LAB_25B1		; set root2 pointer high byte
001719r 2  20 rr rr     	JSR	LAB_26CA		; convert AY and do (AY)/FAC1 (root2/(x+(1/root2)))
00171Cr 2  A9 rr        	LDA	#<LAB_259C		; set 1 pointer low byte
00171Er 2  A0 rr        	LDY	#>LAB_259C		; set 1 pointer high byte
001720r 2  20 rr rr     	JSR	LAB_2455		; subtract (AY) from FAC1 ((root2/(x+(1/root2)))-1)
001723r 2  A9 rr        	LDA	#<LAB_25A0		; set pointer low byte to counter
001725r 2  A0 rr        	LDY	#>LAB_25A0		; set pointer high byte to counter
001727r 2  20 rr rr     	JSR	LAB_2B6E		; ^2 then series evaluation
00172Ar 2  A9 rr        	LDA	#<LAB_25B5		; set -0.5 pointer low byte
00172Cr 2  A0 rr        	LDY	#>LAB_25B5		; set -0.5 pointer high byte
00172Er 2  20 rr rr     	JSR	LAB_246C		; add (AY) to FAC1
001731r 2  68           	PLA				; restore FAC1 exponent
001732r 2  20 rr rr     	JSR	LAB_2912		; evaluate new ASCII digit
001735r 2  A9 rr        	LDA	#<LAB_25B9		; set LOG(2) pointer low byte
001737r 2  A0 rr        	LDY	#>LAB_25B9		; set LOG(2) pointer high byte
001739r 2               
001739r 2               ; do convert AY, FCA1*(AY)
001739r 2               
001739r 2               LAB_25FB
001739r 2  20 rr rr     	JSR	LAB_264D		; unpack memory (AY) into FAC2
00173Cr 2               LAB_MULTIPLY
00173Cr 2  F0 4C        	BEQ	LAB_264C		; exit if zero
00173Er 2               
00173Er 2  20 rr rr     	JSR	LAB_2673		; test and adjust accumulators
001741r 2  A9 00        	LDA	#$00			; clear A
001743r 2  85 75        	STA	FACt_1		; clear temp mantissa1
001745r 2  85 76        	STA	FACt_2		; clear temp mantissa2
001747r 2  85 77        	STA	FACt_3		; clear temp mantissa3
001749r 2  A5 B9        	LDA	FAC1_r		; get FAC1 rounding byte
00174Br 2  20 rr rr     	JSR	LAB_2622		; go do shift/add FAC2
00174Er 2  A5 AF        	LDA	FAC1_3		; get FAC1 mantissa3
001750r 2  20 rr rr     	JSR	LAB_2622		; go do shift/add FAC2
001753r 2  A5 AE        	LDA	FAC1_2		; get FAC1 mantissa2
001755r 2  20 rr rr     	JSR	LAB_2622		; go do shift/add FAC2
001758r 2  A5 AD        	LDA	FAC1_1		; get FAC1 mantissa1
00175Ar 2  20 rr rr     	JSR	LAB_2627		; go do shift/add FAC2
00175Dr 2  4C rr rr     	JMP	LAB_273C		; copy temp to FAC1, normalise and return
001760r 2               
001760r 2               LAB_2622
001760r 2  D0 03        	BNE	LAB_2627		; branch if byte <> zero
001762r 2               
001762r 2  4C rr rr     	JMP	LAB_2569		; shift FCAtemp << A+8 times
001765r 2               
001765r 2               					; else do shift and add
001765r 2               LAB_2627
001765r 2  4A           	LSR				; shift byte
001766r 2  09 80        	ORA	#$80			; set top bit (mark for 8 times)
001768r 2               LAB_262A
001768r 2  A8           	TAY				; copy result
001769r 2  90 13        	BCC	LAB_2640		; skip next if bit was zero
00176Br 2               
00176Br 2  18           	CLC				; clear carry for add
00176Cr 2  A5 77        	LDA	FACt_3		; get temp mantissa3
00176Er 2  65 B6        	ADC	FAC2_3		; add FAC2 mantissa3
001770r 2  85 77        	STA	FACt_3		; save temp mantissa3
001772r 2  A5 76        	LDA	FACt_2		; get temp mantissa2
001774r 2  65 B5        	ADC	FAC2_2		; add FAC2 mantissa2
001776r 2  85 76        	STA	FACt_2		; save temp mantissa2
001778r 2  A5 75        	LDA	FACt_1		; get temp mantissa1
00177Ar 2  65 B4        	ADC	FAC2_1		; add FAC2 mantissa1
00177Cr 2  85 75        	STA	FACt_1		; save temp mantissa1
00177Er 2               LAB_2640
00177Er 2  66 75        	ROR	FACt_1		; shift temp mantissa1
001780r 2  66 76        	ROR	FACt_2		; shift temp mantissa2
001782r 2  66 77        	ROR	FACt_3		; shift temp mantissa3
001784r 2  66 B9        	ROR	FAC1_r		; shift temp rounding byte
001786r 2  98           	TYA				; get byte back
001787r 2  4A           	LSR				; shift byte
001788r 2  D0 DE        	BNE	LAB_262A		; loop if all bits not done
00178Ar 2               
00178Ar 2               LAB_264C
00178Ar 2  60           	RTS
00178Br 2               
00178Br 2               ; unpack memory (AY) into FAC2
00178Br 2               
00178Br 2               LAB_264D
00178Br 2  85 71        	STA	ut1_pl		; save pointer low byte
00178Dr 2  84 72        	STY	ut1_ph		; save pointer high byte
00178Fr 2  A0 03        	LDY	#$03			; 4 bytes to get (0-3)
001791r 2  B1 71        	LDA	(ut1_pl),Y		; get mantissa3
001793r 2  85 B6        	STA	FAC2_3		; save FAC2 mantissa3
001795r 2  88           	DEY				; decrement index
001796r 2  B1 71        	LDA	(ut1_pl),Y		; get mantissa2
001798r 2  85 B5        	STA	FAC2_2		; save FAC2 mantissa2
00179Ar 2  88           	DEY				; decrement index
00179Br 2  B1 71        	LDA	(ut1_pl),Y		; get mantissa1+sign
00179Dr 2  85 B7        	STA	FAC2_s		; save FAC2 sign (b7)
00179Fr 2  45 B0        	EOR	FAC1_s		; EOR with FAC1 sign (b7)
0017A1r 2  85 B8        	STA	FAC_sc		; save sign compare (FAC1 EOR FAC2)
0017A3r 2  A5 B7        	LDA	FAC2_s		; recover FAC2 sign (b7)
0017A5r 2  09 80        	ORA	#$80			; set 1xxx xxx (set normal bit)
0017A7r 2  85 B4        	STA	FAC2_1		; save FAC2 mantissa1
0017A9r 2  88           	DEY				; decrement index
0017AAr 2  B1 71        	LDA	(ut1_pl),Y		; get exponent byte
0017ACr 2  85 B3        	STA	FAC2_e		; save FAC2 exponent
0017AEr 2  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
0017B0r 2  60           	RTS
0017B1r 2               
0017B1r 2               ; test and adjust accumulators
0017B1r 2               
0017B1r 2               LAB_2673
0017B1r 2  A5 B3        	LDA	FAC2_e		; get FAC2 exponent
0017B3r 2               LAB_2675
0017B3r 2  F0 1D        	BEQ	LAB_2696		; branch if FAC2 = $00 (handle underflow)
0017B5r 2               
0017B5r 2  18           	CLC				; clear carry for add
0017B6r 2  65 AC        	ADC	FAC1_e		; add FAC1 exponent
0017B8r 2  90 04        	BCC	LAB_2680		; branch if sum of exponents <$0100
0017BAr 2               
0017BAr 2  30 31        	BMI	LAB_269B		; do overflow error
0017BCr 2               
0017BCr 2  18           	CLC				; clear carry for the add
0017BDr 2  2C           	.byte	$2C			; makes next line BIT $1410
0017BEr 2               LAB_2680
0017BEr 2  10 12        	BPL	LAB_2696		; if +ve go handle underflow
0017C0r 2               
0017C0r 2  69 80        	ADC	#$80			; adjust exponent
0017C2r 2  85 AC        	STA	FAC1_e		; save FAC1 exponent
0017C4r 2  D0 03        	BNE	LAB_268B		; branch if not zero
0017C6r 2               
0017C6r 2  4C rr rr     	JMP	LAB_24F5		; save FAC1 sign and return
0017C9r 2               
0017C9r 2               LAB_268B
0017C9r 2  A5 B8        	LDA	FAC_sc		; get sign compare (FAC1 EOR FAC2)
0017CBr 2  85 B0        	STA	FAC1_s		; save FAC1 sign (b7)
0017CDr 2               LAB_268F
0017CDr 2  60           	RTS
0017CEr 2               
0017CEr 2               ; handle overflow and underflow
0017CEr 2               
0017CEr 2               LAB_2690
0017CEr 2  A5 B0        	LDA	FAC1_s		; get FAC1 sign (b7)
0017D0r 2  10 1B        	BPL	LAB_269B		; do overflow error
0017D2r 2               
0017D2r 2               					; handle underflow
0017D2r 2               LAB_2696
0017D2r 2  68           	PLA				; pop return address low byte
0017D3r 2  68           	PLA				; pop return address high byte
0017D4r 2  4C rr rr     	JMP	LAB_24F1		; clear FAC1 exponent and sign and return
0017D7r 2               
0017D7r 2               ; multiply by 10
0017D7r 2               
0017D7r 2               LAB_269E
0017D7r 2  20 rr rr     	JSR	LAB_27AB		; round and copy FAC1 to FAC2
0017DAr 2  AA           	TAX				; copy exponent (set the flags)
0017DBr 2  F0 F0        	BEQ	LAB_268F		; exit if zero
0017DDr 2               
0017DDr 2  18           	CLC				; clear carry for add
0017DEr 2  69 02        	ADC	#$02			; add two to exponent (*4)
0017E0r 2  B0 0B        	BCS	LAB_269B		; do overflow error if > $FF
0017E2r 2               
0017E2r 2  A2 00        	LDX	#$00			; clear byte
0017E4r 2  86 B8        	STX	FAC_sc		; clear sign compare (FAC1 EOR FAC2)
0017E6r 2  20 rr rr     	JSR	LAB_247C		; add FAC2 to FAC1 (*5)
0017E9r 2  E6 AC        	INC	FAC1_e		; increment FAC1 exponent (*10)
0017EBr 2  D0 E0        	BNE	LAB_268F		; if non zero just do RTS
0017EDr 2               
0017EDr 2               LAB_269B
0017EDr 2  4C rr rr     	JMP	LAB_2564		; do overflow error and warm start
0017F0r 2               
0017F0r 2               ; divide by 10
0017F0r 2               
0017F0r 2               LAB_26B9
0017F0r 2  20 rr rr     	JSR	LAB_27AB		; round and copy FAC1 to FAC2
0017F3r 2  A9 rr        	LDA	#<LAB_26B5		; set pointer to 10d low addr
0017F5r 2  A0 rr        	LDY	#>LAB_26B5		; set pointer to 10d high addr
0017F7r 2  A2 00        	LDX	#$00			; clear sign
0017F9r 2               
0017F9r 2               ; divide by (AY) (X=sign)
0017F9r 2               
0017F9r 2               LAB_26C2
0017F9r 2  86 B8        	STX	FAC_sc		; save sign compare (FAC1 EOR FAC2)
0017FBr 2  20 rr rr     	JSR	LAB_UFAC		; unpack memory (AY) into FAC1
0017FEr 2  4C rr rr     	JMP	LAB_DIVIDE		; do FAC2/FAC1
001801r 2               
001801r 2               					; Perform divide-by
001801r 2               ; convert AY and do (AY)/FAC1
001801r 2               
001801r 2               LAB_26CA
001801r 2  20 rr rr     	JSR	LAB_264D		; unpack memory (AY) into FAC2
001804r 2               
001804r 2               					; Perform divide-into
001804r 2               LAB_DIVIDE
001804r 2  F0 63        	BEQ	LAB_2737		; if zero go do /0 error
001806r 2               
001806r 2  20 rr rr     	JSR	LAB_27BA		; round FAC1
001809r 2  A9 00        	LDA	#$00			; clear A
00180Br 2  38           	SEC				; set carry for subtract
00180Cr 2  E5 AC        	SBC	FAC1_e		; subtract FAC1 exponent (2s complement)
00180Er 2  85 AC        	STA	FAC1_e		; save FAC1 exponent
001810r 2  20 rr rr     	JSR	LAB_2673		; test and adjust accumulators
001813r 2  E6 AC        	INC	FAC1_e		; increment FAC1 exponent
001815r 2  F0 D6        	BEQ	LAB_269B		; if zero do overflow error
001817r 2               
001817r 2  A2 FF        	LDX	#$FF			; set index for pre increment
001819r 2  A9 01        	LDA	#$01			; set bit to flag byte save
00181Br 2               LAB_26E4
00181Br 2  A4 B4        	LDY	FAC2_1		; get FAC2 mantissa1
00181Dr 2  C4 AD        	CPY	FAC1_1		; compare FAC1 mantissa1
00181Fr 2  D0 0A        	BNE	LAB_26F4		; branch if <>
001821r 2               
001821r 2  A4 B5        	LDY	FAC2_2		; get FAC2 mantissa2
001823r 2  C4 AE        	CPY	FAC1_2		; compare FAC1 mantissa2
001825r 2  D0 04        	BNE	LAB_26F4		; branch if <>
001827r 2               
001827r 2  A4 B6        	LDY	FAC2_3		; get FAC2 mantissa3
001829r 2  C4 AF        	CPY	FAC1_3		; compare FAC1 mantissa3
00182Br 2               LAB_26F4
00182Br 2  08           	PHP				; save FAC2-FAC1 compare status
00182Cr 2  2A           	ROL				; shift the result byte
00182Dr 2  90 0E        	BCC	LAB_2702		; if no carry skip the byte save
00182Fr 2               
00182Fr 2  A0 01        	LDY	#$01			; set bit to flag byte save
001831r 2  E8           	INX				; else increment the index to FACt
001832r 2  E0 02        	CPX	#$02			; compare with the index to FACt_3
001834r 2  30 04        	BMI	LAB_2701		; if not last byte just go save it
001836r 2               
001836r 2  D0 28        	BNE	LAB_272B		; if all done go save FAC1 rounding byte, normalise and
001838r 2               					; return
001838r 2               
001838r 2  A0 40        	LDY	#$40			; set bit to flag byte save for the rounding byte
00183Ar 2               LAB_2701
00183Ar 2  95 75        	STA	FACt_1,X		; write result byte to FACt_1 + index
00183Cr 2  98           	TYA				; copy the next save byte flag
00183Dr 2               LAB_2702
00183Dr 2  28           	PLP				; restore FAC2-FAC1 compare status
00183Er 2  90 14        	BCC	LAB_2704		; if FAC2 < FAC1 then skip the subtract
001840r 2               
001840r 2  A8           	TAY				; save FAC2-FAC1 compare status
001841r 2  A5 B6        	LDA	FAC2_3		; get FAC2 mantissa3
001843r 2  E5 AF        	SBC	FAC1_3		; subtract FAC1 mantissa3
001845r 2  85 B6        	STA	FAC2_3		; save FAC2 mantissa3
001847r 2  A5 B5        	LDA	FAC2_2		; get FAC2 mantissa2
001849r 2  E5 AE        	SBC	FAC1_2		; subtract FAC1 mantissa2
00184Br 2  85 B5        	STA	FAC2_2		; save FAC2 mantissa2
00184Dr 2  A5 B4        	LDA	FAC2_1		; get FAC2 mantissa1
00184Fr 2  E5 AD        	SBC	FAC1_1		; subtract FAC1 mantissa1
001851r 2  85 B4        	STA	FAC2_1		; save FAC2 mantissa1
001853r 2  98           	TYA				; restore FAC2-FAC1 compare status
001854r 2               
001854r 2               					; FAC2 = FAC2*2
001854r 2               LAB_2704
001854r 2  06 B6        	ASL	FAC2_3		; shift FAC2 mantissa3
001856r 2  26 B5        	ROL	FAC2_2		; shift FAC2 mantissa2
001858r 2  26 B4        	ROL	FAC2_1		; shift FAC2 mantissa1
00185Ar 2  B0 CF        	BCS	LAB_26F4		; loop with no compare
00185Cr 2               
00185Cr 2  30 BD        	BMI	LAB_26E4		; loop with compare
00185Er 2               
00185Er 2  10 CB        	BPL	LAB_26F4		; loop always with no compare
001860r 2               
001860r 2               ; do A<<6, save as FAC1 rounding byte, normalise and return
001860r 2               
001860r 2               LAB_272B
001860r 2  4A           	LSR				; shift b1 - b0 ..
001861r 2  6A           	ROR				; ..
001862r 2  6A           	ROR				; .. to b7 - b6
001863r 2  85 B9        	STA	FAC1_r		; save FAC1 rounding byte
001865r 2  28           	PLP				; dump FAC2-FAC1 compare status
001866r 2  4C rr rr     	JMP	LAB_273C		; copy temp to FAC1, normalise and return
001869r 2               
001869r 2               ; do "Divide by zero" error
001869r 2               
001869r 2               LAB_2737
001869r 2  A2 14        	LDX	#$14			; error code $14 ("Divide by zero" error)
00186Br 2  4C rr rr     	JMP	LAB_XERR		; do error #X, then warm start
00186Er 2               
00186Er 2               ; copy temp to FAC1 and normalise
00186Er 2               
00186Er 2               LAB_273C
00186Er 2  A5 75        	LDA	FACt_1		; get temp mantissa1
001870r 2  85 AD        	STA	FAC1_1		; save FAC1 mantissa1
001872r 2  A5 76        	LDA	FACt_2		; get temp mantissa2
001874r 2  85 AE        	STA	FAC1_2		; save FAC1 mantissa2
001876r 2  A5 77        	LDA	FACt_3		; get temp mantissa3
001878r 2  85 AF        	STA	FAC1_3		; save FAC1 mantissa3
00187Ar 2  4C rr rr     	JMP	LAB_24D5		; normalise FAC1 and return
00187Dr 2               
00187Dr 2               ; unpack memory (AY) into FAC1
00187Dr 2               
00187Dr 2               LAB_UFAC
00187Dr 2  85 71        	STA	ut1_pl		; save pointer low byte
00187Fr 2  84 72        	STY	ut1_ph		; save pointer high byte
001881r 2  A0 03        	LDY	#$03			; 4 bytes to do
001883r 2  B1 71        	LDA	(ut1_pl),Y		; get last byte
001885r 2  85 AF        	STA	FAC1_3		; save FAC1 mantissa3
001887r 2  88           	DEY				; decrement index
001888r 2  B1 71        	LDA	(ut1_pl),Y		; get last-1 byte
00188Ar 2  85 AE        	STA	FAC1_2		; save FAC1 mantissa2
00188Cr 2  88           	DEY				; decrement index
00188Dr 2  B1 71        	LDA	(ut1_pl),Y		; get second byte
00188Fr 2  85 B0        	STA	FAC1_s		; save FAC1 sign (b7)
001891r 2  09 80        	ORA	#$80			; set 1xxx xxxx (add normal bit)
001893r 2  85 AD        	STA	FAC1_1		; save FAC1 mantissa1
001895r 2  88           	DEY				; decrement index
001896r 2  B1 71        	LDA	(ut1_pl),Y		; get first byte (exponent)
001898r 2  85 AC        	STA	FAC1_e		; save FAC1 exponent
00189Ar 2  84 B9        	STY	FAC1_r		; clear FAC1 rounding byte
00189Cr 2  60           	RTS
00189Dr 2               
00189Dr 2               ; pack FAC1 into Adatal
00189Dr 2               
00189Dr 2               LAB_276E
00189Dr 2  A2 A4        	LDX	#<Adatal		; set pointer low byte
00189Fr 2               LAB_2770
00189Fr 2  A0 00        	LDY	#>Adatal		; set pointer high byte
0018A1r 2  F0 04        	BEQ	LAB_2778		; pack FAC1 into (XY) and return
0018A3r 2               
0018A3r 2               ; pack FAC1 into (Lvarpl)
0018A3r 2               
0018A3r 2               LAB_PFAC
0018A3r 2  A6 97        	LDX	Lvarpl		; get destination pointer low byte
0018A5r 2  A4 98        	LDY	Lvarph		; get destination pointer high byte
0018A7r 2               
0018A7r 2               ; pack FAC1 into (XY)
0018A7r 2               
0018A7r 2               LAB_2778
0018A7r 2  20 rr rr     	JSR	LAB_27BA		; round FAC1
0018AAr 2  86 71        	STX	ut1_pl		; save pointer low byte
0018ACr 2  84 72        	STY	ut1_ph		; save pointer high byte
0018AEr 2  A0 03        	LDY	#$03			; set index
0018B0r 2  A5 AF        	LDA	FAC1_3		; get FAC1 mantissa3
0018B2r 2  91 71        	STA	(ut1_pl),Y		; store in destination
0018B4r 2  88           	DEY				; decrement index
0018B5r 2  A5 AE        	LDA	FAC1_2		; get FAC1 mantissa2
0018B7r 2  91 71        	STA	(ut1_pl),Y		; store in destination
0018B9r 2  88           	DEY				; decrement index
0018BAr 2  A5 B0        	LDA	FAC1_s		; get FAC1 sign (b7)
0018BCr 2  09 7F        	ORA	#$7F			; set bits x111 1111
0018BEr 2  25 AD        	AND	FAC1_1		; AND in FAC1 mantissa1
0018C0r 2  91 71        	STA	(ut1_pl),Y		; store in destination
0018C2r 2  88           	DEY				; decrement index
0018C3r 2  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
0018C5r 2  91 71        	STA	(ut1_pl),Y		; store in destination
0018C7r 2  84 B9        	STY	FAC1_r		; clear FAC1 rounding byte
0018C9r 2  60           	RTS
0018CAr 2               
0018CAr 2               ; round and copy FAC1 to FAC2
0018CAr 2               
0018CAr 2               LAB_27AB
0018CAr 2  20 rr rr     	JSR	LAB_27BA		; round FAC1
0018CDr 2               
0018CDr 2               ; copy FAC1 to FAC2
0018CDr 2               
0018CDr 2               LAB_27AE
0018CDr 2  A2 05        	LDX	#$05			; 5 bytes to copy
0018CFr 2               LAB_27B0
0018CFr 2  B5 AB        	LDA	FAC1_e-1,X		; get byte from FAC1,X
0018D1r 2  95 B2        	STA	FAC1_o,X		; save byte at FAC2,X
0018D3r 2  CA           	DEX				; decrement count
0018D4r 2  D0 F9        	BNE	LAB_27B0		; loop if not all done
0018D6r 2               
0018D6r 2  86 B9        	STX	FAC1_r		; clear FAC1 rounding byte
0018D8r 2               LAB_27B9
0018D8r 2  60           	RTS
0018D9r 2               
0018D9r 2               ; round FAC1
0018D9r 2               
0018D9r 2               LAB_27BA
0018D9r 2  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
0018DBr 2  F0 FB        	BEQ	LAB_27B9		; exit if zero
0018DDr 2               
0018DDr 2  06 B9        	ASL	FAC1_r		; shift FAC1 rounding byte
0018DFr 2  90 F7        	BCC	LAB_27B9		; exit if no overflow
0018E1r 2               
0018E1r 2               ; round FAC1 (no check)
0018E1r 2               
0018E1r 2               LAB_27C2
0018E1r 2  20 rr rr     	JSR	LAB_2559		; increment FAC1 mantissa
0018E4r 2  D0 F2        	BNE	LAB_27B9		; branch if no overflow
0018E6r 2               
0018E6r 2  4C rr rr     	JMP	LAB_252A		; normalise FAC1 for C=1 and return
0018E9r 2               
0018E9r 2               ; get FAC1 sign
0018E9r 2               ; return A=FF,C=1/-ve A=01,C=0/+ve
0018E9r 2               
0018E9r 2               LAB_27CA
0018E9r 2  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
0018EBr 2  F0 09        	BEQ	LAB_27D7		; exit if zero (already correct SGN(0)=0)
0018EDr 2               
0018EDr 2               ; return A=FF,C=1/-ve A=01,C=0/+ve
0018EDr 2               ; no = 0 check
0018EDr 2               
0018EDr 2               LAB_27CE
0018EDr 2  A5 B0        	LDA	FAC1_s		; else get FAC1 sign (b7)
0018EFr 2               
0018EFr 2               ; return A=FF,C=1/-ve A=01,C=0/+ve
0018EFr 2               ; no = 0 check, sign in A
0018EFr 2               
0018EFr 2               LAB_27D0
0018EFr 2  2A           	ROL				; move sign bit to carry
0018F0r 2  A9 FF        	LDA	#$FF			; set byte for -ve result
0018F2r 2  B0 02        	BCS	LAB_27D7		; return if sign was set (-ve)
0018F4r 2               
0018F4r 2  A9 01        	LDA	#$01			; else set byte for +ve result
0018F6r 2               LAB_27D7
0018F6r 2  60           	RTS
0018F7r 2               
0018F7r 2               ; perform SGN()
0018F7r 2               
0018F7r 2               LAB_SGN
0018F7r 2  20 rr rr     	JSR	LAB_27CA		; get FAC1 sign
0018FAr 2               					; return A=$FF/-ve A=$01/+ve
0018FAr 2               ; save A as integer byte
0018FAr 2               
0018FAr 2               LAB_27DB
0018FAr 2  85 AD        	STA	FAC1_1		; save FAC1 mantissa1
0018FCr 2  A9 00        	LDA	#$00			; clear A
0018FEr 2  85 AE        	STA	FAC1_2		; clear FAC1 mantissa2
001900r 2  A2 88        	LDX	#$88			; set exponent
001902r 2               
001902r 2               ; set exp=X, clearFAC1 mantissa3 and normalise
001902r 2               
001902r 2               LAB_27E3
001902r 2  A5 AD        	LDA	FAC1_1		; get FAC1 mantissa1
001904r 2  49 FF        	EOR	#$FF			; complement it
001906r 2  2A           	ROL				; sign bit into carry
001907r 2               
001907r 2               ; set exp=X, clearFAC1 mantissa3 and normalise
001907r 2               
001907r 2               LAB_STFA
001907r 2  A9 00        	LDA	#$00			; clear A
001909r 2  85 AF        	STA	FAC1_3		; clear FAC1 mantissa3
00190Br 2  86 AC        	STX	FAC1_e		; set FAC1 exponent
00190Dr 2  85 B9        	STA	FAC1_r		; clear FAC1 rounding byte
00190Fr 2  85 B0        	STA	FAC1_s		; clear FAC1 sign (b7)
001911r 2  4C rr rr     	JMP	LAB_24D0		; do ABS and normalise FAC1
001914r 2               
001914r 2               ; perform ABS()
001914r 2               
001914r 2               LAB_ABS
001914r 2  46 B0        	LSR	FAC1_s		; clear FAC1 sign (put zero in b7)
001916r 2  60           	RTS
001917r 2               
001917r 2               ; compare FAC1 with (AY)
001917r 2               ; returns A=$00 if FAC1 = (AY)
001917r 2               ; returns A=$01 if FAC1 > (AY)
001917r 2               ; returns A=$FF if FAC1 < (AY)
001917r 2               
001917r 2               LAB_27F8
001917r 2  85 73        	STA	ut2_pl		; save pointer low byte
001919r 2               LAB_27FA
001919r 2  84 74        	STY	ut2_ph		; save pointer high byte
00191Br 2  A0 00        	LDY	#$00			; clear index
00191Dr 2  B1 73        	LDA	(ut2_pl),Y		; get exponent
00191Fr 2  C8           	INY				; increment index
001920r 2  AA           	TAX				; copy (AY) exponent to X
001921r 2  F0 C6        	BEQ	LAB_27CA		; branch if (AY) exponent=0 and get FAC1 sign
001923r 2               					; A=FF,C=1/-ve A=01,C=0/+ve
001923r 2               
001923r 2  B1 73        	LDA	(ut2_pl),Y		; get (AY) mantissa1 (with sign)
001925r 2  45 B0        	EOR	FAC1_s		; EOR FAC1 sign (b7)
001927r 2  30 C4        	BMI	LAB_27CE		; if signs <> do return A=FF,C=1/-ve
001929r 2               					; A=01,C=0/+ve and return
001929r 2               
001929r 2  E4 AC        	CPX	FAC1_e		; compare (AY) exponent with FAC1 exponent
00192Br 2  D0 1A        	BNE	LAB_2828		; branch if different
00192Dr 2               
00192Dr 2  B1 73        	LDA	(ut2_pl),Y		; get (AY) mantissa1 (with sign)
00192Fr 2  09 80        	ORA	#$80			; normalise top bit
001931r 2  C5 AD        	CMP	FAC1_1		; compare with FAC1 mantissa1
001933r 2  D0 12        	BNE	LAB_2828		; branch if different
001935r 2               
001935r 2  C8           	INY				; increment index
001936r 2  B1 73        	LDA	(ut2_pl),Y		; get mantissa2
001938r 2  C5 AE        	CMP	FAC1_2		; compare with FAC1 mantissa2
00193Ar 2  D0 0B        	BNE	LAB_2828		; branch if different
00193Cr 2               
00193Cr 2  C8           	INY				; increment index
00193Dr 2  A9 7F        	LDA	#$7F			; set for 1/2 value rounding byte
00193Fr 2  C5 B9        	CMP	FAC1_r		; compare with FAC1 rounding byte (set carry)
001941r 2  B1 73        	LDA	(ut2_pl),Y		; get mantissa3
001943r 2  E5 AF        	SBC	FAC1_3		; subtract FAC1 mantissa3
001945r 2  F0 28        	BEQ	LAB_2850		; exit if mantissa3 equal
001947r 2               
001947r 2               ; gets here if number <> FAC1
001947r 2               
001947r 2               LAB_2828
001947r 2  A5 B0        	LDA	FAC1_s		; get FAC1 sign (b7)
001949r 2  90 02        	BCC	LAB_282E		; branch if FAC1 > (AY)
00194Br 2               
00194Br 2  49 FF        	EOR	#$FF			; else toggle FAC1 sign
00194Dr 2               LAB_282E
00194Dr 2  4C rr rr     	JMP	LAB_27D0		; return A=FF,C=1/-ve A=01,C=0/+ve
001950r 2               
001950r 2               ; convert FAC1 floating-to-fixed
001950r 2               
001950r 2               LAB_2831
001950r 2  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
001952r 2  F0 4A        	BEQ	LAB_287F		; if zero go clear FAC1 and return
001954r 2               
001954r 2  38           	SEC				; set carry for subtract
001955r 2  E9 98        	SBC	#$98			; subtract maximum integer range exponent
001957r 2  24 B0        	BIT	FAC1_s		; test FAC1 sign (b7)
001959r 2  10 09        	BPL	LAB_2845		; branch if FAC1 +ve
00195Br 2               
00195Br 2               					; FAC1 was -ve
00195Br 2  AA           	TAX				; copy subtracted exponent
00195Cr 2  A9 FF        	LDA	#$FF			; overflow for -ve number
00195Er 2  85 B2        	STA	FAC1_o		; set FAC1 overflow byte
001960r 2  20 rr rr     	JSR	LAB_253D		; twos complement FAC1 mantissa
001963r 2  8A           	TXA				; restore subtracted exponent
001964r 2               LAB_2845
001964r 2  A2 AC        	LDX	#FAC1_e		; set index to FAC1
001966r 2  C9 F9        	CMP	#$F9			; compare exponent result
001968r 2  10 06        	BPL	LAB_2851		; if < 8 shifts shift FAC1 A times right and return
00196Ar 2               
00196Ar 2  20 rr rr     	JSR	LAB_257B		; shift FAC1 A times right (> 8 shifts)
00196Dr 2  84 B2        	STY	FAC1_o		; clear FAC1 overflow byte
00196Fr 2               LAB_2850
00196Fr 2  60           	RTS
001970r 2               
001970r 2               ; shift FAC1 A times right
001970r 2               
001970r 2               LAB_2851
001970r 2  A8           	TAY				; copy shift count
001971r 2  A5 B0        	LDA	FAC1_s		; get FAC1 sign (b7)
001973r 2  29 80        	AND	#$80			; mask sign bit only (x000 0000)
001975r 2  46 AD        	LSR	FAC1_1		; shift FAC1 mantissa1
001977r 2  05 AD        	ORA	FAC1_1		; OR sign in b7 FAC1 mantissa1
001979r 2  85 AD        	STA	FAC1_1		; save FAC1 mantissa1
00197Br 2  20 rr rr     	JSR	LAB_2592		; shift FAC1 Y times right
00197Er 2  84 B2        	STY	FAC1_o		; clear FAC1 overflow byte
001980r 2  60           	RTS
001981r 2               
001981r 2               ; perform INT()
001981r 2               
001981r 2               LAB_INT
001981r 2  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
001983r 2  C9 98        	CMP	#$98			; compare with max int
001985r 2  B0 1E        	BCS	LAB_2886		; exit if >= (already int, too big for fractional part!)
001987r 2               
001987r 2  20 rr rr     	JSR	LAB_2831		; convert FAC1 floating-to-fixed
00198Ar 2  84 B9        	STY	FAC1_r		; save FAC1 rounding byte
00198Cr 2  A5 B0        	LDA	FAC1_s		; get FAC1 sign (b7)
00198Er 2  84 B0        	STY	FAC1_s		; save FAC1 sign (b7)
001990r 2  49 80        	EOR	#$80			; toggle FAC1 sign
001992r 2  2A           	ROL				; shift into carry
001993r 2  A9 98        	LDA	#$98			; set new exponent
001995r 2  85 AC        	STA	FAC1_e		; save FAC1 exponent
001997r 2  A5 AF        	LDA	FAC1_3		; get FAC1 mantissa3
001999r 2  85 5B        	STA	Temp3			; save for EXP() function
00199Br 2  4C rr rr     	JMP	LAB_24D0		; do ABS and normalise FAC1
00199Er 2               
00199Er 2               ; clear FAC1 and return
00199Er 2               
00199Er 2               LAB_287F
00199Er 2  85 AD        	STA	FAC1_1		; clear FAC1 mantissa1
0019A0r 2  85 AE        	STA	FAC1_2		; clear FAC1 mantissa2
0019A2r 2  85 AF        	STA	FAC1_3		; clear FAC1 mantissa3
0019A4r 2  A8           	TAY				; clear Y
0019A5r 2               LAB_2886
0019A5r 2  60           	RTS
0019A6r 2               
0019A6r 2               ; get FAC1 from string
0019A6r 2               ; this routine now handles hex and binary values from strings
0019A6r 2               ; starting with "$" and "%" respectively
0019A6r 2               
0019A6r 2               LAB_2887
0019A6r 2  A0 00        	LDY	#$00			; clear Y
0019A8r 2  84 5F        	STY	Dtypef		; clear data type flag, $FF=string, $00=numeric
0019AAr 2  A2 09        	LDX	#$09			; set index
0019ACr 2               LAB_288B
0019ACr 2  94 A8        	STY	numexp,X		; clear byte
0019AEr 2  CA           	DEX				; decrement index
0019AFr 2  10 FB        	BPL	LAB_288B		; loop until numexp to negnum (and FAC1) = $00
0019B1r 2               
0019B1r 2  90 7F        	BCC	LAB_28FE		; branch if 1st character numeric
0019B3r 2               
0019B3r 2               ; get FAC1 from string .. first character wasn't numeric
0019B3r 2               
0019B3r 2  C9 2D        	CMP	#'-'			; else compare with "-"
0019B5r 2  D0 04        	BNE	LAB_289A		; branch if not "-"
0019B7r 2               
0019B7r 2  86 B1        	STX	negnum		; set flag for -ve number (X = $FF)
0019B9r 2  F0 04        	BEQ	LAB_289C		; branch always (go scan and check for hex/bin)
0019BBr 2               
0019BBr 2               ; get FAC1 from string .. first character wasn't numeric or -
0019BBr 2               
0019BBr 2               LAB_289A
0019BBr 2  C9 2B        	CMP	#'+'			; else compare with "+"
0019BDr 2  D0 05        	BNE	LAB_289D		; branch if not "+" (go check for hex/bin)
0019BFr 2               
0019BFr 2               ; was "+" or "-" to start, so get next character
0019BFr 2               
0019BFr 2               LAB_289C
0019BFr 2  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
0019C2r 2  90 6E        	BCC	LAB_28FE		; branch if numeric character
0019C4r 2               
0019C4r 2               ; code here for hex and binary numbers
0019C4r 2               
0019C4r 2               LAB_289D
0019C4r 2  C9 24        	CMP	#'$'			; else compare with "$"
0019C6r 2  D0 03        	BNE	LAB_NHEX		; branch if not "$"
0019C8r 2               
0019C8r 2  4C rr rr     	JMP	LAB_CHEX		; branch if "$"
0019CBr 2               
0019CBr 2               LAB_NHEX
0019CBr 2  C9 25        	CMP	#'%'			; else compare with "%"
0019CDr 2  D0 08        	BNE	LAB_28A3		; branch if not "%" (continue original code)
0019CFr 2               
0019CFr 2  4C rr rr     	JMP	LAB_CBIN		; branch if "%"
0019D2r 2               
0019D2r 2               LAB_289E
0019D2r 2  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory (ignore + or get next number)
0019D5r 2               LAB_28A1
0019D5r 2  90 5B        	BCC	LAB_28FE		; branch if numeric character
0019D7r 2               
0019D7r 2               ; get FAC1 from string .. character wasn't numeric, -, +, hex or binary
0019D7r 2               
0019D7r 2               LAB_28A3
0019D7r 2  C9 2E        	CMP	#'.'			; else compare with "."
0019D9r 2  F0 2E        	BEQ	LAB_28D5		; branch if "."
0019DBr 2               
0019DBr 2               ; get FAC1 from string .. character wasn't numeric, -, + or .
0019DBr 2               
0019DBr 2  C9 45        	CMP	#'E'			; else compare with "E"
0019DDr 2  D0 30        	BNE	LAB_28DB		; branch if not "E"
0019DFr 2               
0019DFr 2               					; was "E" so evaluate exponential part
0019DFr 2  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
0019E2r 2  90 17        	BCC	LAB_28C7		; branch if numeric character
0019E4r 2               
0019E4r 2  C9 B8        	CMP	#TK_MINUS		; else compare with token for -
0019E6r 2  F0 0E        	BEQ	LAB_28C2		; branch if token for -
0019E8r 2               
0019E8r 2  C9 2D        	CMP	#'-'			; else compare with "-"
0019EAr 2  F0 0A        	BEQ	LAB_28C2		; branch if "-"
0019ECr 2               
0019ECr 2  C9 B7        	CMP	#TK_PLUS		; else compare with token for +
0019EEr 2  F0 08        	BEQ	LAB_28C4		; branch if token for +
0019F0r 2               
0019F0r 2  C9 2B        	CMP	#'+'			; else compare with "+"
0019F2r 2  F0 04        	BEQ	LAB_28C4		; branch if "+"
0019F4r 2               
0019F4r 2  D0 07        	BNE	LAB_28C9		; branch always
0019F6r 2               
0019F6r 2               LAB_28C2
0019F6r 2  66 AB        	ROR	expneg		; set exponent -ve flag (C, which=1, into b7)
0019F8r 2               LAB_28C4
0019F8r 2  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
0019FBr 2               LAB_28C7
0019FBr 2  90 5B        	BCC	LAB_2925		; branch if numeric character
0019FDr 2               
0019FDr 2               LAB_28C9
0019FDr 2  24 AB        	BIT	expneg		; test exponent -ve flag
0019FFr 2  10 0E        	BPL	LAB_28DB		; if +ve go evaluate exponent
001A01r 2               
001A01r 2               					; else do exponent = -exponent
001A01r 2  A9 00        	LDA	#$00			; clear result
001A03r 2  38           	SEC				; set carry for subtract
001A04r 2  E5 A9        	SBC	expcnt		; subtract exponent byte
001A06r 2  4C rr rr     	JMP	LAB_28DD		; go evaluate exponent
001A09r 2               
001A09r 2               LAB_28D5
001A09r 2  66 AA        	ROR	numdpf		; set decimal point flag
001A0Br 2  24 AA        	BIT	numdpf		; test decimal point flag
001A0Dr 2  50 C3        	BVC	LAB_289E		; branch if only one decimal point so far
001A0Fr 2               
001A0Fr 2               					; evaluate exponent
001A0Fr 2               LAB_28DB
001A0Fr 2  A5 A9        	LDA	expcnt		; get exponent count byte
001A11r 2               LAB_28DD
001A11r 2  38           	SEC				; set carry for subtract
001A12r 2  E5 A8        	SBC	numexp		; subtract numerator exponent
001A14r 2  85 A9        	STA	expcnt		; save exponent count byte
001A16r 2  F0 12        	BEQ	LAB_28F6		; branch if no adjustment
001A18r 2               
001A18r 2  10 09        	BPL	LAB_28EF		; else if +ve go do FAC1*10^expcnt
001A1Ar 2               
001A1Ar 2               					; else go do FAC1/10^(0-expcnt)
001A1Ar 2               LAB_28E6
001A1Ar 2  20 rr rr     	JSR	LAB_26B9		; divide by 10
001A1Dr 2  E6 A9        	INC	expcnt		; increment exponent count byte
001A1Fr 2  D0 F9        	BNE	LAB_28E6		; loop until all done
001A21r 2               
001A21r 2  F0 07        	BEQ	LAB_28F6		; branch always
001A23r 2               
001A23r 2               LAB_28EF
001A23r 2  20 rr rr     	JSR	LAB_269E		; multiply by 10
001A26r 2  C6 A9        	DEC	expcnt		; decrement exponent count byte
001A28r 2  D0 F9        	BNE	LAB_28EF		; loop until all done
001A2Ar 2               
001A2Ar 2               LAB_28F6
001A2Ar 2  A5 B1        	LDA	negnum		; get -ve flag
001A2Cr 2  30 01        	BMI	LAB_28FB		; if -ve do - FAC1 and return
001A2Er 2               
001A2Er 2  60           	RTS
001A2Fr 2               
001A2Fr 2               ; do - FAC1 and return
001A2Fr 2               
001A2Fr 2               LAB_28FB
001A2Fr 2  4C rr rr     	JMP	LAB_GTHAN		; do - FAC1 and return
001A32r 2               
001A32r 2               ; do unsigned FAC1*10+number
001A32r 2               
001A32r 2               LAB_28FE
001A32r 2  48           	PHA				; save character
001A33r 2  24 AA        	BIT	numdpf		; test decimal point flag
001A35r 2  10 02        	BPL	LAB_2905		; skip exponent increment if not set
001A37r 2               
001A37r 2  E6 A8        	INC	numexp		; else increment number exponent
001A39r 2               LAB_2905
001A39r 2  20 rr rr     	JSR	LAB_269E		; multiply FAC1 by 10
001A3Cr 2  68           	PLA				; restore character
001A3Dr 2  29 0F        	AND	#$0F			; convert to binary
001A3Fr 2  20 rr rr     	JSR	LAB_2912		; evaluate new ASCII digit
001A42r 2  4C rr rr     	JMP	LAB_289E		; go do next character
001A45r 2               
001A45r 2               ; evaluate new ASCII digit
001A45r 2               
001A45r 2               LAB_2912
001A45r 2  48           	PHA				; save digit
001A46r 2  20 rr rr     	JSR	LAB_27AB		; round and copy FAC1 to FAC2
001A49r 2  68           	PLA				; restore digit
001A4Ar 2  20 rr rr     	JSR	LAB_27DB		; save A as integer byte
001A4Dr 2  A5 B7        	LDA	FAC2_s		; get FAC2 sign (b7)
001A4Fr 2  45 B0        	EOR	FAC1_s		; toggle with FAC1 sign (b7)
001A51r 2  85 B8        	STA	FAC_sc		; save sign compare (FAC1 EOR FAC2)
001A53r 2  A6 AC        	LDX	FAC1_e		; get FAC1 exponent
001A55r 2  4C rr rr     	JMP	LAB_ADD		; add FAC2 to FAC1 and return
001A58r 2               
001A58r 2               ; evaluate next character of exponential part of number
001A58r 2               
001A58r 2               LAB_2925
001A58r 2  A5 A9        	LDA	expcnt		; get exponent count byte
001A5Ar 2  C9 0A        	CMP	#$0A			; compare with 10 decimal
001A5Cr 2  90 09        	BCC	LAB_2934		; branch if less
001A5Er 2               
001A5Er 2  A9 64        	LDA	#$64			; make all -ve exponents = -100 decimal (causes underflow)
001A60r 2  24 AB        	BIT	expneg		; test exponent -ve flag
001A62r 2  30 0E        	BMI	LAB_2942		; branch if -ve
001A64r 2               
001A64r 2  4C rr rr     	JMP	LAB_2564		; else do overflow error
001A67r 2               
001A67r 2               LAB_2934
001A67r 2  0A           	ASL				; * 2
001A68r 2  0A           	ASL				; * 4
001A69r 2  65 A9        	ADC	expcnt		; * 5
001A6Br 2  0A           	ASL				; * 10
001A6Cr 2  A0 00        	LDY	#$00			; set index
001A6Er 2  71 C3        	ADC	(Bpntrl),Y		; add character (will be $30 too much!)
001A70r 2  E9 2F        	SBC	#'0'-1		; convert character to binary
001A72r 2               LAB_2942
001A72r 2  85 A9        	STA	expcnt		; save exponent count byte
001A74r 2  4C rr rr     	JMP	LAB_28C4		; go get next character
001A77r 2               
001A77r 2               ; print " in line [LINE #]"
001A77r 2               
001A77r 2               LAB_2953
001A77r 2  A9 rr        	LDA	#<LAB_LMSG		; point to " in line " message low byte
001A79r 2  A0 rr        	LDY	#>LAB_LMSG		; point to " in line " message high byte
001A7Br 2  20 rr rr     	JSR	LAB_18C3		; print null terminated string from memory
001A7Er 2               
001A7Er 2               					; print Basic line #
001A7Er 2  A5 88        	LDA	Clineh		; get current line high byte
001A80r 2  A6 87        	LDX	Clinel		; get current line low byte
001A82r 2               
001A82r 2               ; print XA as unsigned integer
001A82r 2               
001A82r 2               LAB_295E
001A82r 2  85 AD        	STA	FAC1_1		; save low byte as FAC1 mantissa1
001A84r 2  86 AE        	STX	FAC1_2		; save high byte as FAC1 mantissa2
001A86r 2  A2 90        	LDX	#$90			; set exponent to 16d bits
001A88r 2  38           	SEC				; set integer is +ve flag
001A89r 2  20 rr rr     	JSR	LAB_STFA		; set exp=X, clearFAC1 mantissa3 and normalise
001A8Cr 2  A0 00        	LDY	#$00			; clear index
001A8Er 2  98           	TYA				; clear A
001A8Fr 2  20 rr rr     	JSR	LAB_297B		; convert FAC1 to string, skip sign character save
001A92r 2  4C rr rr     	JMP	LAB_18C3		; print null terminated string from memory and return
001A95r 2               
001A95r 2               ; convert FAC1 to ASCII string result in (AY)
001A95r 2               ; not any more, moved scratchpad to page 0
001A95r 2               
001A95r 2               LAB_296E
001A95r 2  A0 01        	LDY	#$01			; set index = 1
001A97r 2  A9 20        	LDA	#$20			; character = " " (assume +ve)
001A99r 2  24 B0        	BIT	FAC1_s		; test FAC1 sign (b7)
001A9Br 2  10 02        	BPL	LAB_2978		; branch if +ve
001A9Dr 2               
001A9Dr 2  A9 2D        	LDA	#$2D			; else character = "-"
001A9Fr 2               LAB_2978
001A9Fr 2  99 EF 00     	STA	Decss,Y		; save leading character (" " or "-")
001AA2r 2               LAB_297B
001AA2r 2  85 B0        	STA	FAC1_s		; clear FAC1 sign (b7)
001AA4r 2  84 BA        	STY	Sendl			; save index
001AA6r 2  C8           	INY				; increment index
001AA7r 2  A6 AC        	LDX	FAC1_e		; get FAC1 exponent
001AA9r 2  D0 05        	BNE	LAB_2989		; branch if FAC1<>0
001AABr 2               
001AABr 2               					; exponent was $00 so FAC1 is 0
001AABr 2  A9 30        	LDA	#'0'			; set character = "0"
001AADr 2  4C rr rr     	JMP	LAB_2A89		; save last character, [EOT] and exit
001AB0r 2               
001AB0r 2               					; FAC1 is some non zero value
001AB0r 2               LAB_2989
001AB0r 2  A9 00        	LDA	#$00			; clear (number exponent count)
001AB2r 2  E0 81        	CPX	#$81			; compare FAC1 exponent with $81 (>1.00000)
001AB4r 2               
001AB4r 2  B0 09        	BCS	LAB_299A		; branch if FAC1=>1
001AB6r 2               
001AB6r 2               					; FAC1<1
001AB6r 2  A9 rr        	LDA	#<LAB_294F		; set pointer low byte to 1,000,000
001AB8r 2  A0 rr        	LDY	#>LAB_294F		; set pointer high byte to 1,000,000
001ABAr 2  20 rr rr     	JSR	LAB_25FB		; do convert AY, FCA1*(AY)
001ABDr 2  A9 FA        	LDA	#$FA			; set number exponent count (-6)
001ABFr 2               LAB_299A
001ABFr 2  85 A8        	STA	numexp		; save number exponent count
001AC1r 2               LAB_299C
001AC1r 2  A9 rr        	LDA	#<LAB_294B		; set pointer low byte to 999999.4375 (max before sci note)
001AC3r 2  A0 rr        	LDY	#>LAB_294B		; set pointer high byte to 999999.4375
001AC5r 2  20 rr rr     	JSR	LAB_27F8		; compare FAC1 with (AY)
001AC8r 2  F0 1E        	BEQ	LAB_29C3		; exit if FAC1 = (AY)
001ACAr 2               
001ACAr 2  10 12        	BPL	LAB_29B9		; go do /10 if FAC1 > (AY)
001ACCr 2               
001ACCr 2               					; FAC1 < (AY)
001ACCr 2               LAB_29A7
001ACCr 2  A9 rr        	LDA	#<LAB_2947		; set pointer low byte to 99999.9375
001ACEr 2  A0 rr        	LDY	#>LAB_2947		; set pointer high byte to 99999.9375
001AD0r 2  20 rr rr     	JSR	LAB_27F8		; compare FAC1 with (AY)
001AD3r 2  F0 02        	BEQ	LAB_29B2		; branch if FAC1 = (AY) (allow decimal places)
001AD5r 2               
001AD5r 2  10 0E        	BPL	LAB_29C0		; branch if FAC1 > (AY) (no decimal places)
001AD7r 2               
001AD7r 2               					; FAC1 <= (AY)
001AD7r 2               LAB_29B2
001AD7r 2  20 rr rr     	JSR	LAB_269E		; multiply by 10
001ADAr 2  C6 A8        	DEC	numexp		; decrement number exponent count
001ADCr 2  D0 EE        	BNE	LAB_29A7		; go test again (branch always)
001ADEr 2               
001ADEr 2               LAB_29B9
001ADEr 2  20 rr rr     	JSR	LAB_26B9		; divide by 10
001AE1r 2  E6 A8        	INC	numexp		; increment number exponent count
001AE3r 2  D0 DC        	BNE	LAB_299C		; go test again (branch always)
001AE5r 2               
001AE5r 2               ; now we have just the digits to do
001AE5r 2               
001AE5r 2               LAB_29C0
001AE5r 2  20 rr rr     	JSR	LAB_244E		; add 0.5 to FAC1 (round FAC1)
001AE8r 2               LAB_29C3
001AE8r 2  20 rr rr     	JSR	LAB_2831		; convert FAC1 floating-to-fixed
001AEBr 2  A2 01        	LDX	#$01			; set default digits before dp = 1
001AEDr 2  A5 A8        	LDA	numexp		; get number exponent count
001AEFr 2  18           	CLC				; clear carry for add
001AF0r 2  69 07        	ADC	#$07			; up to 6 digits before point
001AF2r 2  30 09        	BMI	LAB_29D8		; if -ve then 1 digit before dp
001AF4r 2               
001AF4r 2  C9 08        	CMP	#$08			; A>=8 if n>=1E6
001AF6r 2  B0 06        	BCS	LAB_29D9		; branch if >= $08
001AF8r 2               
001AF8r 2               					; carry is clear
001AF8r 2  69 FF        	ADC	#$FF			; take 1 from digit count
001AFAr 2  AA           	TAX				; copy to A
001AFBr 2  A9 02        	LDA	#$02			;.set exponent adjust
001AFDr 2               LAB_29D8
001AFDr 2  38           	SEC				; set carry for subtract
001AFEr 2               LAB_29D9
001AFEr 2  E9 02        	SBC	#$02			; -2
001B00r 2  85 A9        	STA	expcnt		;.save exponent adjust
001B02r 2  86 A8        	STX	numexp		; save digits before dp count
001B04r 2  8A           	TXA				; copy to A
001B05r 2  F0 02        	BEQ	LAB_29E4		; branch if no digits before dp
001B07r 2               
001B07r 2  10 13        	BPL	LAB_29F7		; branch if digits before dp
001B09r 2               
001B09r 2               LAB_29E4
001B09r 2  A4 BA        	LDY	Sendl			; get output string index
001B0Br 2  A9 2E        	LDA	#$2E			; character "."
001B0Dr 2  C8           	INY				; increment index
001B0Er 2  99 EF 00     	STA	Decss,Y		; save to output string
001B11r 2  8A           	TXA				;.
001B12r 2  F0 06        	BEQ	LAB_29F5		;.
001B14r 2               
001B14r 2  A9 30        	LDA	#'0'			; character "0"
001B16r 2  C8           	INY				; increment index
001B17r 2  99 EF 00     	STA	Decss,Y		; save to output string
001B1Ar 2               LAB_29F5
001B1Ar 2  84 BA        	STY	Sendl			; save output string index
001B1Cr 2               LAB_29F7
001B1Cr 2  A0 00        	LDY	#$00			; clear index (point to 100,000)
001B1Er 2  A2 80        	LDX	#$80			;
001B20r 2               LAB_29FB
001B20r 2  A5 AF        	LDA	FAC1_3		; get FAC1 mantissa3
001B22r 2  18           	CLC				; clear carry for add
001B23r 2  79 rr rr     	ADC	LAB_2A9C,Y		; add -ve LSB
001B26r 2  85 AF        	STA	FAC1_3		; save FAC1 mantissa3
001B28r 2  A5 AE        	LDA	FAC1_2		; get FAC1 mantissa2
001B2Ar 2  79 rr rr     	ADC	LAB_2A9B,Y		; add -ve NMSB
001B2Dr 2  85 AE        	STA	FAC1_2		; save FAC1 mantissa2
001B2Fr 2  A5 AD        	LDA	FAC1_1		; get FAC1 mantissa1
001B31r 2  79 rr rr     	ADC	LAB_2A9A,Y		; add -ve MSB
001B34r 2  85 AD        	STA	FAC1_1		; save FAC1 mantissa1
001B36r 2  E8           	INX				;
001B37r 2  B0 04        	BCS	LAB_2A18		;
001B39r 2               
001B39r 2  10 E5        	BPL	LAB_29FB		; not -ve so try again
001B3Br 2               
001B3Br 2  30 02        	BMI	LAB_2A1A		;
001B3Dr 2               
001B3Dr 2               LAB_2A18
001B3Dr 2  30 E1        	BMI	LAB_29FB		;
001B3Fr 2               
001B3Fr 2               LAB_2A1A
001B3Fr 2  8A           	TXA				;
001B40r 2  90 04        	BCC	LAB_2A21		;
001B42r 2               
001B42r 2  49 FF        	EOR	#$FF			;
001B44r 2  69 0A        	ADC	#$0A			;
001B46r 2               LAB_2A21
001B46r 2  69 2F        	ADC	#'0'-1		; add "0"-1 to result
001B48r 2  C8           	INY				; increment index ..
001B49r 2  C8           	INY				; .. to next less ..
001B4Ar 2  C8           	INY				; .. power of ten
001B4Br 2  84 95        	STY	Cvaral		; save as current var address low byte
001B4Dr 2  A4 BA        	LDY	Sendl			; get output string index
001B4Fr 2  C8           	INY				; increment output string index
001B50r 2  AA           	TAX				; copy character to X
001B51r 2  29 7F        	AND	#$7F			; mask out top bit
001B53r 2  99 EF 00     	STA	Decss,Y		; save to output string
001B56r 2  C6 A8        	DEC	numexp		; decrement # of characters before the dp
001B58r 2  D0 06        	BNE	LAB_2A3B		; branch if still characters to do
001B5Ar 2               
001B5Ar 2               					; else output the point
001B5Ar 2  A9 2E        	LDA	#$2E			; character "."
001B5Cr 2  C8           	INY				; increment output string index
001B5Dr 2  99 EF 00     	STA	Decss,Y		; save to output string
001B60r 2               LAB_2A3B
001B60r 2  84 BA        	STY	Sendl			; save output string index
001B62r 2  A4 95        	LDY	Cvaral		; get current var address low byte
001B64r 2  8A           	TXA				; get character back
001B65r 2  49 FF        	EOR	#$FF			;
001B67r 2  29 80        	AND	#$80			;
001B69r 2  AA           	TAX				;
001B6Ar 2  C0 12        	CPY	#$12			; compare index with max
001B6Cr 2  D0 B2        	BNE	LAB_29FB		; loop if not max
001B6Er 2               
001B6Er 2               					; now remove trailing zeroes
001B6Er 2  A4 BA        	LDY	Sendl			; get output string index
001B70r 2               LAB_2A4B
001B70r 2  B9 EF 00     	LDA	Decss,Y		; get character from output string
001B73r 2  88           	DEY				; decrement output string index
001B74r 2  C9 30        	CMP	#'0'			; compare with "0"
001B76r 2  F0 F8        	BEQ	LAB_2A4B		; loop until non "0" character found
001B78r 2               
001B78r 2  C9 2E        	CMP	#'.'			; compare with "."
001B7Ar 2  F0 01        	BEQ	LAB_2A58		; branch if was dp
001B7Cr 2               
001B7Cr 2               					; restore last character
001B7Cr 2  C8           	INY				; increment output string index
001B7Dr 2               LAB_2A58
001B7Dr 2  A9 2B        	LDA	#$2B			; character "+"
001B7Fr 2  A6 A9        	LDX	expcnt		; get exponent count
001B81r 2  F0 2E        	BEQ	LAB_2A8C		; if zero go set null terminator and exit
001B83r 2               
001B83r 2               					; exponent isn't zero so write exponent
001B83r 2  10 08        	BPL	LAB_2A68		; branch if exponent count +ve
001B85r 2               
001B85r 2  A9 00        	LDA	#$00			; clear A
001B87r 2  38           	SEC				; set carry for subtract
001B88r 2  E5 A9        	SBC	expcnt		; subtract exponent count adjust (convert -ve to +ve)
001B8Ar 2  AA           	TAX				; copy exponent count to X
001B8Br 2  A9 2D        	LDA	#'-'			; character "-"
001B8Dr 2               LAB_2A68
001B8Dr 2  99 F1 00     	STA	Decss+2,Y		; save to output string
001B90r 2  A9 45        	LDA	#$45			; character "E"
001B92r 2  99 F0 00     	STA	Decss+1,Y		; save exponent sign to output string
001B95r 2  8A           	TXA				; get exponent count back
001B96r 2  A2 2F        	LDX	#'0'-1		; one less than "0" character
001B98r 2  38           	SEC				; set carry for subtract
001B99r 2               LAB_2A74
001B99r 2  E8           	INX				; increment 10's character
001B9Ar 2  E9 0A        	SBC	#$0A			;.subtract 10 from exponent count
001B9Cr 2  B0 FB        	BCS	LAB_2A74		; loop while still >= 0
001B9Er 2               
001B9Er 2  69 3A        	ADC	#':'			; add character ":" ($30+$0A, result is 10 less that value)
001BA0r 2  99 F3 00     	STA	Decss+4,Y		; save to output string
001BA3r 2  8A           	TXA				; copy 10's character
001BA4r 2  99 F2 00     	STA	Decss+3,Y		; save to output string
001BA7r 2  A9 00        	LDA	#$00			; set null terminator
001BA9r 2  99 F4 00     	STA	Decss+5,Y		; save to output string
001BACr 2  F0 08        	BEQ	LAB_2A91		; go set string pointer (AY) and exit (branch always)
001BAEr 2               
001BAEr 2               					; save last character, [EOT] and exit
001BAEr 2               LAB_2A89
001BAEr 2  99 EF 00     	STA	Decss,Y		; save last character to output string
001BB1r 2               
001BB1r 2               					; set null terminator and exit
001BB1r 2               LAB_2A8C
001BB1r 2  A9 00        	LDA	#$00			; set null terminator
001BB3r 2  99 F0 00     	STA	Decss+1,Y		; save after last character
001BB6r 2               
001BB6r 2               					; set string pointer (AY) and exit
001BB6r 2               LAB_2A91
001BB6r 2  A9 F0        	LDA	#<Decssp1		; set result string low pointer
001BB8r 2  A0 00        	LDY	#>Decssp1		; set result string high pointer
001BBAr 2  60           	RTS
001BBBr 2               
001BBBr 2               ; perform power function
001BBBr 2               
001BBBr 2               LAB_POWER
001BBBr 2  F0 42        	BEQ	LAB_EXP		; go do  EXP()
001BBDr 2               
001BBDr 2  A5 B3        	LDA	FAC2_e		; get FAC2 exponent
001BBFr 2  D0 03        	BNE	LAB_2ABF		; branch if FAC2<>0
001BC1r 2               
001BC1r 2  4C rr rr     	JMP	LAB_24F3		; clear FAC1 exponent and sign and return
001BC4r 2               
001BC4r 2               LAB_2ABF
001BC4r 2  A2 9C        	LDX	#<func_l		; set destination pointer low byte
001BC6r 2  A0 00        	LDY	#>func_l		; set destination pointer high byte
001BC8r 2  20 rr rr     	JSR	LAB_2778		; pack FAC1 into (XY)
001BCBr 2  A5 B7        	LDA	FAC2_s		; get FAC2 sign (b7)
001BCDr 2  10 0F        	BPL	LAB_2AD9		; branch if FAC2>0
001BCFr 2               
001BCFr 2               					; else FAC2 is -ve and can only be raised to an
001BCFr 2               					; integer power which gives an x +j0 result
001BCFr 2  20 rr rr     	JSR	LAB_INT		; perform INT
001BD2r 2  A9 9C        	LDA	#<func_l		; set source pointer low byte
001BD4r 2  A0 00        	LDY	#>func_l		; set source pointer high byte
001BD6r 2  20 rr rr     	JSR	LAB_27F8		; compare FAC1 with (AY)
001BD9r 2  D0 03        	BNE	LAB_2AD9		; branch if FAC1 <> (AY) to allow Function Call error
001BDBr 2               					; this will leave FAC1 -ve and cause a Function Call
001BDBr 2               					; error when LOG() is called
001BDBr 2               
001BDBr 2  98           	TYA				; clear sign b7
001BDCr 2  A4 5B        	LDY	Temp3			; save mantissa 3 from INT() function as sign in Y
001BDEr 2               					; for possible later negation, b0
001BDEr 2               LAB_2AD9
001BDEr 2  20 rr rr     	JSR	LAB_279D		; save FAC1 sign and copy ABS(FAC2) to FAC1
001BE1r 2  98           	TYA				; copy sign back ..
001BE2r 2  48           	PHA				; .. and save it
001BE3r 2  20 rr rr     	JSR	LAB_LOG		; do LOG(n)
001BE6r 2  A9 9C        	LDA	#<garb_l		; set pointer low byte
001BE8r 2  A0 00        	LDY	#>garb_l		; set pointer high byte
001BEAr 2  20 rr rr     	JSR	LAB_25FB		; do convert AY, FCA1*(AY) (square the value)
001BEDr 2  20 rr rr     	JSR	LAB_EXP		; go do EXP(n)
001BF0r 2  68           	PLA				; pull sign from stack
001BF1r 2  4A           	LSR				; b0 is to be tested, shift to Cb
001BF2r 2  90 0A        	BCC	LAB_2AF9		; if no bit then exit
001BF4r 2               
001BF4r 2               					; Perform negation
001BF4r 2               ; do - FAC1
001BF4r 2               
001BF4r 2               LAB_GTHAN
001BF4r 2  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
001BF6r 2  F0 06        	BEQ	LAB_2AF9		; exit if FAC1_e = $00
001BF8r 2               
001BF8r 2  A5 B0        	LDA	FAC1_s		; get FAC1 sign (b7)
001BFAr 2  49 FF        	EOR	#$FF			; complement it
001BFCr 2  85 B0        	STA	FAC1_s		; save FAC1 sign (b7)
001BFEr 2               LAB_2AF9
001BFEr 2  60           	RTS
001BFFr 2               
001BFFr 2               ; perform EXP()	(x^e)
001BFFr 2               
001BFFr 2               LAB_EXP
001BFFr 2  A9 rr        	LDA	#<LAB_2AFA		; set 1.443 pointer low byte
001C01r 2  A0 rr        	LDY	#>LAB_2AFA		; set 1.443 pointer high byte
001C03r 2  20 rr rr     	JSR	LAB_25FB		; do convert AY, FCA1*(AY)
001C06r 2  A5 B9        	LDA	FAC1_r		; get FAC1 rounding byte
001C08r 2  69 50        	ADC	#$50			; +$50/$100
001C0Ar 2  90 03        	BCC	LAB_2B2B		; skip rounding if no carry
001C0Cr 2               
001C0Cr 2  20 rr rr     	JSR	LAB_27C2		; round FAC1 (no check)
001C0Fr 2               LAB_2B2B
001C0Fr 2  85 A3        	STA	FAC2_r		; save FAC2 rounding byte
001C11r 2  20 rr rr     	JSR	LAB_27AE		; copy FAC1 to FAC2
001C14r 2  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
001C16r 2  C9 88        	CMP	#$88			; compare with EXP limit (256d)
001C18r 2  90 03        	BCC	LAB_2B39		; branch if less
001C1Ar 2               
001C1Ar 2               LAB_2B36
001C1Ar 2  20 rr rr     	JSR	LAB_2690		; handle overflow and underflow
001C1Dr 2               LAB_2B39
001C1Dr 2  20 rr rr     	JSR	LAB_INT		; perform INT
001C20r 2  A5 5B        	LDA	Temp3			; get mantissa 3 from INT() function
001C22r 2  18           	CLC				; clear carry for add
001C23r 2  69 81        	ADC	#$81			; normalise +1
001C25r 2  F0 F3        	BEQ	LAB_2B36		; if $00 go handle overflow
001C27r 2               
001C27r 2  38           	SEC				; set carry for subtract
001C28r 2  E9 01        	SBC	#$01			; now correct for exponent
001C2Ar 2  48           	PHA				; save FAC2 exponent
001C2Br 2               
001C2Br 2               					; swap FAC1 and FAC2
001C2Br 2  A2 04        	LDX	#$04			; 4 bytes to do
001C2Dr 2               LAB_2B49
001C2Dr 2  B5 B3        	LDA	FAC2_e,X		; get FAC2,X
001C2Fr 2  B4 AC        	LDY	FAC1_e,X		; get FAC1,X
001C31r 2  95 AC        	STA	FAC1_e,X		; save FAC1,X
001C33r 2  94 B3        	STY	FAC2_e,X		; save FAC2,X
001C35r 2  CA           	DEX				; decrement count/index
001C36r 2  10 F5        	BPL	LAB_2B49		; loop if not all done
001C38r 2               
001C38r 2  A5 A3        	LDA	FAC2_r		; get FAC2 rounding byte
001C3Ar 2  85 B9        	STA	FAC1_r		; save as FAC1 rounding byte
001C3Cr 2  20 rr rr     	JSR	LAB_SUBTRACT	; perform subtraction, FAC2 from FAC1
001C3Fr 2  20 rr rr     	JSR	LAB_GTHAN		; do - FAC1
001C42r 2  A9 rr        	LDA	#<LAB_2AFE		; set counter pointer low byte
001C44r 2  A0 rr        	LDY	#>LAB_2AFE		; set counter pointer high byte
001C46r 2  20 rr rr     	JSR	LAB_2B84		; go do series evaluation
001C49r 2  A9 00        	LDA	#$00			; clear A
001C4Br 2  85 B8        	STA	FAC_sc		; clear sign compare (FAC1 EOR FAC2)
001C4Dr 2  68           	PLA				;.get saved FAC2 exponent
001C4Er 2  4C rr rr     	JMP	LAB_2675		; test and adjust accumulators and return
001C51r 2               
001C51r 2               ; ^2 then series evaluation
001C51r 2               
001C51r 2               LAB_2B6E
001C51r 2  85 BA        	STA	Cptrl			; save count pointer low byte
001C53r 2  84 BB        	STY	Cptrh			; save count pointer high byte
001C55r 2  20 rr rr     	JSR	LAB_276E		; pack FAC1 into Adatal
001C58r 2  A9 A4        	LDA	#<Adatal		; set pointer low byte (Y already $00)
001C5Ar 2  20 rr rr     	JSR	LAB_25FB		; do convert AY, FCA1*(AY)
001C5Dr 2  20 rr rr     	JSR	LAB_2B88		; go do series evaluation
001C60r 2  A9 A4        	LDA	#<Adatal		; pointer to original # low byte
001C62r 2  A0 00        	LDY	#>Adatal		; pointer to original # high byte
001C64r 2  4C rr rr     	JMP	LAB_25FB		; do convert AY, FCA1*(AY) and return
001C67r 2               
001C67r 2               ; series evaluation
001C67r 2               
001C67r 2               LAB_2B84
001C67r 2  85 BA        	STA	Cptrl			; save count pointer low byte
001C69r 2  84 BB        	STY	Cptrh			; save count pointer high byte
001C6Br 2               LAB_2B88
001C6Br 2  A2 A8        	LDX	#<numexp		; set pointer low byte
001C6Dr 2  20 rr rr     	JSR	LAB_2770		; set pointer high byte and pack FAC1 into numexp
001C70r 2  B1 BA        	LDA	(Cptrl),Y		; get constants count
001C72r 2  85 B1        	STA	numcon		; save constants count
001C74r 2  A4 BA        	LDY	Cptrl			; get count pointer low byte
001C76r 2  C8           	INY				; increment it (now constants pointer)
001C77r 2  98           	TYA				; copy it
001C78r 2  D0 02        	BNE	LAB_2B97		; skip next if no overflow
001C7Ar 2               
001C7Ar 2  E6 BB        	INC	Cptrh			; else increment high byte
001C7Cr 2               LAB_2B97
001C7Cr 2  85 BA        	STA	Cptrl			; save low byte
001C7Er 2  A4 BB        	LDY	Cptrh			; get high byte
001C80r 2               LAB_2B9B
001C80r 2  20 rr rr     	JSR	LAB_25FB		; do convert AY, FCA1*(AY)
001C83r 2  A5 BA        	LDA	Cptrl			; get constants pointer low byte
001C85r 2  A4 BB        	LDY	Cptrh			; get constants pointer high byte
001C87r 2  18           	CLC				; clear carry for add
001C88r 2  69 04        	ADC	#$04			; +4 to  low pointer (4 bytes per constant)
001C8Ar 2  90 01        	BCC	LAB_2BA8		; skip next if no overflow
001C8Cr 2               
001C8Cr 2  C8           	INY				; increment high byte
001C8Dr 2               LAB_2BA8
001C8Dr 2  85 BA        	STA	Cptrl			; save pointer low byte
001C8Fr 2  84 BB        	STY	Cptrh			; save pointer high byte
001C91r 2  20 rr rr     	JSR	LAB_246C		; add (AY) to FAC1
001C94r 2  A9 A8        	LDA	#<numexp		; set pointer low byte to partial @ numexp
001C96r 2  A0 00        	LDY	#>numexp		; set pointer high byte to partial @ numexp
001C98r 2  C6 B1        	DEC	numcon		; decrement constants count
001C9Ar 2  D0 E4        	BNE	LAB_2B9B		; loop until all done
001C9Cr 2               
001C9Cr 2  60           	RTS
001C9Dr 2               
001C9Dr 2               ; RND(n), 32 bit Galoise version. make n=0 for 19th next number in sequence or n<>0
001C9Dr 2               ; to get 19th next number in sequence after seed n. This version of the PRNG uses
001C9Dr 2               ; the Galois method and a sample of 65536 bytes produced gives the following values.
001C9Dr 2               
001C9Dr 2               ; Entropy = 7.997442 bits per byte
001C9Dr 2               ; Optimum compression would reduce these 65536 bytes by 0 percent
001C9Dr 2               
001C9Dr 2               ; Chi square distribution for 65536 samples is 232.01, and
001C9Dr 2               ; randomly would exceed this value 75.00 percent of the time
001C9Dr 2               
001C9Dr 2               ; Arithmetic mean value of data bytes is 127.6724, 127.5 would be random
001C9Dr 2               ; Monte Carlo value for Pi is 3.122871269, error 0.60 percent
001C9Dr 2               ; Serial correlation coefficient is -0.000370, totally uncorrelated would be 0.0
001C9Dr 2               
001C9Dr 2               LAB_RND
001C9Dr 2  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
001C9Fr 2  F0 07        	BEQ	NextPRN		; do next random # if zero
001CA1r 2               
001CA1r 2               					; else get seed into random number store
001CA1r 2  A2 D8        	LDX	#Rbyte4		; set PRNG pointer low byte
001CA3r 2  A0 00        	LDY	#$00			; set PRNG pointer high byte
001CA5r 2  20 rr rr     	JSR	LAB_2778		; pack FAC1 into (XY)
001CA8r 2               NextPRN
001CA8r 2  A2 AF        	LDX	#$AF			; set EOR byte
001CAAr 2  A0 13        	LDY	#$13			; do this nineteen times
001CACr 2               LoopPRN
001CACr 2  06 D9        	ASL	Rbyte1		; shift PRNG most significant byte
001CAEr 2  26 DA        	ROL	Rbyte2		; shift PRNG middle byte
001CB0r 2  26 DB        	ROL	Rbyte3		; shift PRNG least significant byte
001CB2r 2  26 D8        	ROL	Rbyte4		; shift PRNG extra byte
001CB4r 2  90 05        	BCC	Ninc1			; branch if bit 32 clear
001CB6r 2               
001CB6r 2  8A           	TXA				; set EOR byte
001CB7r 2  45 D9        	EOR	Rbyte1		; EOR PRNG extra byte
001CB9r 2  85 D9        	STA	Rbyte1		; save new PRNG extra byte
001CBBr 2               Ninc1
001CBBr 2  88           	DEY				; decrement loop count
001CBCr 2  D0 EE        	BNE	LoopPRN		; loop if not all done
001CBEr 2               
001CBEr 2  A2 02        	LDX	#$02			; three bytes to copy
001CC0r 2               CopyPRNG
001CC0r 2  B5 D9        	LDA	Rbyte1,X		; get PRNG byte
001CC2r 2  95 AD        	STA	FAC1_1,X		; save FAC1 byte
001CC4r 2  CA           	DEX
001CC5r 2  10 F9        	BPL	CopyPRNG		; loop if not complete
001CC7r 2               
001CC7r 2  A9 80        	LDA	#$80			; set the exponent
001CC9r 2  85 AC        	STA	FAC1_e		; save FAC1 exponent
001CCBr 2               
001CCBr 2  0A           	ASL				; clear A
001CCCr 2  85 B0        	STA	FAC1_s		; save FAC1 sign
001CCEr 2               
001CCEr 2  4C rr rr     	JMP	LAB_24D5		; normalise FAC1 and return
001CD1r 2               
001CD1r 2               ; perform COS()
001CD1r 2               
001CD1r 2               LAB_COS
001CD1r 2  A9 rr        	LDA	#<LAB_2C78		; set (pi/2) pointer low byte
001CD3r 2  A0 rr        	LDY	#>LAB_2C78		; set (pi/2) pointer high byte
001CD5r 2  20 rr rr     	JSR	LAB_246C		; add (AY) to FAC1
001CD8r 2               
001CD8r 2               ; perform SIN()
001CD8r 2               
001CD8r 2               LAB_SIN
001CD8r 2  20 rr rr     	JSR	LAB_27AB		; round and copy FAC1 to FAC2
001CDBr 2  A9 rr        	LDA	#<LAB_2C7C		; set (2*pi) pointer low byte
001CDDr 2  A0 rr        	LDY	#>LAB_2C7C		; set (2*pi) pointer high byte
001CDFr 2  A6 B7        	LDX	FAC2_s		; get FAC2 sign (b7)
001CE1r 2  20 rr rr     	JSR	LAB_26C2		; divide by (AY) (X=sign)
001CE4r 2  20 rr rr     	JSR	LAB_27AB		; round and copy FAC1 to FAC2
001CE7r 2  20 rr rr     	JSR	LAB_INT		; perform INT
001CEAr 2  A9 00        	LDA	#$00			; clear byte
001CECr 2  85 B8        	STA	FAC_sc		; clear sign compare (FAC1 EOR FAC2)
001CEEr 2  20 rr rr     	JSR	LAB_SUBTRACT	; perform subtraction, FAC2 from FAC1
001CF1r 2  A9 rr        	LDA	#<LAB_2C80		; set 0.25 pointer low byte
001CF3r 2  A0 rr        	LDY	#>LAB_2C80		; set 0.25 pointer high byte
001CF5r 2  20 rr rr     	JSR	LAB_2455		; perform subtraction, (AY) from FAC1
001CF8r 2  A5 B0        	LDA	FAC1_s		; get FAC1 sign (b7)
001CFAr 2  48           	PHA				; save FAC1 sign
001CFBr 2  10 0D        	BPL	LAB_2C35		; branch if +ve
001CFDr 2               
001CFDr 2               					; FAC1 sign was -ve
001CFDr 2  20 rr rr     	JSR	LAB_244E		; add 0.5 to FAC1
001D00r 2  A5 B0        	LDA	FAC1_s		; get FAC1 sign (b7)
001D02r 2  30 09        	BMI	LAB_2C38		; branch if -ve
001D04r 2               
001D04r 2  A5 63        	LDA	Cflag			; get comparison evaluation flag
001D06r 2  49 FF        	EOR	#$FF			; toggle flag
001D08r 2  85 63        	STA	Cflag			; save comparison evaluation flag
001D0Ar 2               LAB_2C35
001D0Ar 2  20 rr rr     	JSR	LAB_GTHAN		; do - FAC1
001D0Dr 2               LAB_2C38
001D0Dr 2  A9 rr        	LDA	#<LAB_2C80		; set 0.25 pointer low byte
001D0Fr 2  A0 rr        	LDY	#>LAB_2C80		; set 0.25 pointer high byte
001D11r 2  20 rr rr     	JSR	LAB_246C		; add (AY) to FAC1
001D14r 2  68           	PLA				; restore FAC1 sign
001D15r 2  10 03        	BPL	LAB_2C45		; branch if was +ve
001D17r 2               
001D17r 2               					; else correct FAC1
001D17r 2  20 rr rr     	JSR	LAB_GTHAN		; do - FAC1
001D1Ar 2               LAB_2C45
001D1Ar 2  A9 rr        	LDA	#<LAB_2C84		; set pointer low byte to counter
001D1Cr 2  A0 rr        	LDY	#>LAB_2C84		; set pointer high byte to counter
001D1Er 2  4C rr rr     	JMP	LAB_2B6E		; ^2 then series evaluation and return
001D21r 2               
001D21r 2               ; perform TAN()
001D21r 2               
001D21r 2               LAB_TAN
001D21r 2  20 rr rr     	JSR	LAB_276E		; pack FAC1 into Adatal
001D24r 2  A9 00        	LDA	#$00			; clear byte
001D26r 2  85 63        	STA	Cflag			; clear comparison evaluation flag
001D28r 2  20 rr rr     	JSR	LAB_SIN		; go do SIN(n)
001D2Br 2  A2 9C        	LDX	#<func_l		; set sin(n) pointer low byte
001D2Dr 2  A0 00        	LDY	#>func_l		; set sin(n) pointer high byte
001D2Fr 2  20 rr rr     	JSR	LAB_2778		; pack FAC1 into (XY)
001D32r 2  A9 A4        	LDA	#<Adatal		; set n pointer low addr
001D34r 2  A0 00        	LDY	#>Adatal		; set n pointer high addr
001D36r 2  20 rr rr     	JSR	LAB_UFAC		; unpack memory (AY) into FAC1
001D39r 2  A9 00        	LDA	#$00			; clear byte
001D3Br 2  85 B0        	STA	FAC1_s		; clear FAC1 sign (b7)
001D3Dr 2  A5 63        	LDA	Cflag			; get comparison evaluation flag
001D3Fr 2  20 rr rr     	JSR	LAB_2C74		; save flag and go do series evaluation
001D42r 2               
001D42r 2  A9 9C        	LDA	#<func_l		; set sin(n) pointer low byte
001D44r 2  A0 00        	LDY	#>func_l		; set sin(n) pointer high byte
001D46r 2  4C rr rr     	JMP	LAB_26CA		; convert AY and do (AY)/FAC1
001D49r 2               
001D49r 2               LAB_2C74
001D49r 2  48           	PHA				; save comparison evaluation flag
001D4Ar 2  4C rr rr     	JMP	LAB_2C35		; go do series evaluation
001D4Dr 2               
001D4Dr 2               ; perform USR()
001D4Dr 2               
001D4Dr 2               LAB_USR
001D4Dr 2  20 0A 00     	JSR	Usrjmp		; call user code
001D50r 2  4C rr rr     	JMP	LAB_1BFB		; scan for ")", else do syntax error then warm start
001D53r 2               
001D53r 2               ; perform ATN()
001D53r 2               
001D53r 2               LAB_ATN
001D53r 2  A5 B0        	LDA	FAC1_s		; get FAC1 sign (b7)
001D55r 2  48           	PHA				; save sign
001D56r 2  10 03        	BPL	LAB_2CA1		; branch if +ve
001D58r 2               
001D58r 2  20 rr rr     	JSR	LAB_GTHAN		; else do - FAC1
001D5Br 2               LAB_2CA1
001D5Br 2  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
001D5Dr 2  48           	PHA				; push exponent
001D5Er 2  C9 81        	CMP	#$81			; compare with 1
001D60r 2  90 07        	BCC	LAB_2CAF		; branch if FAC1<1
001D62r 2               
001D62r 2  A9 rr        	LDA	#<LAB_259C		; set 1 pointer low byte
001D64r 2  A0 rr        	LDY	#>LAB_259C		; set 1 pointer high byte
001D66r 2  20 rr rr     	JSR	LAB_26CA		; convert AY and do (AY)/FAC1
001D69r 2               LAB_2CAF
001D69r 2  A9 rr        	LDA	#<LAB_2CC9		; set pointer low byte to counter
001D6Br 2  A0 rr        	LDY	#>LAB_2CC9		; set pointer high byte to counter
001D6Dr 2  20 rr rr     	JSR	LAB_2B6E		; ^2 then series evaluation
001D70r 2  68           	PLA				; restore old FAC1 exponent
001D71r 2  C9 81        	CMP	#$81			; compare with 1
001D73r 2  90 07        	BCC	LAB_2CC2		; branch if FAC1<1
001D75r 2               
001D75r 2  A9 rr        	LDA	#<LAB_2C78		; set (pi/2) pointer low byte
001D77r 2  A0 rr        	LDY	#>LAB_2C78		; set (pi/2) pointer high byte
001D79r 2  20 rr rr     	JSR	LAB_2455		; perform subtraction, (AY) from FAC1
001D7Cr 2               LAB_2CC2
001D7Cr 2  68           	PLA				; restore FAC1 sign
001D7Dr 2  10 16        	BPL	LAB_2D04		; exit if was +ve
001D7Fr 2               
001D7Fr 2  4C rr rr     	JMP	LAB_GTHAN		; else do - FAC1 and return
001D82r 2               
001D82r 2               ; perform BITSET
001D82r 2               
001D82r 2               LAB_BITSET
001D82r 2  20 rr rr     	JSR	LAB_GADB		; get two parameters for POKE or WAIT
001D85r 2  E0 08        	CPX	#$08			; only 0 to 7 are allowed
001D87r 2  B0 20        	BCS	FCError		; branch if > 7
001D89r 2               
001D89r 2  A9 00        	LDA	#$00			; clear A
001D8Br 2  38           	SEC				; set the carry
001D8Cr 2               S_Bits
001D8Cr 2  2A           	ROL				; shift bit
001D8Dr 2  CA           	DEX				; decrement bit number
001D8Er 2  10 FC        	BPL	S_Bits		; loop if still +ve
001D90r 2               
001D90r 2  E8           	INX				; make X = $00
001D91r 2  01 11        	ORA	(Itempl,X)		; or with byte via temporary integer (addr)
001D93r 2  81 11        	STA	(Itempl,X)		; save byte via temporary integer (addr)
001D95r 2               LAB_2D04
001D95r 2  60           	RTS
001D96r 2               
001D96r 2               ; perform BITCLR
001D96r 2               
001D96r 2               LAB_BITCLR
001D96r 2  20 rr rr     	JSR	LAB_GADB		; get two parameters for POKE or WAIT
001D99r 2  E0 08        	CPX	#$08			; only 0 to 7 are allowed
001D9Br 2  B0 0C        	BCS	FCError		; branch if > 7
001D9Dr 2               
001D9Dr 2  A9 FF        	LDA	#$FF			; set A
001D9Fr 2               S_Bitc
001D9Fr 2  2A           	ROL				; shift bit
001DA0r 2  CA           	DEX				; decrement bit number
001DA1r 2  10 FC        	BPL	S_Bitc		; loop if still +ve
001DA3r 2               
001DA3r 2  E8           	INX				; make X = $00
001DA4r 2  21 11        	AND	(Itempl,X)		; and with byte via temporary integer (addr)
001DA6r 2  81 11        	STA	(Itempl,X)		; save byte via temporary integer (addr)
001DA8r 2  60           	RTS
001DA9r 2               
001DA9r 2               FCError
001DA9r 2  4C rr rr     	JMP	LAB_FCER		; do function call error then warm start
001DACr 2               
001DACr 2               ; perform BITTST()
001DACr 2               
001DACr 2               LAB_BTST
001DACr 2  20 BC 00     	JSR	LAB_IGBY		; increment BASIC pointer
001DAFr 2  20 rr rr     	JSR	LAB_GADB		; get two parameters for POKE or WAIT
001DB2r 2  E0 08        	CPX	#$08			; only 0 to 7 are allowed
001DB4r 2  B0 F3        	BCS	FCError		; branch if > 7
001DB6r 2               
001DB6r 2  20 C2 00     	JSR	LAB_GBYT		; get next BASIC byte
001DB9r 2  C9 29        	CMP	#')'			; is next character ")"
001DBBr 2  F0 03        	BEQ	TST_OK		; if ")" go do rest of function
001DBDr 2               
001DBDr 2  4C rr rr     	JMP	LAB_SNER		; do syntax error then warm start
001DC0r 2               
001DC0r 2               TST_OK
001DC0r 2  20 BC 00     	JSR	LAB_IGBY		; update BASIC execute pointer (to character past ")")
001DC3r 2  A9 00        	LDA	#$00			; clear A
001DC5r 2  38           	SEC				; set the carry
001DC6r 2               T_Bits
001DC6r 2  2A           	ROL				; shift bit
001DC7r 2  CA           	DEX				; decrement bit number
001DC8r 2  10 FC        	BPL	T_Bits		; loop if still +ve
001DCAr 2               
001DCAr 2  E8           	INX				; make X = $00
001DCBr 2  21 11        	AND	(Itempl,X)		; AND with byte via temporary integer (addr)
001DCDr 2  F0 02        	BEQ	LAB_NOTT		; branch if zero (already correct)
001DCFr 2               
001DCFr 2  A9 FF        	LDA	#$FF			; set for -1 result
001DD1r 2               LAB_NOTT
001DD1r 2  4C rr rr     	JMP	LAB_27DB		; go do SGN tail
001DD4r 2               
001DD4r 2               ; perform BIN$()
001DD4r 2               
001DD4r 2               LAB_BINS
001DD4r 2  E0 19        	CPX	#$19			; max + 1
001DD6r 2  B0 48        	BCS	BinFErr		; exit if too big ( > or = )
001DD8r 2               
001DD8r 2  86 78        	STX	TempB			; save # of characters ($00 = leading zero remove)
001DDAr 2  A9 18        	LDA	#$18			; need A byte long space
001DDCr 2  20 rr rr     	JSR	LAB_MSSP		; make string space A bytes long
001DDFr 2  A0 17        	LDY	#$17			; set index
001DE1r 2  A2 18        	LDX	#$18			; character count
001DE3r 2               NextB1
001DE3r 2  46 11        	LSR	nums_1		; shift highest byte
001DE5r 2  66 12        	ROR	nums_2		; shift middle byte
001DE7r 2  66 13        	ROR	nums_3		; shift lowest byte bit 0 to carry
001DE9r 2  8A           	TXA				; load with "0"/2
001DEAr 2  2A           	ROL				; shift in carry
001DEBr 2  91 AD        	STA	(str_pl),Y		; save to temp string + index
001DEDr 2  88           	DEY				; decrement index
001DEEr 2  10 F3        	BPL	NextB1		; loop if not done
001DF0r 2               
001DF0r 2  A5 78        	LDA	TempB			; get # of characters
001DF2r 2  F0 0A        	BEQ	EndBHS		; branch if truncate
001DF4r 2               
001DF4r 2  AA           	TAX				; copy length to X
001DF5r 2  38           	SEC				; set carry for add !
001DF6r 2  49 FF        	EOR	#$FF			; 1's complement
001DF8r 2  69 18        	ADC	#$18			; add 24d
001DFAr 2  F0 1C        	BEQ	GoPr2			; if zero print whole string
001DFCr 2               
001DFCr 2  D0 0F        	BNE	GoPr1			; else go make output string
001DFEr 2               
001DFEr 2               ; this is the exit code and is also used by HEX$()
001DFEr 2               ; truncate string to remove leading "0"s
001DFEr 2               
001DFEr 2               EndBHS
001DFEr 2  A8           	TAY				; clear index (A=0, X=length here)
001DFFr 2               NextB2
001DFFr 2  B1 AD        	LDA	(str_pl),Y		; get character from string
001E01r 2  C9 30        	CMP	#'0'			; compare with "0"
001E03r 2  D0 07        	BNE	GoPr			; if not "0" then go print string from here
001E05r 2               
001E05r 2  CA           	DEX				; decrement character count
001E06r 2  F0 03        	BEQ	GoPr3			; if zero then end of string so go print it
001E08r 2               
001E08r 2  C8           	INY				; else increment index
001E09r 2  10 F4        	BPL	NextB2		; loop always
001E0Br 2               
001E0Br 2               ; make fixed length output string - ignore overflows!
001E0Br 2               
001E0Br 2               GoPr3
001E0Br 2  E8           	INX				; need at least 1 character
001E0Cr 2               GoPr
001E0Cr 2  98           	TYA				; copy result
001E0Dr 2               GoPr1
001E0Dr 2  18           	CLC				; clear carry for add
001E0Er 2  65 AD        	ADC	str_pl		; add low address
001E10r 2  85 AD        	STA	str_pl		; save low address
001E12r 2  A9 00        	LDA	#$00			; do high byte
001E14r 2  65 AE        	ADC	str_ph		; add high address
001E16r 2  85 AE        	STA	str_ph		; save high address
001E18r 2               GoPr2
001E18r 2  86 AC        	STX	str_ln		; X holds string length
001E1Ar 2  20 BC 00     	JSR	LAB_IGBY		; update BASIC execute pointer (to character past ")")
001E1Dr 2  4C rr rr     	JMP	LAB_RTST		; check for space on descriptor stack then put address
001E20r 2               					; and length on descriptor stack and update stack pointers
001E20r 2               
001E20r 2               BinFErr
001E20r 2  4C rr rr     	JMP	LAB_FCER		; do function call error then warm start
001E23r 2               
001E23r 2               ; perform HEX$()
001E23r 2               
001E23r 2               LAB_HEXS
001E23r 2  E0 07        	CPX	#$07			; max + 1
001E25r 2  B0 F9        	BCS	BinFErr		; exit if too big ( > or = )
001E27r 2               
001E27r 2  86 78        	STX	TempB			; save # of characters
001E29r 2               
001E29r 2  A9 06        	LDA	#$06			; need 6 bytes for string
001E2Br 2  20 rr rr     	JSR	LAB_MSSP		; make string space A bytes long
001E2Er 2  A0 05        	LDY	#$05			; set string index
001E30r 2               
001E30r 2  F8           	SED				; need decimal mode for nibble convert
001E31r 2  A5 13        	LDA	nums_3		; get lowest byte
001E33r 2  20 rr rr     	JSR	LAB_A2HX		; convert A to ASCII hex byte and output
001E36r 2  A5 12        	LDA	nums_2		; get middle byte
001E38r 2  20 rr rr     	JSR	LAB_A2HX		; convert A to ASCII hex byte and output
001E3Br 2  A5 11        	LDA	nums_1		; get highest byte
001E3Dr 2  20 rr rr     	JSR	LAB_A2HX		; convert A to ASCII hex byte and output
001E40r 2  D8           	CLD				; back to binary
001E41r 2               
001E41r 2  A2 06        	LDX	#$06			; character count
001E43r 2  A5 78        	LDA	TempB			; get # of characters
001E45r 2  F0 B7        	BEQ	EndBHS		; branch if truncate
001E47r 2               
001E47r 2  AA           	TAX				; copy length to X
001E48r 2  38           	SEC				; set carry for add !
001E49r 2  49 FF        	EOR	#$FF			; 1's complement
001E4Br 2  69 06        	ADC	#$06			; add 6d
001E4Dr 2  F0 C9        	BEQ	GoPr2			; if zero print whole string
001E4Fr 2               
001E4Fr 2  D0 BC        	BNE	GoPr1			; else go make output string (branch always)
001E51r 2               
001E51r 2               ; convert A to ASCII hex byte and output .. note set decimal mode before calling
001E51r 2               
001E51r 2               LAB_A2HX
001E51r 2  AA           	TAX				; save byte
001E52r 2  29 0F        	AND	#$0F			; mask off top bits
001E54r 2  20 rr rr     	JSR	LAB_AL2X		; convert low nibble to ASCII and output
001E57r 2  8A           	TXA				; get byte back
001E58r 2  4A           	LSR				; /2	shift high nibble to low nibble
001E59r 2  4A           	LSR				; /4
001E5Ar 2  4A           	LSR				; /8
001E5Br 2  4A           	LSR				; /16
001E5Cr 2               LAB_AL2X
001E5Cr 2  C9 0A        	CMP	#$0A			; set carry for +1 if >9
001E5Er 2  69 30        	ADC	#'0'			; add ASCII "0"
001E60r 2  91 AD        	STA	(str_pl),Y		; save to temp string
001E62r 2  88           	DEY				; decrement counter
001E63r 2  60           	RTS
001E64r 2               
001E64r 2               LAB_NLTO
001E64r 2  85 AC        	STA	FAC1_e		; save FAC1 exponent
001E66r 2  A9 00        	LDA	#$00			; clear sign compare
001E68r 2               LAB_MLTE
001E68r 2  85 B8        	STA	FAC_sc		; save sign compare (FAC1 EOR FAC2)
001E6Ar 2  8A           	TXA				; restore character
001E6Br 2  20 rr rr     	JSR	LAB_2912		; evaluate new ASCII digit
001E6Er 2               
001E6Er 2               ; gets here if the first character was "$" for hex
001E6Er 2               ; get hex number
001E6Er 2               
001E6Er 2               LAB_CHEX
001E6Er 2  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
001E71r 2  90 0A        	BCC	LAB_ISHN		; branch if numeric character
001E73r 2               
001E73r 2  09 20        	ORA	#$20			; case convert, allow "A" to "F" and "a" to "f"
001E75r 2  E9 61        	SBC	#'a'			; subtract "a" (carry set here)
001E77r 2  C9 06        	CMP	#$06			; compare normalised with $06 (max+1)
001E79r 2  B0 2A        	BCS	LAB_EXCH		; exit if >"f" or <"0"
001E7Br 2               
001E7Br 2  69 0A        	ADC	#$0A			; convert to nibble
001E7Dr 2               LAB_ISHN
001E7Dr 2  29 0F        	AND	#$0F			; convert to binary
001E7Fr 2  AA           	TAX				; save nibble
001E80r 2  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
001E82r 2  F0 E4        	BEQ	LAB_MLTE		; skip multiply if zero
001E84r 2               
001E84r 2  69 04        	ADC	#$04			; add four to exponent (*16 - carry clear here)
001E86r 2  90 DC        	BCC	LAB_NLTO		; if no overflow do evaluate digit
001E88r 2               
001E88r 2               LAB_MLTO
001E88r 2  4C rr rr     	JMP	LAB_2564		; do overflow error and warm start
001E8Br 2               
001E8Br 2               LAB_NXCH
001E8Br 2  AA           	TAX				; save bit
001E8Cr 2  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
001E8Er 2  F0 06        	BEQ	LAB_MLBT		; skip multiply if zero
001E90r 2               
001E90r 2  E6 AC        	INC	FAC1_e		; increment FAC1 exponent (*2)
001E92r 2  F0 F4        	BEQ	LAB_MLTO		; do overflow error if = $00
001E94r 2               
001E94r 2  A9 00        	LDA	#$00			; clear sign compare
001E96r 2               LAB_MLBT
001E96r 2  85 B8        	STA	FAC_sc		; save sign compare (FAC1 EOR FAC2)
001E98r 2  8A           	TXA				; restore bit
001E99r 2  20 rr rr     	JSR	LAB_2912		; evaluate new ASCII digit
001E9Cr 2               
001E9Cr 2               ; gets here if the first character was  "%" for binary
001E9Cr 2               ; get binary number
001E9Cr 2               
001E9Cr 2               LAB_CBIN
001E9Cr 2  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
001E9Fr 2  49 30        	EOR	#'0'			; convert "0" to 0 etc.
001EA1r 2  C9 02        	CMP	#$02			; compare with max+1
001EA3r 2  90 E6        	BCC	LAB_NXCH		; branch exit if < 2
001EA5r 2               
001EA5r 2               LAB_EXCH
001EA5r 2  4C rr rr     	JMP	LAB_28F6		; evaluate -ve flag and return
001EA8r 2               
001EA8r 2               ; ctrl-c check routine. includes limited "life" byte save for INGET routine
001EA8r 2               ; now also the code that checks to see if an interrupt has occurred
001EA8r 2               
001EA8r 2               CTRLC
001EA8r 2  AD 00 02     	LDA	ccflag		; get [CTRL-C] check flag
001EABr 2  D0 18        	BNE	LAB_FBA2		; exit if inhibited
001EADr 2               
001EADr 2  20 rr rr     	JSR	V_INPT		; scan input device
001EB0r 2  90 0B        	BCC	LAB_FBA0		; exit if buffer empty
001EB2r 2               
001EB2r 2  8D 01 02     	STA	ccbyte		; save received byte
001EB5r 2  A2 20        	LDX	#$20			; "life" timer for bytes
001EB7r 2  8E 02 02     	STX	ccnull		; set countdown
001EBAr 2  4C rr rr     	JMP	LAB_1636		; return to BASIC
001EBDr 2               
001EBDr 2               LAB_FBA0
001EBDr 2  AE 02 02     	LDX	ccnull		; get countdown byte
001EC0r 2  F0 03        	BEQ	LAB_FBA2		; exit if finished
001EC2r 2               
001EC2r 2  CE 02 02     	DEC	ccnull		; else decrement countdown
001EC5r 2               LAB_FBA2
001EC5r 2  A2 DC        	LDX	#NmiBase		; set pointer to NMI values
001EC7r 2  20 rr rr     	JSR	LAB_CKIN		; go check interrupt
001ECAr 2  A2 DF        	LDX	#IrqBase		; set pointer to IRQ values
001ECCr 2  20 rr rr     	JSR	LAB_CKIN		; go check interrupt
001ECFr 2               LAB_CRTS
001ECFr 2  60           	RTS
001ED0r 2               
001ED0r 2               ; check whichever interrupt is indexed by X
001ED0r 2               
001ED0r 2               LAB_CKIN
001ED0r 2  B5 00        	LDA	PLUS_0,X		; get interrupt flag byte
001ED2r 2  10 FB        	BPL	LAB_CRTS		; branch if interrupt not enabled
001ED4r 2               
001ED4r 2               ; we disable the interrupt here and make two new commands RETIRQ and RETNMI to
001ED4r 2               ; automatically enable the interrupt when we exit
001ED4r 2               
001ED4r 2  0A           	ASL				; move happened bit to setup bit
001ED5r 2  29 40        	AND	#$40			; mask happened bits
001ED7r 2  F0 F6        	BEQ	LAB_CRTS		; if no interrupt then exit
001ED9r 2               
001ED9r 2  95 00        	STA	PLUS_0,X		; save interrupt flag byte
001EDBr 2               
001EDBr 2  8A           	TXA				; copy index ..
001EDCr 2  A8           	TAY				; .. to Y
001EDDr 2               
001EDDr 2  68           	PLA				; dump return address low byte, call from CTRL-C
001EDEr 2  68           	PLA				; dump return address high byte
001EDFr 2               
001EDFr 2  A9 05        	LDA	#$05			; need 5 bytes for GOSUB
001EE1r 2  20 rr rr     	JSR	LAB_1212		; check room on stack for A bytes
001EE4r 2  A5 C4        	LDA	Bpntrh		; get BASIC execute pointer high byte
001EE6r 2  48           	PHA				; push on stack
001EE7r 2  A5 C3        	LDA	Bpntrl		; get BASIC execute pointer low byte
001EE9r 2  48           	PHA				; push on stack
001EEAr 2  A5 88        	LDA	Clineh		; get current line high byte
001EECr 2  48           	PHA				; push on stack
001EEDr 2  A5 87        	LDA	Clinel		; get current line low byte
001EEFr 2  48           	PHA				; push on stack
001EF0r 2  A9 8D        	LDA	#TK_GOSUB		; token for GOSUB
001EF2r 2  48           	PHA				; push on stack
001EF3r 2               
001EF3r 2  B9 01 00     	LDA	PLUS_1,Y		; get interrupt code pointer low byte
001EF6r 2  85 C3        	STA	Bpntrl		; save as BASIC execute pointer low byte
001EF8r 2  B9 02 00     	LDA	PLUS_2,Y		; get interrupt code pointer high byte
001EFBr 2  85 C4        	STA	Bpntrh		; save as BASIC execute pointer high byte
001EFDr 2               
001EFDr 2  4C rr rr     	JMP	LAB_15C2		; go do interpreter inner loop
001F00r 2               					; can't RTS, we used the stack! the RTS from the ctrl-c
001F00r 2               					; check will be taken when the RETIRQ/RETNMI/RETURN is
001F00r 2               					; executed at the end of the subroutine
001F00r 2               
001F00r 2               ; get byte from input device, no waiting
001F00r 2               ; returns with carry set if byte in A
001F00r 2               
001F00r 2               INGET
001F00r 2  20 rr rr     	JSR	V_INPT		; call scan input device
001F03r 2  B0 09        	BCS	LAB_FB95		; if byte go reset timer
001F05r 2               
001F05r 2  AD 02 02     	LDA	ccnull		; get countdown
001F08r 2  F0 09        	BEQ	LAB_FB96		; exit if empty
001F0Ar 2               
001F0Ar 2  AD 01 02     	LDA	ccbyte		; get last received byte
001F0Dr 2  38           	SEC				; flag we got a byte
001F0Er 2               LAB_FB95
001F0Er 2  A2 00        	LDX	#$00			; clear X
001F10r 2  8E 02 02     	STX	ccnull		; clear timer because we got a byte
001F13r 2               LAB_FB96
001F13r 2  60           	RTS
001F14r 2               
001F14r 2               ; these routines only enable the interrupts if the set-up flag is set
001F14r 2               ; if not they have no effect
001F14r 2               
001F14r 2               ; perform IRQ {ON|OFF|CLEAR}
001F14r 2               
001F14r 2               LAB_IRQ
001F14r 2  A2 DF        	LDX	#IrqBase		; set pointer to IRQ values
001F16r 2  2C           	.byte	$2C			; make next line BIT abs.
001F17r 2               
001F17r 2               ; perform NMI {ON|OFF|CLEAR}
001F17r 2               
001F17r 2               LAB_NMI
001F17r 2  A2 DC        	LDX	#NmiBase		; set pointer to NMI values
001F19r 2  C9 93        	CMP	#TK_ON		; compare with token for ON
001F1Br 2  F0 11        	BEQ	LAB_INON		; go turn on interrupt
001F1Dr 2               
001F1Dr 2  C9 B6        	CMP	#TK_OFF		; compare with token for OFF
001F1Fr 2  F0 07        	BEQ	LAB_IOFF		; go turn off interrupt
001F21r 2               
001F21r 2  49 A2        	EOR	#TK_CLEAR		; compare with token for CLEAR, A = $00 if = TK_CLEAR
001F23r 2  F0 0E        	BEQ	LAB_INEX		; go clear interrupt flags and return
001F25r 2               
001F25r 2  4C rr rr     	JMP	LAB_SNER		; do syntax error then warm start
001F28r 2               
001F28r 2               LAB_IOFF
001F28r 2  A9 7F        	LDA	#$7F			; clear A
001F2Ar 2  35 00        	AND	PLUS_0,X		; AND with interrupt setup flag
001F2Cr 2  10 05        	BPL	LAB_INEX		; go clear interrupt enabled flag and return
001F2Er 2               
001F2Er 2               LAB_INON
001F2Er 2  B5 00        	LDA	PLUS_0,X		; get interrupt setup flag
001F30r 2  0A           	ASL				; Shift bit to enabled flag
001F31r 2  15 00        	ORA	PLUS_0,X		; OR with flag byte
001F33r 2               LAB_INEX
001F33r 2  95 00        	STA	PLUS_0,X		; save interrupt flag byte
001F35r 2  4C BC 00     	JMP	LAB_IGBY		; update BASIC execute pointer and return
001F38r 2               
001F38r 2               ; these routines set up the pointers and flags for the interrupt routines
001F38r 2               ; note that the interrupts are also enabled by these commands
001F38r 2               
001F38r 2               ; perform ON IRQ
001F38r 2               
001F38r 2               LAB_SIRQ
001F38r 2  58           	CLI				; enable interrupts
001F39r 2  A2 DF        	LDX	#IrqBase		; set pointer to IRQ values
001F3Br 2  2C           	.byte	$2C			; make next line BIT abs.
001F3Cr 2               
001F3Cr 2               ; perform ON NMI
001F3Cr 2               
001F3Cr 2               LAB_SNMI
001F3Cr 2  A2 DC        	LDX	#NmiBase		; set pointer to NMI values
001F3Er 2               
001F3Er 2  86 78        	STX	TempB			; save interrupt pointer
001F40r 2  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory (past token)
001F43r 2  20 rr rr     	JSR	LAB_GFPN		; get fixed-point number into temp integer
001F46r 2  A5 79        	LDA	Smeml			; get start of mem low byte
001F48r 2  A6 7A        	LDX	Smemh			; get start of mem high byte
001F4Ar 2  20 rr rr     	JSR	LAB_SHLN		; search Basic for temp integer line number from AX
001F4Dr 2  B0 03        	BCS	LAB_LFND		; if carry set go set-up interrupt
001F4Fr 2               
001F4Fr 2  4C rr rr     	JMP	LAB_16F7		; else go do "Undefined statement" error and warm start
001F52r 2               
001F52r 2               LAB_LFND
001F52r 2  A6 78        	LDX	TempB			; get interrupt pointer
001F54r 2  A5 AA        	LDA	Baslnl		; get pointer low byte
001F56r 2  E9 01        	SBC	#$01			; -1 (carry already set for subtract)
001F58r 2  95 01        	STA	PLUS_1,X		; save as interrupt pointer low byte
001F5Ar 2  A5 AB        	LDA	Baslnh		; get pointer high byte
001F5Cr 2  E9 00        	SBC	#$00			; subtract carry
001F5Er 2  95 02        	STA	PLUS_2,X		; save as interrupt pointer high byte
001F60r 2               
001F60r 2  A9 C0        	LDA	#$C0			; set interrupt enabled/setup bits
001F62r 2  95 00        	STA	PLUS_0,X		; set interrupt flags
001F64r 2               LAB_IRTS
001F64r 2  60           	RTS
001F65r 2               
001F65r 2               ; return from IRQ service, restores the enabled flag.
001F65r 2               
001F65r 2               ; perform RETIRQ
001F65r 2               
001F65r 2               LAB_RETIRQ
001F65r 2  D0 FD        	BNE	LAB_IRTS		; exit if following token (to allow syntax error)
001F67r 2               
001F67r 2  A5 DF        	LDA	IrqBase		; get interrupt flags
001F69r 2  0A           	ASL				; copy setup to enabled (b7)
001F6Ar 2  05 DF        	ORA	IrqBase		; OR in setup flag
001F6Cr 2  85 DF        	STA	IrqBase		; save enabled flag
001F6Er 2  4C rr rr     	JMP	LAB_16E8		; go do rest of RETURN
001F71r 2               
001F71r 2               ; return from NMI service, restores the enabled flag.
001F71r 2               
001F71r 2               ; perform RETNMI
001F71r 2               
001F71r 2               LAB_RETNMI
001F71r 2  D0 F1        	BNE	LAB_IRTS		; exit if following token (to allow syntax error)
001F73r 2               
001F73r 2  A5 DC        	LDA	NmiBase		; get set-up flag
001F75r 2  0A           	ASL				; copy setup to enabled (b7)
001F76r 2  05 DC        	ORA	NmiBase		; OR in setup flag
001F78r 2  85 DC        	STA	NmiBase		; save enabled flag
001F7Ar 2  4C rr rr     	JMP	LAB_16E8		; go do rest of RETURN
001F7Dr 2               
001F7Dr 2               ; MAX() MIN() pre process
001F7Dr 2               
001F7Dr 2               LAB_MMPP
001F7Dr 2  20 rr rr     	JSR	LAB_EVEZ		; process expression
001F80r 2  4C rr rr     	JMP	LAB_CTNM		; check if source is numeric, else do type mismatch
001F83r 2               
001F83r 2               ; perform MAX()
001F83r 2               
001F83r 2               LAB_MAX
001F83r 2  20 rr rr     	JSR	LAB_PHFA		; push FAC1, evaluate expression,
001F86r 2               					; pull FAC2 and compare with FAC1
001F86r 2  10 FB        	BPL	LAB_MAX		; branch if no swap to do
001F88r 2               
001F88r 2  A5 B4        	LDA	FAC2_1		; get FAC2 mantissa1
001F8Ar 2  09 80        	ORA	#$80			; set top bit (clear sign from compare)
001F8Cr 2  85 B4        	STA	FAC2_1		; save FAC2 mantissa1
001F8Er 2  20 rr rr     	JSR	LAB_279B		; copy FAC2 to FAC1
001F91r 2  F0 F0        	BEQ	LAB_MAX		; go do next (branch always)
001F93r 2               
001F93r 2               ; perform MIN()
001F93r 2               
001F93r 2               LAB_MIN
001F93r 2  20 rr rr     	JSR	LAB_PHFA		; push FAC1, evaluate expression,
001F96r 2               					; pull FAC2 and compare with FAC1
001F96r 2  30 FB        	BMI	LAB_MIN		; branch if no swap to do
001F98r 2               
001F98r 2  F0 F9        	BEQ	LAB_MIN		; branch if no swap to do
001F9Ar 2               
001F9Ar 2  A5 B4        	LDA	FAC2_1		; get FAC2 mantissa1
001F9Cr 2  09 80        	ORA	#$80			; set top bit (clear sign from compare)
001F9Er 2  85 B4        	STA	FAC2_1		; save FAC2 mantissa1
001FA0r 2  20 rr rr     	JSR	LAB_279B		; copy FAC2 to FAC1
001FA3r 2  F0 EE        	BEQ	LAB_MIN		; go do next (branch always)
001FA5r 2               
001FA5r 2               ; exit routine. don't bother returning to the loop code
001FA5r 2               ; check for correct exit, else so syntax error
001FA5r 2               
001FA5r 2               LAB_MMEC
001FA5r 2  C9 29        	CMP	#')'			; is it end of function?
001FA7r 2  D0 05        	BNE	LAB_MMSE		; if not do MAX MIN syntax error
001FA9r 2               
001FA9r 2  68           	PLA				; dump return address low byte
001FAAr 2  68           	PLA				; dump return address high byte
001FABr 2  4C BC 00     	JMP	LAB_IGBY		; update BASIC execute pointer (to chr past ")")
001FAEr 2               
001FAEr 2               LAB_MMSE
001FAEr 2  4C rr rr     	JMP	LAB_SNER		; do syntax error then warm start
001FB1r 2               
001FB1r 2               ; check for next, evaluate and return or exit
001FB1r 2               ; this is the routine that does most of the work
001FB1r 2               
001FB1r 2               LAB_PHFA
001FB1r 2  20 C2 00     	JSR	LAB_GBYT		; get next BASIC byte
001FB4r 2  C9 2C        	CMP	#','			; is there more ?
001FB6r 2  D0 ED        	BNE	LAB_MMEC		; if not go do end check
001FB8r 2               
001FB8r 2               					; push FAC1
001FB8r 2  20 rr rr     	JSR	LAB_27BA		; round FAC1
001FBBr 2  A5 B0        	LDA	FAC1_s		; get FAC1 sign
001FBDr 2  09 7F        	ORA	#$7F			; set all non sign bits
001FBFr 2  25 AD        	AND	FAC1_1		; AND FAC1 mantissa1 (AND in sign bit)
001FC1r 2  48           	PHA				; push on stack
001FC2r 2  A5 AE        	LDA	FAC1_2		; get FAC1 mantissa2
001FC4r 2  48           	PHA				; push on stack
001FC5r 2  A5 AF        	LDA	FAC1_3		; get FAC1 mantissa3
001FC7r 2  48           	PHA				; push on stack
001FC8r 2  A5 AC        	LDA	FAC1_e		; get FAC1 exponent
001FCAr 2  48           	PHA				; push on stack
001FCBr 2               
001FCBr 2  20 BC 00     	JSR	LAB_IGBY		; scan and get next BASIC byte (after ",")
001FCEr 2  20 rr rr     	JSR	LAB_EVNM		; evaluate expression and check is numeric,
001FD1r 2               					; else do type mismatch
001FD1r 2               
001FD1r 2               					; pop FAC2 (MAX/MIN expression so far)
001FD1r 2  68           	PLA				; pop exponent
001FD2r 2  85 B3        	STA	FAC2_e		; save FAC2 exponent
001FD4r 2  68           	PLA				; pop mantissa3
001FD5r 2  85 B6        	STA	FAC2_3		; save FAC2 mantissa3
001FD7r 2  68           	PLA				; pop mantissa1
001FD8r 2  85 B5        	STA	FAC2_2		; save FAC2 mantissa2
001FDAr 2  68           	PLA				; pop sign/mantissa1
001FDBr 2  85 B4        	STA	FAC2_1		; save FAC2 sign/mantissa1
001FDDr 2  85 B7        	STA	FAC2_s		; save FAC2 sign
001FDFr 2               
001FDFr 2               					; compare FAC1 with (packed) FAC2
001FDFr 2  A9 B3        	LDA	#<FAC2_e		; set pointer low byte to FAC2
001FE1r 2  A0 00        	LDY	#>FAC2_e		; set pointer high byte to FAC2
001FE3r 2  4C rr rr     	JMP	LAB_27F8		; compare FAC1 with FAC2 (AY) and return
001FE6r 2               					; returns A=$00 if FAC1 = (AY)
001FE6r 2               					; returns A=$01 if FAC1 > (AY)
001FE6r 2               					; returns A=$FF if FAC1 < (AY)
001FE6r 2               
001FE6r 2               ; perform WIDTH
001FE6r 2               
001FE6r 2               LAB_WDTH
001FE6r 2  C9 2C        	CMP	#','			; is next byte ","
001FE8r 2  F0 1B        	BEQ	LAB_TBSZ		; if so do tab size
001FEAr 2               
001FEAr 2  20 rr rr     	JSR	LAB_GTBY		; get byte parameter
001FEDr 2  8A           	TXA				; copy width to A
001FEEr 2  F0 0A        	BEQ	LAB_NSTT		; branch if set for infinite line
001FF0r 2               
001FF0r 2  E0 10        	CPX	#$10			; else make min width = 16d
001FF2r 2  90 45        	BCC	TabErr		; if less do function call error and exit
001FF4r 2               
001FF4r 2               ; this next compare ensures that we can't exit WIDTH via an error leaving the
001FF4r 2               ; tab size greater than the line length.
001FF4r 2               
001FF4r 2  E4 64        	CPX	TabSiz		; compare with tab size
001FF6r 2  B0 02        	BCS	LAB_NSTT		; branch if >= tab size
001FF8r 2               
001FF8r 2  86 64        	STX	TabSiz		; else make tab size = terminal width
001FFAr 2               LAB_NSTT
001FFAr 2  86 0F        	STX	TWidth		; set the terminal width
001FFCr 2  20 C2 00     	JSR	LAB_GBYT		; get BASIC byte back
001FFFr 2  F0 1A        	BEQ	WExit			; exit if no following
002001r 2               
002001r 2  C9 2C        	CMP	#','			; else is it ","
002003r 2  D0 A9        	BNE	LAB_MMSE		; if not do syntax error
002005r 2               
002005r 2               LAB_TBSZ
002005r 2  20 rr rr     	JSR	LAB_SGBY		; scan and get byte parameter
002008r 2  8A           	TXA				; copy TAB size
002009r 2  30 2E        	BMI	TabErr		; if >127 do function call error and exit
00200Br 2               
00200Br 2  E0 01        	CPX	#$01			; compare with min-1
00200Dr 2  90 2A        	BCC	TabErr		; if <=1 do function call error and exit
00200Fr 2               
00200Fr 2  A5 0F        	LDA	TWidth		; set flags for width
002011r 2  F0 06        	BEQ	LAB_SVTB		; skip check if infinite line
002013r 2               
002013r 2  E4 0F        	CPX	TWidth		; compare TAB with width
002015r 2  F0 02        	BEQ	LAB_SVTB		; ok if =
002017r 2               
002017r 2  B0 20        	BCS	TabErr		; branch if too big
002019r 2               
002019r 2               LAB_SVTB
002019r 2  86 64        	STX	TabSiz		; save TAB size
00201Br 2               
00201Br 2               ; calculate tab column limit from TAB size. The Iclim is set to the last tab
00201Br 2               ; position on a line that still has at least one whole tab width between it
00201Br 2               ; and the end of the line.
00201Br 2               
00201Br 2               WExit
00201Br 2  A5 0F        	LDA	TWidth		; get width
00201Dr 2  F0 06        	BEQ	LAB_SULP		; branch if infinite line
00201Fr 2               
00201Fr 2  C5 64        	CMP	TabSiz		; compare with tab size
002021r 2  B0 03        	BCS	LAB_WDLP		; branch if >= tab size
002023r 2               
002023r 2  85 64        	STA	TabSiz		; else make tab size = terminal width
002025r 2               LAB_SULP
002025r 2  38           	SEC				; set carry for subtract
002026r 2               LAB_WDLP
002026r 2  E5 64        	SBC	TabSiz		; subtract tab size
002028r 2  B0 FC        	BCS	LAB_WDLP		; loop while no borrow
00202Ar 2               
00202Ar 2  65 64        	ADC	TabSiz		; add tab size back
00202Cr 2  18           	CLC				; clear carry for add
00202Dr 2  65 64        	ADC	TabSiz		; add tab size back again
00202Fr 2  85 10        	STA	Iclim			; save for now
002031r 2  A5 0F        	LDA	TWidth		; get width back
002033r 2  38           	SEC				; set carry for subtract
002034r 2  E5 10        	SBC	Iclim			; subtract remainder
002036r 2  85 10        	STA	Iclim			; save tab column limit
002038r 2               LAB_NOSQ
002038r 2  60           	RTS
002039r 2               
002039r 2               TabErr
002039r 2  4C rr rr     	JMP	LAB_FCER		; do function call error then warm start
00203Cr 2               
00203Cr 2               ; perform SQR()
00203Cr 2               
00203Cr 2               LAB_SQR
00203Cr 2  A5 B0        	LDA	FAC1_s		; get FAC1 sign
00203Er 2  30 F9        	BMI	TabErr		; if -ve do function call error
002040r 2               
002040r 2  A5 AC        	LDA	FAC1_e		; get exponent
002042r 2  F0 F4        	BEQ	LAB_NOSQ		; if zero just return
002044r 2               
002044r 2               					; else do root
002044r 2  20 rr rr     	JSR	LAB_27AB		; round and copy FAC1 to FAC2
002047r 2  A9 00        	LDA	#$00			; clear A
002049r 2               
002049r 2  85 77        	STA	FACt_3		; clear remainder
00204Br 2  85 76        	STA	FACt_2		; ..
00204Dr 2  85 75        	STA	FACt_1		; ..
00204Fr 2  85 78        	STA	TempB			; ..
002051r 2               
002051r 2  85 AF        	STA	FAC1_3		; clear root
002053r 2  85 AE        	STA	FAC1_2		; ..
002055r 2  85 AD        	STA	FAC1_1		; ..
002057r 2               
002057r 2  A2 18        	LDX	#$18			; 24 pairs of bits to do
002059r 2  A5 B3        	LDA	FAC2_e		; get exponent
00205Br 2  4A           	LSR				; check odd/even
00205Cr 2  B0 0E        	BCS	LAB_SQE2		; if odd only 1 shift first time
00205Er 2               
00205Er 2               LAB_SQE1
00205Er 2  06 B6        	ASL	FAC2_3		; shift highest bit of number ..
002060r 2  26 B5        	ROL	FAC2_2		; ..
002062r 2  26 B4        	ROL	FAC2_1		; ..
002064r 2  26 77        	ROL	FACt_3		; .. into remainder
002066r 2  26 76        	ROL	FACt_2		; ..
002068r 2  26 75        	ROL	FACt_1		; ..
00206Ar 2  26 78        	ROL	TempB			; .. never overflows
00206Cr 2               LAB_SQE2
00206Cr 2  06 B6        	ASL	FAC2_3		; shift highest bit of number ..
00206Er 2  26 B5        	ROL	FAC2_2		; ..
002070r 2  26 B4        	ROL	FAC2_1		; ..
002072r 2  26 77        	ROL	FACt_3		; .. into remainder
002074r 2  26 76        	ROL	FACt_2		; ..
002076r 2  26 75        	ROL	FACt_1		; ..
002078r 2  26 78        	ROL	TempB			; .. never overflows
00207Ar 2               
00207Ar 2  06 AF        	ASL	FAC1_3		; root = root * 2
00207Cr 2  26 AE        	ROL	FAC1_2		; ..
00207Er 2  26 AD        	ROL	FAC1_1		; .. never overflows
002080r 2               
002080r 2  A5 AF        	LDA	FAC1_3		; get root low byte
002082r 2  2A           	ROL				; *2
002083r 2  85 5B        	STA	Temp3			; save partial low byte
002085r 2  A5 AE        	LDA	FAC1_2		; get root low mid byte
002087r 2  2A           	ROL				; *2
002088r 2  85 5C        	STA	Temp3+1		; save partial low mid byte
00208Ar 2  A5 AD        	LDA	FAC1_1		; get root high mid byte
00208Cr 2  2A           	ROL				; *2
00208Dr 2  85 5D        	STA	Temp3+2		; save partial high mid byte
00208Fr 2  A9 00        	LDA	#$00			; get root high byte (always $00)
002091r 2  2A           	ROL				; *2
002092r 2  85 5E        	STA	Temp3+3		; save partial high byte
002094r 2               
002094r 2               					; carry clear for subtract +1
002094r 2  A5 77        	LDA	FACt_3		; get remainder low byte
002096r 2  E5 5B        	SBC	Temp3			; subtract partial low byte
002098r 2  85 5B        	STA	Temp3			; save partial low byte
00209Ar 2               
00209Ar 2  A5 76        	LDA	FACt_2		; get remainder low mid byte
00209Cr 2  E5 5C        	SBC	Temp3+1		; subtract partial low mid byte
00209Er 2  85 5C        	STA	Temp3+1		; save partial low mid byte
0020A0r 2               
0020A0r 2  A5 75        	LDA	FACt_1		; get remainder high mid byte
0020A2r 2  E5 5D        	SBC	Temp3+2		; subtract partial high mid byte
0020A4r 2  A8           	TAY				; copy partial high mid byte
0020A5r 2               
0020A5r 2  A5 78        	LDA	TempB			; get remainder high byte
0020A7r 2  E5 5E        	SBC	Temp3+3		; subtract partial high byte
0020A9r 2  90 0E        	BCC	LAB_SQNS		; skip sub if remainder smaller
0020ABr 2               
0020ABr 2  85 78        	STA	TempB			; save remainder high byte
0020ADr 2               
0020ADr 2  84 75        	STY	FACt_1		; save remainder high mid byte
0020AFr 2               
0020AFr 2  A5 5C        	LDA	Temp3+1		; get remainder low mid byte
0020B1r 2  85 76        	STA	FACt_2		; save remainder low mid byte
0020B3r 2               
0020B3r 2  A5 5B        	LDA	Temp3			; get partial low byte
0020B5r 2  85 77        	STA	FACt_3		; save remainder low byte
0020B7r 2               
0020B7r 2  E6 AF        	INC	FAC1_3		; increment root low byte (never any rollover)
0020B9r 2               LAB_SQNS
0020B9r 2  CA           	DEX				; decrement bit pair count
0020BAr 2  D0 A2        	BNE	LAB_SQE1		; loop if not all done
0020BCr 2               
0020BCr 2  38           	SEC				; set carry for subtract
0020BDr 2  A5 B3        	LDA	FAC2_e		; get exponent
0020BFr 2  E9 80        	SBC	#$80			; normalise
0020C1r 2  6A           	ROR				; /2 and re-bias to $80
0020C2r 2  69 00        	ADC	#$00			; add bit zero back in (allow for half shift)
0020C4r 2  85 AC        	STA	FAC1_e		; save it
0020C6r 2  4C rr rr     	JMP	LAB_24D5		; normalise FAC1 and return
0020C9r 2               
0020C9r 2               ; perform VARPTR()
0020C9r 2               
0020C9r 2               LAB_VARPTR
0020C9r 2  20 BC 00     	JSR	LAB_IGBY		; increment and scan memory
0020CCr 2  20 rr rr     	JSR	LAB_GVAR		; get var address
0020CFr 2  20 rr rr     	JSR	LAB_1BFB		; scan for ")" , else do syntax error then warm start
0020D2r 2  A4 95        	LDY	Cvaral		; get var address low byte
0020D4r 2  A5 96        	LDA	Cvarah		; get var address high byte
0020D6r 2  4C rr rr     	JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
0020D9r 2               
0020D9r 2               ; perform PI
0020D9r 2               
0020D9r 2               LAB_PI
0020D9r 2  A9 rr        	LDA	#<LAB_2C7C		; set (2*pi) pointer low byte
0020DBr 2  A0 rr        	LDY	#>LAB_2C7C		; set (2*pi) pointer high byte
0020DDr 2  20 rr rr     	JSR	LAB_UFAC		; unpack memory (AY) into FAC1
0020E0r 2  C6 AC        	DEC	FAC1_e		; make result = PI
0020E2r 2  60           	RTS
0020E3r 2               
0020E3r 2               ; perform TWOPI
0020E3r 2               
0020E3r 2               LAB_TWOPI
0020E3r 2  A9 rr        	LDA	#<LAB_2C7C		; set (2*pi) pointer low byte
0020E5r 2  A0 rr        	LDY	#>LAB_2C7C		; set (2*pi) pointer high byte
0020E7r 2  4C rr rr     	JMP	LAB_UFAC		; unpack memory (AY) into FAC1 and return
0020EAr 2               
0020EAr 2               ; system dependant i/o vectors
0020EAr 2               ; these are in RAM and are set by the monitor at start-up
0020EAr 2               
0020EAr 2               V_INPT
0020EAr 2  6C 05 02     	JMP	(VEC_IN)		; non halting scan input device
0020EDr 2               V_OUTP
0020EDr 2  6C 07 02     	JMP	(VEC_OUT)		; send byte to output device
0020F0r 2               V_LOAD
0020F0r 2  6C 09 02     	JMP	(VEC_LD)		; load BASIC program
0020F3r 2               V_SAVE
0020F3r 2  6C 0B 02     	JMP	(VEC_SV)		; save BASIC program
0020F6r 2               
0020F6r 2               ; The rest are tables messages and code for RAM
0020F6r 2               
0020F6r 2               ; the rest of the code is tables and BASIC start-up code
0020F6r 2               
0020F6r 2               PG2_TABS
0020F6r 2  00           	.byte	$00			; ctrl-c flag		-	$00 = enabled
0020F7r 2  00           	.byte	$00			; ctrl-c byte		-	GET needs this
0020F8r 2  00           	.byte	$00			; ctrl-c byte timeout	-	GET needs this
0020F9r 2  rr rr        	.word	CTRLC			; ctrl c check vector
0020FBr 2               ;	.word	xxxx			; non halting key input	-	monitor to set this
0020FBr 2               ;	.word	xxxx			; output vector		-	monitor to set this
0020FBr 2               ;	.word	xxxx			; load vector		-	monitor to set this
0020FBr 2               ;	.word	xxxx			; save vector		-	monitor to set this
0020FBr 2               PG2_TABE
0020FBr 2               
0020FBr 2               ; character get subroutine for zero page
0020FBr 2               
0020FBr 2               ; For a 1.8432MHz 6502 including the JSR and RTS
0020FBr 2               ; fastest (>=":")	=  29 cycles =  15.7uS
0020FBr 2               ; slowest (<":")	=  40 cycles =  21.7uS
0020FBr 2               ; space skip	= +21 cycles = +11.4uS
0020FBr 2               ; inc across page	=  +4 cycles =  +2.2uS
0020FBr 2               
0020FBr 2               ; the target address for the LDA at LAB_2CF4 becomes the BASIC execute pointer once the
0020FBr 2               ; block is copied to it's destination, any non zero page address will do at assembly
0020FBr 2               ; time, to assemble a three byte instruction.
0020FBr 2               
0020FBr 2               ; page 0 initialisation table from $BC
0020FBr 2               ; increment and scan memory
0020FBr 2               
0020FBr 2               LAB_2CEE
0020FBr 2  E6 C3        	INC	Bpntrl		; increment BASIC execute pointer low byte
0020FDr 2  D0 02        	BNE	LAB_2CF4		; branch if no carry
0020FFr 2               					; else
0020FFr 2  E6 C4        	INC	Bpntrh		; increment BASIC execute pointer high byte
002101r 2               
002101r 2               ; page 0 initialisation table from $C2
002101r 2               ; scan memory
002101r 2               
002101r 2               LAB_2CF4
002101r 2  AD FF FF     	LDA	$FFFF			; get byte to scan (addr set by call routine)
002104r 2  C9 AD        	CMP	#TK_ELSE		; compare with the token for ELSE
002106r 2  F0 0E        	BEQ	LAB_2D05		; exit if ELSE, not numeric, carry set
002108r 2               
002108r 2  C9 3A        	CMP	#':'			; compare with ":"
00210Ar 2  B0 0A        	BCS	LAB_2D05		; exit if >= ":", not numeric, carry set
00210Cr 2               
00210Cr 2  C9 20        	CMP	#' '			; compare with " "
00210Er 2  F0 EB        	BEQ	LAB_2CEE		; if " " go do next
002110r 2               
002110r 2  38           	SEC				; set carry for SBC
002111r 2  E9 30        	SBC	#'0'			; subtract "0"
002113r 2  38           	SEC				; set carry for SBC
002114r 2  E9 D0        	SBC	#$D0			; subtract -"0"
002116r 2               					; clear carry if byte = "0"-"9"
002116r 2               LAB_2D05
002116r 2  60           	RTS
002117r 2               
002117r 2               ; page zero initialisation table $00-$12 inclusive
002117r 2               
002117r 2               StrTab
002117r 2  4C           	.byte	$4C			; JMP opcode
002118r 2  rr rr        	.word LAB_COLD		; initial warm start vector (cold start)
00211Ar 2               
00211Ar 2  00           	.byte	$00			; these bytes are not used by BASIC
00211Br 2  00 00        	.word	$0000			;
00211Dr 2  00 00        	.word	$0000			;
00211Fr 2  00 00        	.word	$0000			;
002121r 2               
002121r 2  4C           	.byte	$4C			; JMP opcode
002122r 2  rr rr        	.word	LAB_FCER		; initial user function vector ("Function call" error)
002124r 2  00           	.byte	$00			; default NULL count
002125r 2  00           	.byte	$00			; clear terminal position
002126r 2  00           	.byte	$00			; default terminal width byte
002127r 2  F2           	.byte	$F2			; default limit for TAB = 14
002128r 2  00 04        	.word	Ram_base		; start of user RAM
00212Ar 2               EndTab
00212Ar 2               
00212Ar 2               LAB_MSZM
00212Ar 2  0D 0A 4D 65  	.byte	$0D,$0A,"Memory size ",$00
00212Er 2  6D 6F 72 79  
002132r 2  20 73 69 7A  
002139r 2               
002139r 2               LAB_SMSG
002139r 2  20 42 79 74  	.byte	" Bytes free",$0D,$0A,$0A
00213Dr 2  65 73 20 66  
002141r 2  72 65 65 0D  
002147r 2  45 6E 68 61  	.byte	"Enhanced BASIC 2.22",$0A,$00
00214Br 2  6E 63 65 64  
00214Fr 2  20 42 41 53  
00215Cr 2               
00215Cr 2               ; numeric constants and series
00215Cr 2               
00215Cr 2               					; constants and series for LOG(n)
00215Cr 2               LAB_25A0
00215Cr 2  02           	.byte	$02			; counter
00215Dr 2  80 19 56 62  	.byte	$80,$19,$56,$62	; 0.59898
002161r 2  80 76 22 F3  	.byte	$80,$76,$22,$F3	; 0.96147
002165r 2               ;##	.byte	$80,$76,$22,$F1	; 0.96147
002165r 2  82 38 AA 40  	.byte	$82,$38,$AA,$40	; 2.88539
002169r 2               ;##	.byte	$82,$38,$AA,$45	; 2.88539
002169r 2               
002169r 2               LAB_25AD
002169r 2  80 35 04 F3  	.byte	$80,$35,$04,$F3	; 0.70711	1/root 2
00216Dr 2               LAB_25B1
00216Dr 2  81 35 04 F3  	.byte	$81,$35,$04,$F3	; 1.41421	root 2
002171r 2               LAB_25B5
002171r 2  80 80 00 00  	.byte	$80,$80,$00,$00	; -0.5
002175r 2               LAB_25B9
002175r 2  80 31 72 18  	.byte	$80,$31,$72,$18	; 0.69315	LOG(2)
002179r 2               
002179r 2               					; numeric PRINT constants
002179r 2               LAB_2947
002179r 2  91 43 4F F8  	.byte	$91,$43,$4F,$F8	; 99999.9375 (max value with at least one decimal)
00217Dr 2               LAB_294B
00217Dr 2  94 74 23 F7  	.byte	$94,$74,$23,$F7	; 999999.4375 (max value before scientific notation)
002181r 2               LAB_294F
002181r 2  94 74 24 00  	.byte	$94,$74,$24,$00	; 1000000
002185r 2               
002185r 2               					; EXP(n) constants and series
002185r 2               LAB_2AFA
002185r 2  81 38 AA 3B  	.byte	$81,$38,$AA,$3B	; 1.4427	(1/LOG base 2 e)
002189r 2               LAB_2AFE
002189r 2  06           	.byte	$06			; counter
00218Ar 2  74 63 90 8C  	.byte	$74,$63,$90,$8C	; 2.17023e-4
00218Er 2  77 23 0C AB  	.byte	$77,$23,$0C,$AB	; 0.00124
002192r 2  7A 1E 94 00  	.byte	$7A,$1E,$94,$00	; 0.00968
002196r 2  7C 63 42 80  	.byte	$7C,$63,$42,$80	; 0.05548
00219Ar 2  7E 75 FE D0  	.byte	$7E,$75,$FE,$D0	; 0.24023
00219Er 2  80 31 72 15  	.byte	$80,$31,$72,$15	; 0.69315
0021A2r 2  81 00 00 00  	.byte	$81,$00,$00,$00	; 1.00000
0021A6r 2               
0021A6r 2               ;##	.byte	$07			; counter
0021A6r 2               ;##	.byte	$74,$94,$2E,$40	; -1/7! (-1/5040)
0021A6r 2               ;##	.byte	$77,$2E,$4F,$70	;  1/6! ( 1/720)
0021A6r 2               ;##	.byte	$7A,$88,$02,$6E	; -1/5! (-1/120)
0021A6r 2               ;##	.byte	$7C,$2A,$A0,$E6	;  1/4! ( 1/24)
0021A6r 2               ;##	.byte	$7E,$AA,$AA,$50	; -1/3! (-1/6)
0021A6r 2               ;##	.byte	$7F,$7F,$FF,$FF	;  1/2! ( 1/2)
0021A6r 2               ;##	.byte	$81,$80,$00,$00	; -1/1! (-1/1)
0021A6r 2               ;##	.byte	$81,$00,$00,$00	;  1/0! ( 1/1)
0021A6r 2               
0021A6r 2               					; trigonometric constants and series
0021A6r 2               LAB_2C78
0021A6r 2  81 49 0F DB  	.byte	$81,$49,$0F,$DB	; 1.570796371 (pi/2) as floating #
0021AAr 2               LAB_2C84
0021AAr 2  04           	.byte	$04			; counter
0021ABr 2  86 1E D7 FB  	.byte	$86,$1E,$D7,$FB	; 39.7109
0021AFr 2               ;##	.byte	$86,$1E,$D7,$BA	; 39.7109
0021AFr 2  87 99 26 65  	.byte	$87,$99,$26,$65	;-76.575
0021B3r 2               ;##	.byte	$87,$99,$26,$64	;-76.575
0021B3r 2  87 23 34 58  	.byte	$87,$23,$34,$58	; 81.6022
0021B7r 2  86 A5 5D E1  	.byte	$86,$A5,$5D,$E1	;-41.3417
0021BBr 2               ;##	.byte	$86,$A5,$5D,$E0	;-41.3417
0021BBr 2               LAB_2C7C
0021BBr 2  83 49 0F DB  	.byte	$83,$49,$0F,$DB	; 6.28319 (2*pi) as floating #
0021BFr 2               ;##	.byte	$83,$49,$0F,$DA	; 6.28319 (2*pi) as floating #
0021BFr 2               
0021BFr 2               LAB_2CC9
0021BFr 2  08           	.byte	$08			; counter
0021C0r 2  78 3A C5 37  	.byte	$78,$3A,$C5,$37	; 0.00285
0021C4r 2  7B 83 A2 5C  	.byte	$7B,$83,$A2,$5C	;-0.0160686
0021C8r 2  7C 2E DD 4D  	.byte	$7C,$2E,$DD,$4D	; 0.0426915
0021CCr 2  7D 99 B0 1E  	.byte	$7D,$99,$B0,$1E	;-0.0750429
0021D0r 2  7D 59 ED 24  	.byte	$7D,$59,$ED,$24	; 0.106409
0021D4r 2  7E 91 72 00  	.byte	$7E,$91,$72,$00	;-0.142036
0021D8r 2  7E 4C B9 73  	.byte	$7E,$4C,$B9,$73	; 0.199926
0021DCr 2  7F AA AA 53  	.byte	$7F,$AA,$AA,$53	;-0.333331
0021E0r 2               
0021E0r 2               ;##	.byte	$08			; counter
0021E0r 2               ;##	.byte	$78,$3B,$D7,$4A	; 1/17
0021E0r 2               ;##	.byte	$7B,$84,$6E,$02	;-1/15
0021E0r 2               ;##	.byte	$7C,$2F,$C1,$FE	; 1/13
0021E0r 2               ;##	.byte	$7D,$9A,$31,$74	;-1/11
0021E0r 2               ;##	.byte	$7D,$5A,$3D,$84	; 1/9
0021E0r 2               ;##	.byte	$7E,$91,$7F,$C8	;-1/7
0021E0r 2               ;##	.byte	$7E,$4C,$BB,$E4	; 1/5
0021E0r 2               ;##	.byte	$7F,$AA,$AA,$6C	;-1/3
0021E0r 2               
0021E0r 2               LAB_1D96	= *+1			; $00,$00 used for undefined variables
0021E0r 2               LAB_259C
0021E0r 2  81 00 00 00  	.byte	$81,$00,$00,$00	; 1.000000, used for INC
0021E4r 2               LAB_2AFD
0021E4r 2  81 80 00 00  	.byte	$81,$80,$00,$00	; -1.00000, used for DEC. must be on the same page as +1.00
0021E8r 2               
0021E8r 2               					; misc constants
0021E8r 2               LAB_1DF7
0021E8r 2  90           	.byte	$90			;-32768 (uses first three bytes from 0.5)
0021E9r 2               LAB_2A96
0021E9r 2  80 00 00 00  	.byte	$80,$00,$00,$00	; 0.5
0021EDr 2               LAB_2C80
0021EDr 2  7F 00 00 00  	.byte	$7F,$00,$00,$00	; 0.25
0021F1r 2               LAB_26B5
0021F1r 2  84 20 00 00  	.byte	$84,$20,$00,$00	; 10.0000 divide by 10 constant
0021F5r 2               
0021F5r 2               ; This table is used in converting numbers to ASCII.
0021F5r 2               
0021F5r 2               LAB_2A9A
0021F5r 2               LAB_2A9B = LAB_2A9A+1
0021F5r 2               LAB_2A9C = LAB_2A9B+1
0021F5r 2  FE 79 60     	.byte	$FE,$79,$60		; -100000
0021F8r 2  00 27 10     	.byte	$00,$27,$10		; 10000
0021FBr 2  FF FC 18     	.byte	$FF,$FC,$18		; -1000
0021FEr 2  00 00 64     	.byte	$00,$00,$64		; 100
002201r 2  FF FF F6     	.byte	$FF,$FF,$F6		; -10
002204r 2  00 00 01     	.byte	$00,$00,$01		; 1
002207r 2               
002207r 2               LAB_CTBL
002207r 2  rr rr        	.word	LAB_END-1		; END
002209r 2  rr rr        	.word	LAB_FOR-1		; FOR
00220Br 2  rr rr        	.word	LAB_NEXT-1		; NEXT
00220Dr 2  rr rr        	.word	LAB_DATA-1		; DATA
00220Fr 2  rr rr        	.word	LAB_INPUT-1		; INPUT
002211r 2  rr rr        	.word	LAB_DIM-1		; DIM
002213r 2  rr rr        	.word	LAB_READ-1		; READ
002215r 2  rr rr        	.word	LAB_LET-1		; LET
002217r 2  rr rr        	.word	LAB_DEC-1		; DEC			new command
002219r 2  rr rr        	.word	LAB_GOTO-1		; GOTO
00221Br 2  rr rr        	.word	LAB_RUN-1		; RUN
00221Dr 2  rr rr        	.word	LAB_IF-1		; IF
00221Fr 2  rr rr        	.word	LAB_RESTORE-1	; RESTORE		modified command
002221r 2  rr rr        	.word	LAB_GOSUB-1		; GOSUB
002223r 2  rr rr        	.word	LAB_RETIRQ-1	; RETIRQ		new command
002225r 2  rr rr        	.word	LAB_RETNMI-1	; RETNMI		new command
002227r 2  rr rr        	.word	LAB_RETURN-1	; RETURN
002229r 2  rr rr        	.word	LAB_REM-1		; REM
00222Br 2  rr rr        	.word	LAB_STOP-1		; STOP
00222Dr 2  rr rr        	.word	LAB_ON-1		; ON			modified command
00222Fr 2  rr rr        	.word	LAB_NULL-1		; NULL		modified command
002231r 2  rr rr        	.word	LAB_INC-1		; INC			new command
002233r 2  rr rr        	.word	LAB_WAIT-1		; WAIT
002235r 2  rr rr        	.word	V_LOAD-1		; LOAD
002237r 2  rr rr        	.word	V_SAVE-1		; SAVE
002239r 2  rr rr        	.word	LAB_DEF-1		; DEF
00223Br 2  rr rr        	.word	LAB_POKE-1		; POKE
00223Dr 2  rr rr        	.word	LAB_DOKE-1		; DOKE		new command
00223Fr 2  rr rr        	.word	LAB_CALL-1		; CALL		new command
002241r 2  rr rr        	.word	LAB_DO-1		; DO			new command
002243r 2  rr rr        	.word	LAB_LOOP-1		; LOOP		new command
002245r 2  rr rr        	.word	LAB_PRINT-1		; PRINT
002247r 2  rr rr        	.word	LAB_CONT-1		; CONT
002249r 2  rr rr        	.word	LAB_LIST-1		; LIST
00224Br 2  rr rr        	.word	LAB_CLEAR-1		; CLEAR
00224Dr 2  rr rr        	.word	LAB_NEW-1		; NEW
00224Fr 2  rr rr        	.word	LAB_WDTH-1		; WIDTH		new command
002251r 2  rr rr        	.word	LAB_GET-1		; GET			new command
002253r 2  rr rr        	.word	LAB_SWAP-1		; SWAP		new command
002255r 2  rr rr        	.word	LAB_BITSET-1	; BITSET		new command
002257r 2  rr rr        	.word	LAB_BITCLR-1	; BITCLR		new command
002259r 2  rr rr        	.word	LAB_IRQ-1		; IRQ			new command
00225Br 2  rr rr        	.word	LAB_NMI-1		; NMI			new command
00225Dr 2               	;.word   SYSjmp-1                ; SYS         *** added for SBC-2
00225Dr 2               
00225Dr 2               ; function pre process routine table
00225Dr 2               
00225Dr 2               LAB_FTPL
00225Dr 2               LAB_FTPM	= LAB_FTPL+$01
00225Dr 2  rr rr        	.word	LAB_PPFN-1		; SGN(n)	process numeric expression in ()
00225Fr 2  rr rr        	.word	LAB_PPFN-1		; INT(n)		"
002261r 2  rr rr        	.word	LAB_PPFN-1		; ABS(n)		"
002263r 2  rr rr        	.word	LAB_EVEZ-1		; USR(x)	process any expression
002265r 2  rr rr        	.word	LAB_1BF7-1		; FRE(x)		"
002267r 2  rr rr        	.word	LAB_1BF7-1		; POS(x)		"
002269r 2  rr rr        	.word	LAB_PPFN-1		; SQR(n)	process numeric expression in ()
00226Br 2  rr rr        	.word	LAB_PPFN-1		; RND(n)		"
00226Dr 2  rr rr        	.word	LAB_PPFN-1		; LOG(n)		"
00226Fr 2  rr rr        	.word	LAB_PPFN-1		; EXP(n)		"
002271r 2  rr rr        	.word	LAB_PPFN-1		; COS(n)		"
002273r 2  rr rr        	.word	LAB_PPFN-1		; SIN(n)		"
002275r 2  rr rr        	.word	LAB_PPFN-1		; TAN(n)		"
002277r 2  rr rr        	.word	LAB_PPFN-1		; ATN(n)		"
002279r 2  rr rr        	.word	LAB_PPFN-1		; PEEK(n)		"
00227Br 2  rr rr        	.word	LAB_PPFN-1		; DEEK(n)		"
00227Dr 2  00 00        	.word	$0000			; SADD()	none
00227Fr 2  rr rr        	.word	LAB_PPFS-1		; LEN($)	process string expression in ()
002281r 2  rr rr        	.word	LAB_PPFN-1		; STR$(n)	process numeric expression in ()
002283r 2  rr rr        	.word	LAB_PPFS-1		; VAL($)	process string expression in ()
002285r 2  rr rr        	.word	LAB_PPFS-1		; ASC($)		"
002287r 2  rr rr        	.word	LAB_PPFS-1		; UCASE$($)		"
002289r 2  rr rr        	.word	LAB_PPFS-1		; LCASE$($)		"
00228Br 2  rr rr        	.word	LAB_PPFN-1		; CHR$(n)	process numeric expression in ()
00228Dr 2  rr rr        	.word	LAB_BHSS-1		; HEX$(n)		"
00228Fr 2  rr rr        	.word	LAB_BHSS-1		; BIN$(n)		"
002291r 2  00 00        	.word	$0000			; BITTST()	none
002293r 2  rr rr        	.word	LAB_MMPP-1		; MAX()	process numeric expression
002295r 2  rr rr        	.word	LAB_MMPP-1		; MIN()		"
002297r 2  rr rr        	.word	LAB_PPBI-1		; PI		advance pointer
002299r 2  rr rr        	.word	LAB_PPBI-1		; TWOPI		"
00229Br 2  00 00        	.word	$0000			; VARPTR()	none
00229Dr 2  rr rr        	.word	LAB_LRMS-1		; LEFT$()	process string expression
00229Fr 2  rr rr        	.word	LAB_LRMS-1		; RIGHT$()		"
0022A1r 2  rr rr        	.word	LAB_LRMS-1		; MID$()		"
0022A3r 2               
0022A3r 2               ; action addresses for functions
0022A3r 2               
0022A3r 2               LAB_FTBL
0022A3r 2               LAB_FTBM	= LAB_FTBL+$01
0022A3r 2  rr rr        	.word	LAB_SGN-1		; SGN()
0022A5r 2  rr rr        	.word	LAB_INT-1		; INT()
0022A7r 2  rr rr        	.word	LAB_ABS-1		; ABS()
0022A9r 2  rr rr        	.word	LAB_USR-1		; USR()
0022ABr 2  rr rr        	.word	LAB_FRE-1		; FRE()
0022ADr 2  rr rr        	.word	LAB_POS-1		; POS()
0022AFr 2  rr rr        	.word	LAB_SQR-1		; SQR()
0022B1r 2  rr rr        	.word	LAB_RND-1		; RND()		modified function
0022B3r 2  rr rr        	.word	LAB_LOG-1		; LOG()
0022B5r 2  rr rr        	.word	LAB_EXP-1		; EXP()
0022B7r 2  rr rr        	.word	LAB_COS-1		; COS()
0022B9r 2  rr rr        	.word	LAB_SIN-1		; SIN()
0022BBr 2  rr rr        	.word	LAB_TAN-1		; TAN()
0022BDr 2  rr rr        	.word	LAB_ATN-1		; ATN()
0022BFr 2  rr rr        	.word	LAB_PEEK-1		; PEEK()
0022C1r 2  rr rr        	.word	LAB_DEEK-1		; DEEK()		new function
0022C3r 2  rr rr        	.word	LAB_SADD-1		; SADD()		new function
0022C5r 2  rr rr        	.word	LAB_LENS-1		; LEN()
0022C7r 2  rr rr        	.word	LAB_STRS-1		; STR$()
0022C9r 2  rr rr        	.word	LAB_VAL-1		; VAL()
0022CBr 2  rr rr        	.word	LAB_ASC-1		; ASC()
0022CDr 2  rr rr        	.word	LAB_UCASE-1		; UCASE$()		new function
0022CFr 2  rr rr        	.word	LAB_LCASE-1		; LCASE$()		new function
0022D1r 2  rr rr        	.word	LAB_CHRS-1		; CHR$()
0022D3r 2  rr rr        	.word	LAB_HEXS-1		; HEX$()		new function
0022D5r 2  rr rr        	.word	LAB_BINS-1		; BIN$()		new function
0022D7r 2  rr rr        	.word	LAB_BTST-1		; BITTST()		new function
0022D9r 2  rr rr        	.word	LAB_MAX-1		; MAX()		new function
0022DBr 2  rr rr        	.word	LAB_MIN-1		; MIN()		new function
0022DDr 2  rr rr        	.word	LAB_PI-1		; PI			new function
0022DFr 2  rr rr        	.word	LAB_TWOPI-1		; TWOPI		new function
0022E1r 2  rr rr        	.word	LAB_VARPTR-1	; VARPTR()		new function
0022E3r 2  rr rr        	.word	LAB_LEFT-1		; LEFT$()
0022E5r 2  rr rr        	.word	LAB_RIGHT-1		; RIGHT$()
0022E7r 2  rr rr        	.word	LAB_MIDS-1		; MID$()
0022E9r 2               
0022E9r 2               ; hierarchy and action addresses for operator
0022E9r 2               
0022E9r 2               LAB_OPPT
0022E9r 2  79           	.byte	$79			; +
0022EAr 2  rr rr        	.word	LAB_ADD-1
0022ECr 2  79           	.byte	$79			; -
0022EDr 2  rr rr        	.word	LAB_SUBTRACT-1
0022EFr 2  7B           	.byte	$7B			; *
0022F0r 2  rr rr        	.word	LAB_MULTIPLY-1
0022F2r 2  7B           	.byte	$7B			; /
0022F3r 2  rr rr        	.word	LAB_DIVIDE-1
0022F5r 2  7F           	.byte	$7F			; ^
0022F6r 2  rr rr        	.word	LAB_POWER-1
0022F8r 2  50           	.byte	$50			; AND
0022F9r 2  rr rr        	.word	LAB_AND-1
0022FBr 2  46           	.byte	$46			; EOR			new operator
0022FCr 2  rr rr        	.word	LAB_EOR-1
0022FEr 2  46           	.byte	$46			; OR
0022FFr 2  rr rr        	.word	LAB_OR-1
002301r 2  56           	.byte	$56			; >>			new operator
002302r 2  rr rr        	.word	LAB_RSHIFT-1
002304r 2  56           	.byte	$56			; <<			new operator
002305r 2  rr rr        	.word	LAB_LSHIFT-1
002307r 2  7D           	.byte	$7D			; >
002308r 2  rr rr        	.word	LAB_GTHAN-1
00230Ar 2  5A           	.byte	$5A			; =
00230Br 2  rr rr        	.word	LAB_EQUAL-1
00230Dr 2  64           	.byte	$64			; <
00230Er 2  rr rr        	.word	LAB_LTHAN-1
002310r 2               
002310r 2               ; keywords start with ..
002310r 2               ; this is the first character table and must be in alphabetic order
002310r 2               
002310r 2               TAB_1STC
002310r 2  2A           	.byte	"*"
002311r 2  2B           	.byte	"+"
002312r 2  2D           	.byte	"-"
002313r 2  2F           	.byte	"/"
002314r 2  3C           	.byte	"<"
002315r 2  3D           	.byte	"="
002316r 2  3E           	.byte	">"
002317r 2  3F           	.byte	"?"
002318r 2  41           	.byte	"A"
002319r 2  42           	.byte	"B"
00231Ar 2  43           	.byte	"C"
00231Br 2  44           	.byte	"D"
00231Cr 2  45           	.byte	"E"
00231Dr 2  46           	.byte	"F"
00231Er 2  47           	.byte	"G"
00231Fr 2  48           	.byte	"H"
002320r 2  49           	.byte	"I"
002321r 2  4C           	.byte	"L"
002322r 2  4D           	.byte	"M"
002323r 2  4E           	.byte	"N"
002324r 2  4F           	.byte	"O"
002325r 2  50           	.byte	"P"
002326r 2  52           	.byte	"R"
002327r 2  53           	.byte	"S"
002328r 2  54           	.byte	"T"
002329r 2  55           	.byte	"U"
00232Ar 2  56           	.byte	"V"
00232Br 2  57           	.byte	"W"
00232Cr 2  5E           	.byte	"^"
00232Dr 2  00           	.byte	$00			; table terminator
00232Er 2               
00232Er 2               ; pointers to keyword tables
00232Er 2               
00232Er 2               TAB_CHRT
00232Er 2  rr rr        	.word	TAB_STAR		; table for "*"
002330r 2  rr rr        	.word	TAB_PLUS		; table for "+"
002332r 2  rr rr        	.word	TAB_MNUS		; table for "-"
002334r 2  rr rr        	.word	TAB_SLAS		; table for "/"
002336r 2  rr rr        	.word	TAB_LESS		; table for "<"
002338r 2  rr rr        	.word	TAB_EQUL		; table for "="
00233Ar 2  rr rr        	.word	TAB_MORE		; table for ">"
00233Cr 2  rr rr        	.word	TAB_QEST		; table for "?"
00233Er 2  rr rr        	.word	TAB_ASCA		; table for "A"
002340r 2  rr rr        	.word	TAB_ASCB		; table for "B"
002342r 2  rr rr        	.word	TAB_ASCC		; table for "C"
002344r 2  rr rr        	.word	TAB_ASCD		; table for "D"
002346r 2  rr rr        	.word	TAB_ASCE		; table for "E"
002348r 2  rr rr        	.word	TAB_ASCF		; table for "F"
00234Ar 2  rr rr        	.word	TAB_ASCG		; table for "G"
00234Cr 2  rr rr        	.word	TAB_ASCH		; table for "H"
00234Er 2  rr rr        	.word	TAB_ASCI		; table for "I"
002350r 2  rr rr        	.word	TAB_ASCL		; table for "L"
002352r 2  rr rr        	.word	TAB_ASCM		; table for "M"
002354r 2  rr rr        	.word	TAB_ASCN		; table for "N"
002356r 2  rr rr        	.word	TAB_ASCO		; table for "O"
002358r 2  rr rr        	.word	TAB_ASCP		; table for "P"
00235Ar 2  rr rr        	.word	TAB_ASCR		; table for "R"
00235Cr 2  rr rr        	.word	TAB_ASCS		; table for "S"
00235Er 2  rr rr        	.word	TAB_ASCT		; table for "T"
002360r 2  rr rr        	.word	TAB_ASCU		; table for "U"
002362r 2  rr rr        	.word	TAB_ASCV		; table for "V"
002364r 2  rr rr        	.word	TAB_ASCW		; table for "W"
002366r 2  rr rr        	.word	TAB_POWR		; table for "^"
002368r 2               
002368r 2               ; tables for each start character, note if a longer keyword with the same start
002368r 2               ; letters as a shorter one exists then it must come first, else the list is in
002368r 2               ; alphabetical order as follows ..
002368r 2               
002368r 2               ; [keyword,token
002368r 2               ; [keyword,token]]
002368r 2               ; end marker (#$00)
002368r 2               
002368r 2               TAB_STAR
002368r 2  B9 00        	.byte TK_MUL,$00		; *
00236Ar 2               TAB_PLUS
00236Ar 2  B7 00        	.byte TK_PLUS,$00		; +
00236Cr 2               TAB_MNUS
00236Cr 2  B8 00        	.byte TK_MINUS,$00	; -
00236Er 2               TAB_SLAS
00236Er 2  BA 00        	.byte TK_DIV,$00		; /
002370r 2               TAB_LESS
002370r 2               LBB_LSHIFT
002370r 2  3C C0        	.byte	"<",TK_LSHIFT	; <<	note - "<<" must come before "<"
002372r 2  C3           	.byte TK_LT			; <
002373r 2  00           	.byte	$00
002374r 2               TAB_EQUL
002374r 2  C2 00        	.byte TK_EQUAL,$00	; =
002376r 2               TAB_MORE
002376r 2               LBB_RSHIFT
002376r 2  3E BF        	.byte	">",TK_RSHIFT	; >>	note - ">>" must come before ">"
002378r 2  C1           	.byte TK_GT			; >
002379r 2  00           	.byte	$00
00237Ar 2               TAB_QEST
00237Ar 2  9F 00        	.byte TK_PRINT,$00	; ?
00237Cr 2               TAB_ASCA
00237Cr 2               LBB_ABS
00237Cr 2  42 53 28 C6  	.byte	"BS(",TK_ABS	; ABS(
002380r 2               LBB_AND
002380r 2  4E 44 BC     	.byte	"ND",TK_AND		; AND
002383r 2               LBB_ASC
002383r 2  53 43 28 D8  	.byte	"SC(",TK_ASC	; ASC(
002387r 2               LBB_ATN
002387r 2  54 4E 28 D1  	.byte	"TN(",TK_ATN	; ATN(
00238Br 2  00           	.byte	$00
00238Cr 2               TAB_ASCB
00238Cr 2               LBB_BINS
00238Cr 2  49 4E 24 28  	.byte	"IN$(",TK_BINS	; BIN$(
002390r 2  DD           
002391r 2               LBB_BITCLR
002391r 2  49 54 43 4C  	.byte	"ITCLR",TK_BITCLR	; BITCLR
002395r 2  52 A8        
002397r 2               LBB_BITSET
002397r 2  49 54 53 45  	.byte	"ITSET",TK_BITSET	; BITSET
00239Br 2  54 A7        
00239Dr 2               LBB_BITTST
00239Dr 2  49 54 54 53  	.byte	"ITTST(",TK_BITTST
0023A1r 2  54 28 DE     
0023A4r 2               					; BITTST(
0023A4r 2  00           	.byte	$00
0023A5r 2               TAB_ASCC
0023A5r 2               LBB_CALL
0023A5r 2  41 4C 4C 9C  	.byte	"ALL",TK_CALL	; CALL
0023A9r 2               LBB_CHRS
0023A9r 2  48 52 24 28  	.byte	"HR$(",TK_CHRS	; CHR$(
0023ADr 2  DB           
0023AEr 2               LBB_CLEAR
0023AEr 2  4C 45 41 52  	.byte	"LEAR",TK_CLEAR	; CLEAR
0023B2r 2  A2           
0023B3r 2               LBB_CONT
0023B3r 2  4F 4E 54 A0  	.byte	"ONT",TK_CONT	; CONT
0023B7r 2               LBB_COS
0023B7r 2  4F 53 28 CE  	.byte	"OS(",TK_COS	; COS(
0023BBr 2  00           	.byte	$00
0023BCr 2               TAB_ASCD
0023BCr 2               LBB_DATA
0023BCr 2  41 54 41 83  	.byte	"ATA",TK_DATA	; DATA
0023C0r 2               LBB_DEC
0023C0r 2  45 43 88     	.byte	"EC",TK_DEC		; DEC
0023C3r 2               LBB_DEEK
0023C3r 2  45 45 4B 28  	.byte	"EEK(",TK_DEEK	; DEEK(
0023C7r 2  D3           
0023C8r 2               LBB_DEF
0023C8r 2  45 46 99     	.byte	"EF",TK_DEF		; DEF
0023CBr 2               LBB_DIM
0023CBr 2  49 4D 85     	.byte	"IM",TK_DIM		; DIM
0023CEr 2               LBB_DOKE
0023CEr 2  4F 4B 45 9B  	.byte	"OKE",TK_DOKE	; DOKE note - "DOKE" must come before "DO"
0023D2r 2               LBB_DO
0023D2r 2  4F 9D        	.byte	"O",TK_DO		; DO
0023D4r 2  00           	.byte	$00
0023D5r 2               TAB_ASCE
0023D5r 2               LBB_ELSE
0023D5r 2  4C 53 45 AD  	.byte	"LSE",TK_ELSE	; ELSE
0023D9r 2               LBB_END
0023D9r 2  4E 44 80     	.byte	"ND",TK_END		; END
0023DCr 2               LBB_EOR
0023DCr 2  4F 52 BD     	.byte	"OR",TK_EOR		; EOR
0023DFr 2               LBB_EXP
0023DFr 2  58 50 28 CD  	.byte	"XP(",TK_EXP	; EXP(
0023E3r 2  00           	.byte	$00
0023E4r 2               TAB_ASCF
0023E4r 2               LBB_FN
0023E4r 2  4E AF        	.byte	"N",TK_FN		; FN
0023E6r 2               LBB_FOR
0023E6r 2  4F 52 81     	.byte	"OR",TK_FOR		; FOR
0023E9r 2               LBB_FRE
0023E9r 2  52 45 28 C8  	.byte	"RE(",TK_FRE	; FRE(
0023EDr 2  00           	.byte	$00
0023EEr 2               TAB_ASCG
0023EEr 2               LBB_GET
0023EEr 2  45 54 A5     	.byte	"ET",TK_GET		; GET
0023F1r 2               LBB_GOSUB
0023F1r 2  4F 53 55 42  	.byte	"OSUB",TK_GOSUB	; GOSUB
0023F5r 2  8D           
0023F6r 2               LBB_GOTO
0023F6r 2  4F 54 4F 89  	.byte	"OTO",TK_GOTO	; GOTO
0023FAr 2  00           	.byte	$00
0023FBr 2               TAB_ASCH
0023FBr 2               LBB_HEXS
0023FBr 2  45 58 24 28  	.byte	"EX$(",TK_HEXS	; HEX$(
0023FFr 2  DC           
002400r 2  00           	.byte	$00
002401r 2               TAB_ASCI
002401r 2               LBB_IF
002401r 2  46 8B        	.byte	"F",TK_IF		; IF
002403r 2               LBB_INC
002403r 2  4E 43 95     	.byte	"NC",TK_INC		; INC
002406r 2               LBB_INPUT
002406r 2  4E 50 55 54  	.byte	"NPUT",TK_INPUT	; INPUT
00240Ar 2  84           
00240Br 2               LBB_INT
00240Br 2  4E 54 28 C5  	.byte	"NT(",TK_INT	; INT(
00240Fr 2               LBB_IRQ
00240Fr 2  52 51 A9     	.byte	"RQ",TK_IRQ		; IRQ
002412r 2  00           	.byte	$00
002413r 2               TAB_ASCL
002413r 2               LBB_LCASES
002413r 2  43 41 53 45  	.byte	"CASE$(",TK_LCASES
002417r 2  24 28 DA     
00241Ar 2               					; LCASE$(
00241Ar 2               LBB_LEFTS
00241Ar 2  45 46 54 24  	.byte	"EFT$(",TK_LEFTS	; LEFT$(
00241Er 2  28 E4        
002420r 2               LBB_LEN
002420r 2  45 4E 28 D5  	.byte	"EN(",TK_LEN	; LEN(
002424r 2               LBB_LET
002424r 2  45 54 87     	.byte	"ET",TK_LET		; LET
002427r 2               LBB_LIST
002427r 2  49 53 54 A1  	.byte	"IST",TK_LIST	; LIST
00242Br 2               LBB_LOAD
00242Br 2  4F 41 44 97  	.byte	"OAD",TK_LOAD	; LOAD
00242Fr 2               LBB_LOG
00242Fr 2  4F 47 28 CC  	.byte	"OG(",TK_LOG	; LOG(
002433r 2               LBB_LOOP
002433r 2  4F 4F 50 9E  	.byte	"OOP",TK_LOOP	; LOOP
002437r 2  00           	.byte	$00
002438r 2               TAB_ASCM
002438r 2               LBB_MAX
002438r 2  41 58 28 DF  	.byte	"AX(",TK_MAX	; MAX(
00243Cr 2               LBB_MIDS
00243Cr 2  49 44 24 28  	.byte	"ID$(",TK_MIDS	; MID$(
002440r 2  E6           
002441r 2               LBB_MIN
002441r 2  49 4E 28 E0  	.byte	"IN(",TK_MIN	; MIN(
002445r 2  00           	.byte	$00
002446r 2               TAB_ASCN
002446r 2               LBB_NEW
002446r 2  45 57 A3     	.byte	"EW",TK_NEW		; NEW
002449r 2               LBB_NEXT
002449r 2  45 58 54 82  	.byte	"EXT",TK_NEXT	; NEXT
00244Dr 2               LBB_NMI
00244Dr 2  4D 49 AA     	.byte	"MI",TK_NMI		; NMI
002450r 2               LBB_NOT
002450r 2  4F 54 B2     	.byte	"OT",TK_NOT		; NOT
002453r 2               LBB_NULL
002453r 2  55 4C 4C 94  	.byte	"ULL",TK_NULL	; NULL
002457r 2  00           	.byte	$00
002458r 2               TAB_ASCO
002458r 2               LBB_OFF
002458r 2  46 46 B6     	.byte	"FF",TK_OFF		; OFF
00245Br 2               LBB_ON
00245Br 2  4E 93        	.byte	"N",TK_ON		; ON
00245Dr 2               LBB_OR
00245Dr 2  52 BE        	.byte	"R",TK_OR		; OR
00245Fr 2  00           	.byte	$00
002460r 2               TAB_ASCP
002460r 2               LBB_PEEK
002460r 2  45 45 4B 28  	.byte	"EEK(",TK_PEEK	; PEEK(
002464r 2  D2           
002465r 2               LBB_PI
002465r 2  49 E1        	.byte	"I",TK_PI		; PI
002467r 2               LBB_POKE
002467r 2  4F 4B 45 9A  	.byte	"OKE",TK_POKE	; POKE
00246Br 2               LBB_POS
00246Br 2  4F 53 28 C9  	.byte	"OS(",TK_POS	; POS(
00246Fr 2               LBB_PRINT
00246Fr 2  52 49 4E 54  	.byte	"RINT",TK_PRINT	; PRINT
002473r 2  9F           
002474r 2  00           	.byte	$00
002475r 2               TAB_ASCR
002475r 2               LBB_READ
002475r 2  45 41 44 86  	.byte	"EAD",TK_READ	; READ
002479r 2               LBB_REM
002479r 2  45 4D 91     	.byte	"EM",TK_REM		; REM
00247Cr 2               LBB_RESTORE
00247Cr 2  45 53 54 4F  	.byte	"ESTORE",TK_RESTORE
002480r 2  52 45 8C     
002483r 2               					; RESTORE
002483r 2               LBB_RETIRQ
002483r 2  45 54 49 52  	.byte	"ETIRQ",TK_RETIRQ	; RETIRQ
002487r 2  51 8E        
002489r 2               LBB_RETNMI
002489r 2  45 54 4E 4D  	.byte	"ETNMI",TK_RETNMI	; RETNMI
00248Dr 2  49 8F        
00248Fr 2               LBB_RETURN
00248Fr 2  45 54 55 52  	.byte	"ETURN",TK_RETURN	; RETURN
002493r 2  4E 90        
002495r 2               LBB_RIGHTS
002495r 2  49 47 48 54  	.byte	"IGHT$(",TK_RIGHTS
002499r 2  24 28 E5     
00249Cr 2               					; RIGHT$(
00249Cr 2               LBB_RND
00249Cr 2  4E 44 28 CB  	.byte	"ND(",TK_RND	; RND(
0024A0r 2               LBB_RUN
0024A0r 2  55 4E 8A     	.byte	"UN",TK_RUN		; RUN
0024A3r 2  00           	.byte	$00
0024A4r 2               TAB_ASCS
0024A4r 2               LBB_SADD
0024A4r 2  41 44 44 28  	.byte	"ADD(",TK_SADD	; SADD(
0024A8r 2  D4           
0024A9r 2               LBB_SAVE
0024A9r 2  41 56 45 98  	.byte	"AVE",TK_SAVE	; SAVE
0024ADr 2               LBB_SGN
0024ADr 2  47 4E 28 C4  	.byte	"GN(",TK_SGN	; SGN(
0024B1r 2               LBB_SIN
0024B1r 2  49 4E 28 CF  	.byte	"IN(",TK_SIN	; SIN(
0024B5r 2               LBB_SPC
0024B5r 2  50 43 28 B0  	.byte	"PC(",TK_SPC	; SPC(
0024B9r 2               LBB_SQR
0024B9r 2  51 52 28 CA  	.byte	"QR(",TK_SQR	; SQR(
0024BDr 2               LBB_STEP
0024BDr 2  54 45 50 B3  	.byte	"TEP",TK_STEP	; STEP
0024C1r 2               LBB_STOP
0024C1r 2  54 4F 50 92  	.byte	"TOP",TK_STOP	; STOP
0024C5r 2               LBB_STRS
0024C5r 2  54 52 24 28  	.byte	"TR$(",TK_STRS	; STR$(
0024C9r 2  D6           
0024CAr 2               LBB_SWAP
0024CAr 2  57 41 50 A6  	.byte	"WAP",TK_SWAP	; SWAP
0024CEr 2               LBB_SYS
0024CEr 2  59 53 AB     	.byte   "YS", TK_SYS    ; SYS    *** added for SBC-2
0024D1r 2  00           	.byte	$00
0024D2r 2               TAB_ASCT
0024D2r 2               LBB_TAB
0024D2r 2  41 42 28 AC  	.byte	"AB(",TK_TAB	; TAB(
0024D6r 2               LBB_TAN
0024D6r 2  41 4E 28 D0  	.byte	"AN(",TK_TAN	; TAN(
0024DAr 2               LBB_THEN
0024DAr 2  48 45 4E B1  	.byte	"HEN",TK_THEN	; THEN
0024DEr 2               LBB_TO
0024DEr 2  4F AE        	.byte	"O",TK_TO		; TO
0024E0r 2               LBB_TWOPI
0024E0r 2  57 4F 50 49  	.byte	"WOPI",TK_TWOPI	; TWOPI
0024E4r 2  E2           
0024E5r 2  00           	.byte	$00
0024E6r 2               TAB_ASCU
0024E6r 2               LBB_UCASES
0024E6r 2  43 41 53 45  	.byte	"CASE$(",TK_UCASES
0024EAr 2  24 28 D9     
0024EDr 2               					; UCASE$(
0024EDr 2               LBB_UNTIL
0024EDr 2  4E 54 49 4C  	.byte	"NTIL",TK_UNTIL	; UNTIL
0024F1r 2  B4           
0024F2r 2               LBB_USR
0024F2r 2  53 52 28 C7  	.byte	"SR(",TK_USR	; USR(
0024F6r 2  00           	.byte	$00
0024F7r 2               TAB_ASCV
0024F7r 2               LBB_VAL
0024F7r 2  41 4C 28 D7  	.byte	"AL(",TK_VAL	; VAL(
0024FBr 2               LBB_VPTR
0024FBr 2  41 52 50 54  	.byte	"ARPTR(",TK_VPTR	; VARPTR(
0024FFr 2  52 28 E3     
002502r 2  00           	.byte	$00
002503r 2               TAB_ASCW
002503r 2               LBB_WAIT
002503r 2  41 49 54 96  	.byte	"AIT",TK_WAIT	; WAIT
002507r 2               LBB_WHILE
002507r 2  48 49 4C 45  	.byte	"HILE",TK_WHILE	; WHILE
00250Br 2  B5           
00250Cr 2               LBB_WIDTH
00250Cr 2  49 44 54 48  	.byte	"IDTH",TK_WIDTH	; WIDTH
002510r 2  A4           
002511r 2  00           	.byte	$00
002512r 2               TAB_POWR
002512r 2  BB 00        	.byte	TK_POWER,$00	; ^
002514r 2               
002514r 2               ; new decode table for LIST
002514r 2               ; Table is ..
002514r 2               ; byte - keyword length, keyword first character
002514r 2               ; word - pointer to rest of keyword from dictionary
002514r 2               
002514r 2               ; note if length is 1 then the pointer is ignored
002514r 2               
002514r 2               LAB_KEYT
002514r 2  03 45        	.byte	3,"E"
002516r 2  rr rr        	.word	LBB_END		; END
002518r 2  03 46        	.byte	3,"F"
00251Ar 2  rr rr        	.word	LBB_FOR		; FOR
00251Cr 2  04 4E        	.byte	4,"N"
00251Er 2  rr rr        	.word	LBB_NEXT		; NEXT
002520r 2  04 44        	.byte	4,"D"
002522r 2  rr rr        	.word	LBB_DATA		; DATA
002524r 2  05 49        	.byte	5,"I"
002526r 2  rr rr        	.word	LBB_INPUT		; INPUT
002528r 2  03 44        	.byte	3,"D"
00252Ar 2  rr rr        	.word	LBB_DIM		; DIM
00252Cr 2  04 52        	.byte	4,"R"
00252Er 2  rr rr        	.word	LBB_READ		; READ
002530r 2  03 4C        	.byte	3,"L"
002532r 2  rr rr        	.word	LBB_LET		; LET
002534r 2  03 44        	.byte	3,"D"
002536r 2  rr rr        	.word	LBB_DEC		; DEC
002538r 2  04 47        	.byte	4,"G"
00253Ar 2  rr rr        	.word	LBB_GOTO		; GOTO
00253Cr 2  03 52        	.byte	3,"R"
00253Er 2  rr rr        	.word	LBB_RUN		; RUN
002540r 2  02 49        	.byte	2,"I"
002542r 2  rr rr        	.word	LBB_IF		; IF
002544r 2  07 52        	.byte	7,"R"
002546r 2  rr rr        	.word	LBB_RESTORE		; RESTORE
002548r 2  05 47        	.byte	5,"G"
00254Ar 2  rr rr        	.word	LBB_GOSUB		; GOSUB
00254Cr 2  06 52        	.byte	6,"R"
00254Er 2  rr rr        	.word	LBB_RETIRQ		; RETIRQ
002550r 2  06 52        	.byte	6,"R"
002552r 2  rr rr        	.word	LBB_RETNMI		; RETNMI
002554r 2  06 52        	.byte	6,"R"
002556r 2  rr rr        	.word	LBB_RETURN		; RETURN
002558r 2  03 52        	.byte	3,"R"
00255Ar 2  rr rr        	.word	LBB_REM		; REM
00255Cr 2  04 53        	.byte	4,"S"
00255Er 2  rr rr        	.word	LBB_STOP		; STOP
002560r 2  02 4F        	.byte	2,"O"
002562r 2  rr rr        	.word	LBB_ON		; ON
002564r 2  04 4E        	.byte	4,"N"
002566r 2  rr rr        	.word	LBB_NULL		; NULL
002568r 2  03 49        	.byte	3,"I"
00256Ar 2  rr rr        	.word	LBB_INC		; INC
00256Cr 2  04 57        	.byte	4,"W"
00256Er 2  rr rr        	.word	LBB_WAIT		; WAIT
002570r 2  04 4C        	.byte	4,"L"
002572r 2  rr rr        	.word	LBB_LOAD		; LOAD
002574r 2  04 53        	.byte	4,"S"
002576r 2  rr rr        	.word	LBB_SAVE		; SAVE
002578r 2  03 44        	.byte	3,"D"
00257Ar 2  rr rr        	.word	LBB_DEF		; DEF
00257Cr 2  04 50        	.byte	4,"P"
00257Er 2  rr rr        	.word	LBB_POKE		; POKE
002580r 2  04 44        	.byte	4,"D"
002582r 2  rr rr        	.word	LBB_DOKE		; DOKE
002584r 2  04 43        	.byte	4,"C"
002586r 2  rr rr        	.word	LBB_CALL		; CALL
002588r 2  02 44        	.byte	2,"D"
00258Ar 2  rr rr        	.word	LBB_DO		; DO
00258Cr 2  04 4C        	.byte	4,"L"
00258Er 2  rr rr        	.word	LBB_LOOP		; LOOP
002590r 2  05 50        	.byte	5,"P"
002592r 2  rr rr        	.word	LBB_PRINT		; PRINT
002594r 2  04 43        	.byte	4,"C"
002596r 2  rr rr        	.word	LBB_CONT		; CONT
002598r 2  04 4C        	.byte	4,"L"
00259Ar 2  rr rr        	.word	LBB_LIST		; LIST
00259Cr 2  05 43        	.byte	5,"C"
00259Er 2  rr rr        	.word	LBB_CLEAR		; CLEAR
0025A0r 2  03 4E        	.byte	3,"N"
0025A2r 2  rr rr        	.word	LBB_NEW		; NEW
0025A4r 2  05 57        	.byte	5,"W"
0025A6r 2  rr rr        	.word	LBB_WIDTH		; WIDTH
0025A8r 2  03 47        	.byte	3,"G"
0025AAr 2  rr rr        	.word	LBB_GET		; GET
0025ACr 2  04 53        	.byte	4,"S"
0025AEr 2  rr rr        	.word	LBB_SWAP		; SWAP
0025B0r 2  06 42        	.byte	6,"B"
0025B2r 2  rr rr        	.word	LBB_BITSET		; BITSET
0025B4r 2  06 42        	.byte	6,"B"
0025B6r 2  rr rr        	.word	LBB_BITCLR		; BITCLR
0025B8r 2  03 49        	.byte	3,"I"
0025BAr 2  rr rr        	.word	LBB_IRQ		; IRQ
0025BCr 2  03 4E        	.byte	3,"N"
0025BEr 2  rr rr        	.word	LBB_NMI		; NMI
0025C0r 2  03 53        	.byte	3,"S"			;
0025C2r 2  rr rr        	.word	LBB_SYS			; SYS   *** Added for SBC-2
0025C4r 2               
0025C4r 2               
0025C4r 2               ; secondary commands (can't start a statement)
0025C4r 2               
0025C4r 2  04 54        	.byte	4,"T"
0025C6r 2  rr rr        	.word	LBB_TAB		; TAB
0025C8r 2  04 45        	.byte	4,"E"
0025CAr 2  rr rr        	.word	LBB_ELSE		; ELSE
0025CCr 2  02 54        	.byte	2,"T"
0025CEr 2  rr rr        	.word	LBB_TO		; TO
0025D0r 2  02 46        	.byte	2,"F"
0025D2r 2  rr rr        	.word	LBB_FN		; FN
0025D4r 2  04 53        	.byte	4,"S"
0025D6r 2  rr rr        	.word	LBB_SPC		; SPC
0025D8r 2  04 54        	.byte	4,"T"
0025DAr 2  rr rr        	.word	LBB_THEN		; THEN
0025DCr 2  03 4E        	.byte	3,"N"
0025DEr 2  rr rr        	.word	LBB_NOT		; NOT
0025E0r 2  04 53        	.byte	4,"S"
0025E2r 2  rr rr        	.word	LBB_STEP		; STEP
0025E4r 2  05 55        	.byte	5,"U"
0025E6r 2  rr rr        	.word	LBB_UNTIL		; UNTIL
0025E8r 2  05 57        	.byte	5,"W"
0025EAr 2  rr rr        	.word	LBB_WHILE		; WHILE
0025ECr 2  03 4F        	.byte	3,"O"
0025EEr 2  rr rr        	.word	LBB_OFF		; OFF
0025F0r 2               
0025F0r 2               ; opperators
0025F0r 2               
0025F0r 2  01 2B        	.byte	1,"+"
0025F2r 2  00 00        	.word	$0000			; +
0025F4r 2  01 2D        	.byte	1,"-"
0025F6r 2  00 00        	.word	$0000			; -
0025F8r 2  01 2A        	.byte	1,"*"
0025FAr 2  00 00        	.word	$0000			; *
0025FCr 2  01 2F        	.byte	1,"/"
0025FEr 2  00 00        	.word	$0000			; /
002600r 2  01 5E        	.byte	1,"^"
002602r 2  00 00        	.word	$0000			; ^
002604r 2  03 41        	.byte	3,"A"
002606r 2  rr rr        	.word	LBB_AND		; AND
002608r 2  03 45        	.byte	3,"E"
00260Ar 2  rr rr        	.word	LBB_EOR		; EOR
00260Cr 2  02 4F        	.byte	2,"O"
00260Er 2  rr rr        	.word	LBB_OR		; OR
002610r 2  02 3E        	.byte	2,">"
002612r 2  rr rr        	.word	LBB_RSHIFT		; >>
002614r 2  02 3C        	.byte	2,"<"
002616r 2  rr rr        	.word	LBB_LSHIFT		; <<
002618r 2  01 3E        	.byte	1,">"
00261Ar 2  00 00        	.word	$0000			; >
00261Cr 2  01 3D        	.byte	1,"="
00261Er 2  00 00        	.word	$0000			; =
002620r 2  01 3C        	.byte	1,"<"
002622r 2  00 00        	.word	$0000			; <
002624r 2               
002624r 2               ; functions
002624r 2               
002624r 2  04 53        	.byte	4,"S"			;
002626r 2  rr rr        	.word	LBB_SGN		; SGN
002628r 2  04 49        	.byte	4,"I"			;
00262Ar 2  rr rr        	.word	LBB_INT		; INT
00262Cr 2  04 41        	.byte	4,"A"			;
00262Er 2  rr rr        	.word	LBB_ABS		; ABS
002630r 2  04 55        	.byte	4,"U"			;
002632r 2  rr rr        	.word	LBB_USR		; USR
002634r 2  04 46        	.byte	4,"F"			;
002636r 2  rr rr        	.word	LBB_FRE		; FRE
002638r 2  04 50        	.byte	4,"P"			;
00263Ar 2  rr rr        	.word	LBB_POS		; POS
00263Cr 2  04 53        	.byte	4,"S"			;
00263Er 2  rr rr        	.word	LBB_SQR		; SQR
002640r 2  04 52        	.byte	4,"R"			;
002642r 2  rr rr        	.word	LBB_RND		; RND
002644r 2  04 4C        	.byte	4,"L"			;
002646r 2  rr rr        	.word	LBB_LOG		; LOG
002648r 2  04 45        	.byte	4,"E"			;
00264Ar 2  rr rr        	.word	LBB_EXP		; EXP
00264Cr 2  04 43        	.byte	4,"C"			;
00264Er 2  rr rr        	.word	LBB_COS		; COS
002650r 2  04 53        	.byte	4,"S"			;
002652r 2  rr rr        	.word	LBB_SIN		; SIN
002654r 2  04 54        	.byte	4,"T"			;
002656r 2  rr rr        	.word	LBB_TAN		; TAN
002658r 2  04 41        	.byte	4,"A"			;
00265Ar 2  rr rr        	.word	LBB_ATN		; ATN
00265Cr 2  05 50        	.byte	5,"P"			;
00265Er 2  rr rr        	.word	LBB_PEEK		; PEEK
002660r 2  05 44        	.byte	5,"D"			;
002662r 2  rr rr        	.word	LBB_DEEK		; DEEK
002664r 2  05 53        	.byte	5,"S"			;
002666r 2  rr rr        	.word	LBB_SADD		; SADD
002668r 2  04 4C        	.byte	4,"L"			;
00266Ar 2  rr rr        	.word	LBB_LEN		; LEN
00266Cr 2  05 53        	.byte	5,"S"			;
00266Er 2  rr rr        	.word	LBB_STRS		; STR$
002670r 2  04 56        	.byte	4,"V"			;
002672r 2  rr rr        	.word	LBB_VAL		; VAL
002674r 2  04 41        	.byte	4,"A"			;
002676r 2  rr rr        	.word	LBB_ASC		; ASC
002678r 2  07 55        	.byte	7,"U"			;
00267Ar 2  rr rr        	.word	LBB_UCASES		; UCASE$
00267Cr 2  07 4C        	.byte	7,"L"			;
00267Er 2  rr rr        	.word	LBB_LCASES		; LCASE$
002680r 2  05 43        	.byte	5,"C"			;
002682r 2  rr rr        	.word	LBB_CHRS		; CHR$
002684r 2  05 48        	.byte	5,"H"			;
002686r 2  rr rr        	.word	LBB_HEXS		; HEX$
002688r 2  05 42        	.byte	5,"B"			;
00268Ar 2  rr rr        	.word	LBB_BINS		; BIN$
00268Cr 2  07 42        	.byte	7,"B"			;
00268Er 2  rr rr        	.word	LBB_BITTST		; BITTST
002690r 2  04 4D        	.byte	4,"M"			;
002692r 2  rr rr        	.word	LBB_MAX		; MAX
002694r 2  04 4D        	.byte	4,"M"			;
002696r 2  rr rr        	.word	LBB_MIN		; MIN
002698r 2  02 50        	.byte	2,"P"			;
00269Ar 2  rr rr        	.word	LBB_PI		; PI
00269Cr 2  05 54        	.byte	5,"T"			;
00269Er 2  rr rr        	.word	LBB_TWOPI		; TWOPI
0026A0r 2  07 56        	.byte	7,"V"			;
0026A2r 2  rr rr        	.word	LBB_VPTR		; VARPTR
0026A4r 2  06 4C        	.byte	6,"L"			;
0026A6r 2  rr rr        	.word	LBB_LEFTS		; LEFT$
0026A8r 2  07 52        	.byte	7,"R"			;
0026AAr 2  rr rr        	.word	LBB_RIGHTS		; RIGHT$
0026ACr 2  05 4D        	.byte	5,"M"			;
0026AEr 2  rr rr        	.word	LBB_MIDS		; MID$
0026B0r 2               
0026B0r 2               ; BASIC messages, mostly error messages
0026B0r 2               
0026B0r 2               LAB_BAER
0026B0r 2  rr rr        	.word	ERR_NF		;$00 NEXT without FOR
0026B2r 2  rr rr        	.word	ERR_SN		;$02 syntax
0026B4r 2  rr rr        	.word	ERR_RG		;$04 RETURN without GOSUB
0026B6r 2  rr rr        	.word	ERR_OD		;$06 out of data
0026B8r 2  rr rr        	.word	ERR_FC		;$08 function call
0026BAr 2  rr rr        	.word	ERR_OV		;$0A overflow
0026BCr 2  rr rr        	.word	ERR_OM		;$0C out of memory
0026BEr 2  rr rr        	.word	ERR_US		;$0E undefined statement
0026C0r 2  rr rr        	.word	ERR_BS		;$10 array bounds
0026C2r 2  rr rr        	.word	ERR_DD		;$12 double dimension array
0026C4r 2  rr rr        	.word	ERR_D0		;$14 divide by 0
0026C6r 2  rr rr        	.word	ERR_ID		;$16 illegal direct
0026C8r 2  rr rr        	.word	ERR_TM		;$18 type mismatch
0026CAr 2  rr rr        	.word	ERR_LS		;$1A long string
0026CCr 2  rr rr        	.word	ERR_ST		;$1C string too complex
0026CEr 2  rr rr        	.word	ERR_CN		;$1E continue error
0026D0r 2  rr rr        	.word	ERR_UF		;$20 undefined function
0026D2r 2  rr rr        	.word ERR_LD		;$22 LOOP without DO
0026D4r 2               
0026D4r 2               ; I may implement these two errors to force definition of variables and
0026D4r 2               ; dimensioning of arrays before use.
0026D4r 2               
0026D4r 2               ;	.word ERR_UV		;$24 undefined variable
0026D4r 2               
0026D4r 2               ; the above error has been tested and works (see code and comments below LAB_1D8B)
0026D4r 2               
0026D4r 2               ;	.word ERR_UA		;$26 undimensioned array
0026D4r 2               
0026D4r 2  4E 45 58 54  ERR_NF	.byte	"NEXT without FOR",$00
0026D8r 2  20 77 69 74  
0026DCr 2  68 6F 75 74  
0026E5r 2  53 79 6E 74  ERR_SN	.byte	"Syntax",$00
0026E9r 2  61 78 00     
0026ECr 2  52 45 54 55  ERR_RG	.byte	"RETURN without GOSUB",$00
0026F0r 2  52 4E 20 77  
0026F4r 2  69 74 68 6F  
002701r 2  4F 75 74 20  ERR_OD	.byte	"Out of DATA",$00
002705r 2  6F 66 20 44  
002709r 2  41 54 41 00  
00270Dr 2  46 75 6E 63  ERR_FC	.byte	"Function call",$00
002711r 2  74 69 6F 6E  
002715r 2  20 63 61 6C  
00271Br 2  4F 76 65 72  ERR_OV	.byte	"Overflow",$00
00271Fr 2  66 6C 6F 77  
002723r 2  00           
002724r 2  4F 75 74 20  ERR_OM	.byte	"Out of memory",$00
002728r 2  6F 66 20 6D  
00272Cr 2  65 6D 6F 72  
002732r 2  55 6E 64 65  ERR_US	.byte	"Undefined statement",$00
002736r 2  66 69 6E 65  
00273Ar 2  64 20 73 74  
002746r 2  41 72 72 61  ERR_BS	.byte	"Array bounds",$00
00274Ar 2  79 20 62 6F  
00274Er 2  75 6E 64 73  
002753r 2  44 6F 75 62  ERR_DD	.byte	"Double dimension",$00
002757r 2  6C 65 20 64  
00275Br 2  69 6D 65 6E  
002764r 2  44 69 76 69  ERR_D0	.byte	"Divide by zero",$00
002768r 2  64 65 20 62  
00276Cr 2  79 20 7A 65  
002773r 2  49 6C 6C 65  ERR_ID	.byte	"Illegal direct",$00
002777r 2  67 61 6C 20  
00277Br 2  64 69 72 65  
002782r 2  54 79 70 65  ERR_TM	.byte	"Type mismatch",$00
002786r 2  20 6D 69 73  
00278Ar 2  6D 61 74 63  
002790r 2  53 74 72 69  ERR_LS	.byte	"String too long",$00
002794r 2  6E 67 20 74  
002798r 2  6F 6F 20 6C  
0027A0r 2  53 74 72 69  ERR_ST	.byte	"String too complex",$00
0027A4r 2  6E 67 20 74  
0027A8r 2  6F 6F 20 63  
0027B3r 2  43 61 6E 27  ERR_CN	.byte	"Can't continue",$00
0027B7r 2  74 20 63 6F  
0027BBr 2  6E 74 69 6E  
0027C2r 2  55 6E 64 65  ERR_UF	.byte	"Undefined function",$00
0027C6r 2  66 69 6E 65  
0027CAr 2  64 20 66 75  
0027D5r 2  4C 4F 4F 50  ERR_LD	.byte	"LOOP without DO",$00
0027D9r 2  20 77 69 74  
0027DDr 2  68 6F 75 74  
0027E5r 2               
0027E5r 2               ;ERR_UV	.byte	"Undefined variable",$00
0027E5r 2               
0027E5r 2               ; the above error has been tested and works (see code and comments below LAB_1D8B)
0027E5r 2               
0027E5r 2               ;ERR_UA	.byte	"Undimensioned array",$00
0027E5r 2               
0027E5r 2  0D 0A 42 72  LAB_BMSG	.byte	$0D,$0A,"Break",$00
0027E9r 2  65 61 6B 00  
0027EDr 2  20 45 72 72  LAB_EMSG	.byte	" Error",$00
0027F1r 2  6F 72 00     
0027F4r 2  20 69 6E 20  LAB_LMSG	.byte	" in line ",$00
0027F8r 2  6C 69 6E 65  
0027FCr 2  20 00        
0027FEr 2  0D 0A 52 65  LAB_RMSG	.byte	$0D,$0A,"Ready",$0D,$0A,$00
002802r 2  61 64 79 0D  
002806r 2  0A 00        
002808r 2               
002808r 2  20 45 78 74  LAB_IMSG	.byte	" Extra ignored",$0D,$0A,$00
00280Cr 2  72 61 20 69  
002810r 2  67 6E 6F 72  
002819r 2  20 52 65 64  LAB_REDO	.byte	" Redo from start",$0D,$0A,$00
00281Dr 2  6F 20 66 72  
002821r 2  6F 6D 20 73  
00282Cr 2               
00282Cr 2               AA_end_basic
00282Cr 2               
00282Cr 1               .include "main.asm"
00282Cr 2               .setcpu "65C02"
00282Cr 2               .code
00282Cr 2               ;---------------------------------------------------------------------
00282Cr 2               ;  SBC Firmware V5.1, 5-30-05, by Daryl Rictor
00282Cr 2               ;
00282Cr 2               ; ----------------- assembly instructions ----------------------------
00282Cr 2               ;               *=   $E800                ; start of operating system
00282Cr 2               ;Start_OS       jmp   MonitorBoot         ; easy access to monitor program
00282Cr 2  4C rr rr     Jmp_CR	   jmp   Print_CR
00282Fr 2  4C rr rr     Jmp_1sp	   jmp   Print1SP			; jump table for usable monitor
002832r 2  4C rr rr     Jmp_2sp	   jmp   Print2SP			; routines
002835r 2  4C rr rr     Jmp_xsp	   jmp   PrintXSP			; This will not change in future
002838r 2  4C rr rr     Jmp_nib	   jmp   PrintDig			; releases, only be added to
00283Br 2  4C rr rr     Jmp_byte	   jmp   Print1Byte
00283Er 2  4C rr rr     jmp_wrd	   jmp   Print2Byte
002841r 2  4C rr rr     jmp_bell	   jmp   Bell
002844r 2  4C rr rr     jmp_delay	   jmp   Delay
002847r 2  4C rr rr     jmp_scan	   jmp   Scan_input
00284Ar 2  4C rr rr     jmp_inp        jmp   Input_chr
00284Dr 2  4C rr rr     jmp_out        jmp   Output
002850r 2  4C rr rr     jmp_input	   jmp   Input
002853r 2  4C rr rr     jmp_input1     jmp   Input1
002856r 2               ;
002856r 2               ;
002856r 2               ;*********************************************************************
002856r 2               ;  local Zero-page variables
002856r 2               ;
002856r 2               Prompt         =     $32               ; 1 byte
002856r 2               linecnt        =     $33               ; 1 byte
002856r 2               Modejmp        =     $34               ; 1 byte
002856r 2               Hexdigcnt      =     $35               ; 1 byte
002856r 2               OPCtxtptr      =     $36               ; 1 byte
002856r 2               Memchr         =     $37               ; 1 byte
002856r 2               Startaddr      =     $38               ; 2 bytes
002856r 2               Startaddr_H    =     $39
002856r 2               Addrptr        =     $3a               ; 2 bytes
002856r 2               Addrptr_H       =    $3b
002856r 2               Hexdigits      =     $3c               ; 2 bytes
002856r 2               Hexdigits_H    =     $3d
002856r 2               Memptr         =     $3e               ; 2 bytes
002856r 2               Memptr_H       =     $3f
002856r 2               ;
002856r 2               ; Local Non-Zero Page Variables
002856r 2               ;
002856r 2               buffer         =     $0300             ; keybd input buffer (127 chrs max)
002856r 2               PCH            =     $03e0             ; hold program counter (need PCH next to PCL for Printreg routine)
002856r 2               PCL            =     $03e1             ;  ""
002856r 2               ACC            =     $03e2             ; hold Accumulator (A)
002856r 2               XREG           =     $03e3             ; hold X register
002856r 2               YREG           =     $03e4             ; hold Y register
002856r 2               SPTR           =     $03e5             ; hold stack pointer
002856r 2               PREG           =     $03e6             ; hold status register (P)
002856r 2               ChrInVect      =     $03eb             ; holds Character Input Address
002856r 2               ScanInVect     =     $03ee             ; holds Character Scan Input address
002856r 2               ChrOutVect     =     $03f1             ; holds Character Output Address
002856r 2               BRKvector      =     $03f4             ; holds application break vector
002856r 2               RESvector      =     $03f7             ; 2F7,8,9 holds application reset vector & checksum
002856r 2               INTvector      =     $03fa             ; 2FA,B,C holds application interrupt vector & checksum
002856r 2               NMIvector      =     $03fd             ; 2FD,E,F holds application NMI vector & checksum
002856r 2               
002856r 2               ;
002856r 2               ; *************************************************************************
002856r 2               ; kernal commands
002856r 2               ; *************************************************************************
002856r 2               ; PrintRegCR   - subroutine prints a CR, the register contents, CR, then returns
002856r 2               ; PrintReg     - same as PrintRegCR without leading CR
002856r 2               ; Print2Byte   - prints AAXX hex digits
002856r 2               ; Print1Byte   - prints AA hex digits
002856r 2               ; PrintDig     - prints A hex nibble (low 4 bits)
002856r 2               ; Print_CR     - prints a CR (ASCII 13)and LF (ASCII 10)
002856r 2               ; PrintXSP     - prints # of spaces in X Reg
002856r 2               ; Print2SP     - prints 2 spaces
002856r 2               ; Print1SP     - prints 1 space
002856r 2               ; Input_assem  - Alternate input prompt for Assember
002856r 2               ; Input        - print <CR> and prompt then get a line of input, store at buffer
002856r 2               ; Input_Chr    - get one byte from input port, waits for input
002856r 2               ; Scan_Input   - Checks for an input character (no waiting)
002856r 2               ; Output       - send one byte to the output port
002856r 2               ; Bell         - send ctrl-g (bell) to output port
002856r 2               ; Delay        - delay loop
002856r 2               ; *************************************************************************
002856r 2               ;
002856r 2  20 50 43 3D  RegData        .byte" PC=  A=  X=  Y=  S=  P= (NVRBDIZC)="
00285Ar 2  20 20 41 3D  
00285Er 2  20 20 58 3D  
00287Ar 2               ;
00287Ar 2  20 rr rr     PrintReg       Jsr   Print_CR          ; Lead with a CR
00287Dr 2  A2 FF                       ldx   #$ff              ;
00287Fr 2  A0 FF                       ldy   #$ff              ;
002881r 2  C8           Printreg1      iny                     ;
002882r 2  B9 rr rr                    lda   RegData,y         ;
002885r 2  20 rr rr                    jsr   Output            ;
002888r 2  C9 3D                       cmp   #$3D              ; "="
00288Ar 2  D0 F5                       bne   Printreg1         ;
00288Cr 2  E8           Printreg2      inx                     ;
00288Dr 2  E0 07                       cpx   #$07              ;
00288Fr 2  F0 0C                       beq   Printreg3         ; done with first 6
002891r 2  BD E0 03                    lda   PCH,x             ;
002894r 2  20 rr rr                    jsr   Print1Byte        ;
002897r 2  E0 00                       cpx   #$00              ;
002899r 2  D0 E6                       bne   Printreg1         ;
00289Br 2  80 EF                       bra   Printreg2         ;
00289Dr 2  CA           Printreg3      dex                     ;
00289Er 2  BD E0 03                    lda   PCH,x             ; get Preg
0028A1r 2  A2 08                       ldx   #$08              ;
0028A3r 2  2A           Printreg4      rol                     ;
0028A4r 2  A8                          tay                     ;
0028A5r 2  A9 31                       lda   #$31              ;
0028A7r 2  B0 01                       bcs   Printreg5         ;
0028A9r 2  3A                          dec                     ;
0028AAr 2  20 rr rr     Printreg5      jsr   Output            ;
0028ADr 2  98                          tya                     ;
0028AEr 2  CA                          dex                     ;
0028AFr 2  D0 F2                       bne   Printreg4         ;
0028B1r 2               ; fall into the print CR routine
0028B1r 2  48           Print_CR       PHA                     ; Save Acc
0028B2r 2  A9 0D                       LDA   #$0D              ; "cr"
0028B4r 2  20 rr rr                    JSR   Output            ; send it
0028B7r 2  A9 0A                       LDA   #$0A              ; "lf"
0028B9r 2  20 rr rr                    JSR   Output            ; send it
0028BCr 2  68                          PLA                     ; Restore Acc
0028BDr 2  60                          RTS                     ;
0028BEr 2               
0028BEr 2  20 rr rr     Print2Byte     JSR   Print1Byte        ;  prints AAXX hex digits
0028C1r 2  8A                          TXA                     ;
0028C2r 2  48           Print1Byte     PHA                     ;  prints AA hex digits
0028C3r 2  4A                          LSR                     ;  MOVE UPPER NIBBLE TO LOWER
0028C4r 2  4A                          LSR                     ;
0028C5r 2  4A                          LSR                     ;
0028C6r 2  4A                          LSR                     ;
0028C7r 2  20 rr rr                    JSR   PrintDig          ;
0028CAr 2  68                          PLA                     ;
0028CBr 2  5A           PrintDig       PHY                     ;  prints A hex nibble (low 4 bits)
0028CCr 2  29 0F                       AND   #$0F              ;
0028CEr 2  A8                          TAY                     ;
0028CFr 2  B9 rr rr                    LDA   Hexdigdata,Y      ;
0028D2r 2  7A                          PLY                     ;
0028D3r 2  4C rr rr                    jmp   Output            ;
0028D6r 2  20 rr rr     PrintXSP1      JSR   Print1SP          ;
0028D9r 2  CA                          dex                     ;
0028DAr 2  E0 00        PrintXSP       cpx   #$00              ;
0028DCr 2  D0 F8                       bne   PrintXSP1         ;
0028DEr 2  60                          rts                     ;
0028DFr 2  20 rr rr     Print2SP       jsr   Print1SP          ; print 2 SPACES
0028E2r 2  A9 20        Print1SP       LDA   #$20              ; print 1 SPACE
0028E4r 2  4C rr rr                    JMP   Output            ;
0028E7r 2               ;
0028E7r 2  A9 21        Input_Assem    lda   #$21              ; Assembler Prompt "!"
0028E9r 2  2C                          .byte $2c               ; mask out next line to bypass
0028EAr 2  A9 3E        Input          lda   #$3E              ; Monitor Prompt ">"
0028ECr 2  85 32                       sta   Prompt            ; save prompt chr
0028EEr 2  20 rr rr     Input1         jsr   Print_CR          ; New Line
0028F1r 2  A5 32                       lda   Prompt            ; get prompt
0028F3r 2  20 rr rr                    jsr   Output            ; Print Prompt
0028F6r 2  A0 FF                       ldy   #$ff              ; pointer
0028F8r 2  20 rr rr     InputWait      jsr   Input_chr         ; get a character
0028FBr 2  C9 20                       cmp   #$20              ; is ctrl char?
0028FDr 2  B0 3D                       BCS   InputSave         ; no, echo chr
0028FFr 2  C9 0D                       cmp   #$0d              ; cr
002901r 2  F0 4A                       Beq   InputDone         ; done
002903r 2  C9 1B                       cmp   #$1B              ; esc
002905r 2  F0 E7                       beq   Input1            ; cancel and new line
002907r 2  C9 08                       cmp   #$08              ; bs
002909r 2  F0 09                       beq   backspace         ;
00290Br 2  C9 09        		   cmp   #$09		   ; TAB key
00290Dr 2  F0 1B        		   beq   tabkey		   ;
00290Fr 2  C9 02                       cmp   #$02              ; Ctrl-B
002911r 2  D0 E5                       bne   InputWait         ; Ignore other codes
002913r 2  00                          brk                     ; Force a keyboard Break cmd
002914r 2  C0 FF        backspace      cpy   #$ff              ;
002916r 2  F0 E0                       beq   InputWait         ; nothing to do
002918r 2  88                          dey                     ; remove last char
002919r 2  A9 08                       Lda   #$08              ; backup one space
00291Br 2  20 rr rr                    jsr   Output            ;
00291Er 2  A9 20                       Lda   #$20              ; Print space (destructive BS)
002920r 2  20 rr rr                    jsr   Output            ;
002923r 2  A9 08                       Lda   #$08              ; backup one space
002925r 2  20 rr rr                    jsr   Output            ;
002928r 2  80 CE                       BRA   InputWait         ; ready for next key
00292Ar 2  A9 20        tabkey	   lda   #$20		   ; convert tab to space
00292Cr 2  C8           		   iny			   ; move cursor
00292Dr 2  30 1F                       bmi   InputTooLong	   ; line too long?
00292Fr 2  99 00 03                    sta   buffer,y		   ; no, save space in buffer
002932r 2  20 rr rr     		   jsr   Output		   ; print the space too
002935r 2  98                          tya   			   ; test to see if tab is on multiple of 8
002936r 2  29 07        		   and   #$07		   ; mask remainder of cursor/8
002938r 2  D0 F0                       bne   tabkey		   ; not done, add another space
00293Ar 2  80 BC        		   bra   InputWait	   ; done.
00293Cr 2  C9 61        InputSave      CMP   #$61              ;   ucase
00293Er 2  90 02                       BCC   InputSave1        ;
002940r 2  E9 20                       SBC   #$20              ;
002942r 2  C8           InputSave1     INY                     ;
002943r 2  30 09                       BMI   InputTooLong      ; get next char (up to 127)
002945r 2  99 00 03                    STA   buffer,y          ;
002948r 2  20 rr rr                    JSR   Output            ; OutputCharacter
00294Br 2  80 AB                       BRA   InputWait         ;
00294Dr 2  C8           InputDone      INY                     ;
00294Er 2  A9 0D        InputTooLong   LDA   #$0d              ; force CR at end of 128 characters
002950r 2  99 00 03                    sta   buffer,y          ;
002953r 2  20 rr rr                    JSR   Output            ;
002956r 2               ;               lda   #$0a              ; lf Char
002956r 2               ;               JSR   Output            ;
002956r 2  60                          RTS                     ;
002957r 2               ;
002957r 2  6C EB 03     Input_chr      jmp   (ChrInVect)       ;
00295Ar 2  6C EE 03     Scan_input     jmp   (ScanInVect)      ;
00295Dr 2  6C F1 03     Output         jmp   (ChrOutVect)      ;
002960r 2               ;
002960r 2  A9 07        Bell           LDA  #$07               ; Ctrl G Bell
002962r 2  4C rr rr                    jmp  Output             ;
002965r 2               ;
002965r 2  48           Delay          PHA                     ; use A to execute a delay loop
002966r 2  3A           delay1         DEC                     ;
002967r 2  D0 FD                       BNE   delay1            ;
002969r 2  68                          PLA                     ;
00296Ar 2  3A                          DEC                     ;
00296Br 2  D0 F8                       BNE   Delay             ;
00296Dr 2  60           GRTS           RTS                     ;
00296Er 2               ;
00296Er 2               ;
00296Er 2  8D E2 03     BRKroutine     sta   ACC               ; save A    Monitor"s break handler
002971r 2  8E E3 03                    stx   XREG              ; save X
002974r 2  8C E4 03                    sty   YREG              ; save Y
002977r 2  68                          pla                     ;
002978r 2  8D E6 03                    sta   PREG              ; save P
00297Br 2  68                          pla                     ; PCL
00297Cr 2  FA                          plx                     ; PCH
00297Dr 2  38                          sec                     ;
00297Er 2  E9 02                       sbc   #$02              ;
002980r 2  8D E1 03                    sta   PCL               ; backup to BRK cmd
002983r 2  B0 01                       bcs   Brk2              ;
002985r 2  CA                          dex                     ;
002986r 2  8E E0 03     Brk2           stx   PCH               ; save PC
002989r 2  BA                          TSX                     ; get stack pointer
00298Ar 2  8E E5 03                    stx   SPTR              ; save stack pointer
00298Dr 2  20 rr rr                    jsr   Bell              ; Beep speaker
002990r 2  20 rr rr                    jsr   PrintReg          ; dump register contents
002993r 2  A2 FF                       ldx   #$FF              ;
002995r 2  9A                          txs                     ; clear stack
002996r 2  58                          cli                     ; enable interrupts again
002997r 2                              ;jmp   Monitor           ; start the monitor
002997r 2               
002997r 2               ;
002997r 2               ;-----------DATA TABLES ------------------------------------------------
002997r 2               ;
002997r 2  30 31 32 33  Hexdigdata     .byte "0123456789ABCDEF";hex char table
00299Br 2  34 35 36 37  
00299Fr 2  38 39 41 42  
0029A7r 2               ;
0029A7r 2               
0029A7r 1               ; ----------------- assembly instructions ----------------------------
0029A7r 1               ;
0029A7r 1               ; this is a subroutine library only
0029A7r 1               ; it must be included in an executable source file
0029A7r 1               ;
0029A7r 1               ;
0029A7r 1               ;*** I/O Locations *******************************
0029A7r 1               ; define the i/o address of the ACIA1 chip
0029A7r 1               ;*** 6551 CIA ************************
0029A7r 1               ACIA1dat       =     $8200
0029A7r 1               ACIA1Sta       =     $8201
0029A7r 1               ACIA1cmd       =     $8202
0029A7r 1               ACIA1ctl       =     $8203
0029A7r 1               ;
0029A7r 1               ;***********************************************************************
0029A7r 1               ; 6551 I/O Support Routines
0029A7r 1               ;
0029A7r 1               .code
0029A7r 1  A2 rr        ACIA1_init     LDX   #<ACIA1_Input      ; set up RAM vectors for
0029A9r 1  A9 rr                       LDA   #>ACIA1_Input      ; Input, Output, and Scan
0029ABr 1  A8                          TAY                     	; Routines
0029ACr 1  49 A5                       EOR   #$A5              	;
0029AEr 1  8D ED 03                    sta   ChrInVect+2       	;
0029B1r 1  8C EC 03                    sty   ChrInVect+1       	;
0029B4r 1  8E EB 03                    stx   ChrInVect         	;
0029B7r 1  A2 rr                       LDX   #<ACIA1_Scan  	;
0029B9r 1  A9 rr                       LDA   #>ACIA1_Scan       ;
0029BBr 1  A8                          TAY                     	;
0029BCr 1  49 A5                       EOR   #$A5              	;
0029BEr 1  8D F0 03                    sta   ScanInVect+2      	;
0029C1r 1  8C EF 03                    sty   ScanInVect+1      	;
0029C4r 1  8E EE 03                    stx   ScanInVect        	;
0029C7r 1  A2 rr                       LDX   #<ACIA1_Output     ;
0029C9r 1  A9 rr                       LDA   #>ACIA1_Output     ;
0029CBr 1  A8                          TAY                     	;
0029CCr 1  49 A5                       EOR   #$A5              	;
0029CEr 1  8D F3 03                    sta   ChrOutVect+2      	;
0029D1r 1  8C F2 03                    sty   ChrOutVect+1      	;
0029D4r 1  8E F1 03                    stx   ChrOutVect        	;
0029D7r 1  A9 rr                       lda   #<ACIA1_Scan      	; setup BASIC vectors
0029D9r 1  8D 05 02                    sta   VEC_IN
0029DCr 1  A9 rr        	       lda   #>ACIA1_Scan	; BASIC's chr input
0029DEr 1  8D 06 02                    sta   VEC_IN+1
0029E1r 1  A9 rr                       lda   #<ACIA1_Output
0029E3r 1  8D 07 02                    sta   VEC_OUT
0029E6r 1  A9 rr        	       lda   #>ACIA1_Output	; BASIC's chr output
0029E8r 1  8D 08 02                    sta   VEC_OUT+1
0029EBr 1               	       ;lda   #<Psave
0029EBr 1                          ;    sta   VEC_SV
0029EBr 1               	       ;lda   #>Psave		; SAVE cmd
0029EBr 1                          ;    sta   VEC_SV+1
0029EBr 1               	       ;lda   #<pload
0029EBr 1                          ;    sta   VEC_LD
0029EBr 1               	       ;lda   #>pload		; LOAD cmd
0029EBr 1                          ;    sta   VEC_LD+1
0029EBr 1               
0029EBr 1  A9 1F        ACIA1portset   lda   #$1F               ; 19.2K/8/1
0029EDr 1  8D 03 82                    sta   ACIA1ctl           ; control reg
0029F0r 1  A9 0B                       lda   #$0B               ; N parity/echo off/rx int off/ dtr active low
0029F2r 1  8D 02 82                    sta   ACIA1cmd           ; command reg
0029F5r 1  60                          rts                      ; done
0029F6r 1               ;
0029F6r 1               ; input chr from ACIA1 (waiting)
0029F6r 1               ;
0029F6r 1               ACIA1_Input
0029F6r 1  AD 01 82                    lda   ACIA1Sta           ; Serial port status
0029F9r 1  29 08                       and   #$08               ; is recvr full
0029FBr 1  F0 F9                       beq   ACIA1_Input        ; no char to get
0029FDr 1  AD 00 82                    Lda   ACIA1dat           ; get chr
002A00r 1  60                          RTS                      ;
002A01r 1               ;
002A01r 1               ; non-waiting get character routine
002A01r 1               ;
002A01r 1  18           ACIA1_Scan     clc
002A02r 1  AD 01 82                    lda   ACIA1Sta           ; Serial port status
002A05r 1  29 08                       and   #$08               ; mask rcvr full bit
002A07r 1  F0 04                       beq   ACIA1_scan2
002A09r 1  AD 00 82                    Lda   ACIA1dat           ; get chr
002A0Cr 1  38           	         sec
002A0Dr 1  60           ACIA1_scan2    rts
002A0Er 1               ;
002A0Er 1               ; output to OutPut Port
002A0Er 1               ;
002A0Er 1  48           ACIA1_Output   PHA                      ; save registers
002A0Fr 1  AD 01 82     ACIA1_Out1     lda   ACIA1Sta           ; serial port status
002A12r 1  29 10                       and   #$10               ; is tx buffer empty
002A14r 1  F0 F9                       beq   ACIA1_Out1         ; no
002A16r 1  68                          PLA                      ; get chr
002A17r 1  8D 00 82                    sta   ACIA1dat           ; put character to Port
002A1Ar 1  60                          RTS                      ; done
002A1Br 1               ;
002A1Br 1               ;end of file
002A1Br 1               
